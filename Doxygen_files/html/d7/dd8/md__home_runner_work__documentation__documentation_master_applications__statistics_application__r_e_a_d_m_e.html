<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KratosMultiphysics: Statistics Application</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../kratos_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">KratosMultiphysics
   </div>
   <div id="projectbrief">KRATOS Multiphysics (Kratos) is a framework for building parallel, multi-disciplinary simulation software, aiming at modularity, extensibility, and high performance. Kratos is written in C++, and counts with an extensive Python interface.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Statistics Application </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Statistics application consist of widely used methods to calculate statistics in various containers of KratosMultiphysics. There are mainly two groups of statistical methods namely <b>Spatial</b> and <b><a class="el" href="../../de/d7a/class_temporal.html" title="A temporal controller to control behavior based on temporal values.">Temporal</a></b>. <b>Spatial</b> methods calculate statistics on spatial containers and output the values whenever they are called. <b><a class="el" href="../../de/d7a/class_temporal.html" title="A temporal controller to control behavior based on temporal values.">Temporal</a></b> methods calculate statistics on the fly in a transient simulation. All the temporal methods gurantee that, the resultant statistics will be same as the ones if one calculates accumulating all the data upto that time instance and calculate the same statistics. All of these methods in each group is <code>OpenMP</code> and <code>MPI</code> compatible, and tested.</p>
<p>Following table summarize capabilities of Statistics Application.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Statistical Methods   </th><th class="markdownTableHeadNone">Norm Types   </th><th class="markdownTableHeadNone">Spatial Domain   </th><th class="markdownTableHeadNone"><a class="el" href="../../de/d7a/class_temporal.html" title="A temporal controller to control behavior based on temporal values.">Temporal</a> Domain   </th><th class="markdownTableHeadNone">Data types    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="../../#sum">Sum</a>   </td><td class="markdownTableBodyNone"><a href="../../#value">Value</a>   </td><td class="markdownTableBodyNone"><a href="../../#spatial-methods">Spatial methods</a>   </td><td class="markdownTableBodyNone"><a href="../../#temporal-methods">Temporal methods</a>   </td><td class="markdownTableBodyNone">Double    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="../../#mean">Mean</a>   </td><td class="markdownTableBodyNone"><a href="../../#magnitude">Magnitude</a>   </td><td class="markdownTableBodyNone"><a href="../../#spatial-containers">Spatial containers</a>   </td><td class="markdownTableBodyNone"><a href="../../#temporal-containers">Temporal containers</a>   </td><td class="markdownTableBodyNone">Array 3D    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="../../#root-mean-square">Root mean square</a>   </td><td class="markdownTableBodyNone"><a href="../../#euclidean">Euclidean</a>   </td><td class="markdownTableBodyNone"><a href="../../#spatial-nodal-historical">nodal_historical</a>   </td><td class="markdownTableBodyNone"><a href="../../#temporal-nodal-historical-historical">nodal_historical_historical</a>   </td><td class="markdownTableBodyNone">Vector    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="../../#variance">Variance</a>   </td><td class="markdownTableBodyNone"><a href="../../#infinity">Infinity</a>   </td><td class="markdownTableBodyNone"><a href="../../#spatial-nodal-non-historical">nodal_non_historical</a>   </td><td class="markdownTableBodyNone"><a href="../../#temporal-nodal-historical-non-historical">nodal_historical_non_historical</a>   </td><td class="markdownTableBodyNone">Matrix    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="../../#min">Min</a>   </td><td class="markdownTableBodyNone"><a href="../../#p-norm">P-Norm</a>   </td><td class="markdownTableBodyNone"><a href="../../#spatial-condition-non-historical">condition_non_historical</a>   </td><td class="markdownTableBodyNone"><a href="../../#temporal-nodal-non-historical">nodal_non_historical</a>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="../../#max">Max</a>   </td><td class="markdownTableBodyNone"><a href="../../#lpq-norm">Lpq-Norm</a>   </td><td class="markdownTableBodyNone"><a href="../../#spatial-element-non-historical">element_non_historical</a>   </td><td class="markdownTableBodyNone"><a href="../../#temporal-element-non-historical">element_non_historical</a>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="../../#median">Median</a>   </td><td class="markdownTableBodyNone"><a href="../../#frobenius">Frobenius</a>   </td><td class="markdownTableBodyNone"><a href="../../#spatial-statistics-process">Spatial statistics process</a>   </td><td class="markdownTableBodyNone"><a href="../../#temporal-condition-non-historical">condition_non_historical</a>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="../../#distribution">Distribution</a>   </td><td class="markdownTableBodyNone"><a href="../../#trace">Trace</a>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><a href="../../#temporal-statistics-process">Temporal statistics process</a>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="../../#norm-methods">Norm methods</a>   </td><td class="markdownTableBodyNone"><a href="../../#index-based">Index</a>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><a href="../../#component-based">Component</a>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
</table>
<h1>JSON Examples</h1>
<p>If you prefer to use statistics of a simulation using <a class="el" href="../../db/d39/namespace_statistics_application.html">StatisticsApplication</a>, there is <code><a class="el" href="../../dd/db8/namespacespatial__statistics__process.html">spatial_statistics_process</a></code> for spatial statistics calculations and <code><a class="el" href="../../d5/d6e/namespacetemporal__statistics__process.html">temporal_statistics_process</a></code> for temporal statistics. These processes can be included via JSON settings under <code>auxiliary_processes</code>.</p>
<h2>Spatial statistics process examples</h2>
<p>Following example illustrates different methods used in different containers with different norms. <code>input_variable_settings</code> holds an array of methods for specified containers, specified norm and specified variables. They can be customized for your requirement. <code>output_settings</code> holds information about how the output should be handled.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">                &quot;kratos_module&quot; : &quot;KratosMultiphysics.StatisticsApplication&quot;,</div>
<div class="line">                &quot;python_module&quot; : &quot;spatial_statistics_process&quot;,</div>
<div class="line">                &quot;Parameters&quot; : {</div>
<div class="line">                    &quot;model_part_name&quot; : &quot;test_model_part&quot;,</div>
<div class="line">                    &quot;input_variable_settings&quot; : [</div>
<div class="line">                        {</div>
<div class="line">                            &quot;method_name&quot;    : &quot;sum&quot;,</div>
<div class="line">                            &quot;norm_type&quot;      : &quot;none&quot;,</div>
<div class="line">                            &quot;container&quot;      : &quot;nodal_historical&quot;,</div>
<div class="line">                            &quot;variable_names&quot; : [&quot;PRESSURE&quot;, &quot;VELOCITY&quot;],</div>
<div class="line">                            &quot;method_settings&quot;: {}</div>
<div class="line">                        },</div>
<div class="line">                        {</div>
<div class="line">                            &quot;method_name&quot;    : &quot;mean&quot;,</div>
<div class="line">                            &quot;norm_type&quot;      : &quot;none&quot;,</div>
<div class="line">                            &quot;container&quot;      : &quot;nodal_non_historical&quot;,</div>
<div class="line">                            &quot;variable_names&quot; : [&quot;PRESSURE&quot;, &quot;VELOCITY&quot;],</div>
<div class="line">                            &quot;method_settings&quot;: {}</div>
<div class="line">                        },</div>
<div class="line">                        {</div>
<div class="line">                            &quot;method_name&quot;    : &quot;variance&quot;,</div>
<div class="line">                            &quot;norm_type&quot;      : &quot;none&quot;,</div>
<div class="line">                            &quot;container&quot;      : &quot;element_non_historical&quot;,</div>
<div class="line">                            &quot;variable_names&quot; : [&quot;PRESSURE&quot;, &quot;VELOCITY&quot;],</div>
<div class="line">                            &quot;method_settings&quot;: {}</div>
<div class="line">                        },</div>
<div class="line">                        {</div>
<div class="line">                            &quot;method_name&quot;    : &quot;rootmeansquare&quot;,</div>
<div class="line">                            &quot;norm_type&quot;      : &quot;none&quot;,</div>
<div class="line">                            &quot;container&quot;      : &quot;condition_non_historical&quot;,</div>
<div class="line">                            &quot;variable_names&quot; : [&quot;PRESSURE&quot;, &quot;VELOCITY&quot;],</div>
<div class="line">                            &quot;method_settings&quot;: {}</div>
<div class="line">                        },</div>
<div class="line">                        {</div>
<div class="line">                            &quot;method_name&quot;    : &quot;sum&quot;,</div>
<div class="line">                            &quot;norm_type&quot;      : &quot;magnitude&quot;,</div>
<div class="line">                            &quot;container&quot;      : &quot;nodal_historical&quot;,</div>
<div class="line">                            &quot;variable_names&quot; : [&quot;PRESSURE&quot;, &quot;VELOCITY&quot;, &quot;LOAD_MESHES&quot;, &quot;GREEN_LAGRANGE_STRAIN_TENSOR&quot;],</div>
<div class="line">                            &quot;method_settings&quot;: {}</div>
<div class="line">                        },</div>
<div class="line">                        {</div>
<div class="line">                            &quot;method_name&quot;    : &quot;mean&quot;,</div>
<div class="line">                            &quot;norm_type&quot;      : &quot;pnorm_2.5&quot;,</div>
<div class="line">                            &quot;container&quot;      : &quot;nodal_non_historical&quot;,</div>
<div class="line">                            &quot;variable_names&quot; : [&quot;VELOCITY&quot;, &quot;LOAD_MESHES&quot;, &quot;GREEN_LAGRANGE_STRAIN_TENSOR&quot;],</div>
<div class="line">                            &quot;method_settings&quot;: {}</div>
<div class="line">                        },</div>
<div class="line">                        {</div>
<div class="line">                            &quot;method_name&quot;    : &quot;variance&quot;,</div>
<div class="line">                            &quot;norm_type&quot;      : &quot;component_x&quot;,</div>
<div class="line">                            &quot;container&quot;      : &quot;condition_non_historical&quot;,</div>
<div class="line">                            &quot;variable_names&quot; : [&quot;VELOCITY&quot;],</div>
<div class="line">                            &quot;method_settings&quot;: {}</div>
<div class="line">                        },</div>
<div class="line">                        {</div>
<div class="line">                            &quot;method_name&quot;    : &quot;rootmeansquare&quot;,</div>
<div class="line">                            &quot;norm_type&quot;      : &quot;index_3&quot;,</div>
<div class="line">                            &quot;container&quot;      : &quot;nodal_non_historical&quot;,</div>
<div class="line">                            &quot;variable_names&quot; : [&quot;LOAD_MESHES&quot;],</div>
<div class="line">                            &quot;method_settings&quot;: {}</div>
<div class="line">                        },</div>
<div class="line">                        {</div>
<div class="line">                            &quot;method_name&quot;    : &quot;min&quot;,</div>
<div class="line">                            &quot;norm_type&quot;      : &quot;frobenius&quot;,</div>
<div class="line">                            &quot;container&quot;      : &quot;nodal_non_historical&quot;,</div>
<div class="line">                            &quot;variable_names&quot; : [&quot;GREEN_LAGRANGE_STRAIN_TENSOR&quot;],</div>
<div class="line">                            &quot;method_settings&quot;: {}</div>
<div class="line">                        }</div>
<div class="line">                    ],</div>
<div class="line">                    &quot;output_settings&quot; : {</div>
<div class="line">                        &quot;output_control_variable&quot;: &quot;STEP&quot;,</div>
<div class="line">                        &quot;output_time_interval&quot;   : 1,</div>
<div class="line">                        &quot;write_kratos_version&quot;   : false,</div>
<div class="line">                        &quot;write_time_stamp&quot;       : false,</div>
<div class="line">                        &quot;output_file_settings&quot;   : {</div>
<div class="line">                            &quot;file_name&quot;  : &quot;&lt;model_part_name&gt;_&lt;container&gt;_&lt;norm_type&gt;_&lt;method_name&gt;.dat&quot;,</div>
<div class="line">                            &quot;output_path&quot;: &quot;spatial_statistics_process&quot;,</div>
<div class="line">                            &quot;write_buffer_size&quot; : -1</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
</div><!-- fragment --><h2><a class="el" href="../../de/d7a/class_temporal.html" title="A temporal controller to control behavior based on temporal values.">Temporal</a> statistics process example</h2>
<p>Following is an example on how to use <code><a class="el" href="../../d5/d6e/namespacetemporal__statistics__process.html">temporal_statistics_process</a></code> in json. The output variables data type should be matched with the input variables order and the data type for <code>"norm_type" = "none"</code>. If <code>"norm_type" != "none"</code>, then output variables should be <code>scalars</code>. If <code>"container" = "nodal_historical_historical"</code> is used as the container type, then output variables should be added to <code>NodalSolutionStepVariables</code> list in <a class="el" href="../../db/d66/namespace_kratos.html" title="REF: G. R. Cowper, GAUSSIAN QUADRATURE FORMULAS FOR TRIANGLES.">Kratos</a> since this container type outputs temporal statistics variables to nodal historical container. This json settings also can be added to <code>auxiliary_processes</code> list.</p>
<p>For details about all the available statistical methods, norm_types, etc, please refer to rest of the <code>README.md</code> file.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    &quot;kratos_module&quot;: &quot;KratosMultiphysics.StatisticsApplication&quot;,</div>
<div class="line">    &quot;python_module&quot;: &quot;temporal_statistics_process&quot;,</div>
<div class="line">    &quot;Parameters&quot;: {</div>
<div class="line">        &quot;model_part_name&quot;: &quot;FluidModelPart.fluid_computational_model_part&quot;,</div>
<div class="line">        &quot;input_variable_settings&quot;: [</div>
<div class="line">            {</div>
<div class="line">                &quot;method_name&quot;: &quot;variance&quot;,</div>
<div class="line">                &quot;norm_type&quot;: &quot;none&quot;,</div>
<div class="line">                &quot;container&quot;: &quot;nodal_historical_non_historical&quot;,</div>
<div class="line">                &quot;echo_level&quot;: 1,</div>
<div class="line">                &quot;method_settings&quot;: {</div>
<div class="line">                    &quot;input_variables&quot;: [</div>
<div class="line">                        &quot;VELOCITY&quot;,</div>
<div class="line">                        &quot;PRESSURE&quot;</div>
<div class="line">                    ],</div>
<div class="line">                    &quot;output_mean_variables&quot;: [</div>
<div class="line">                        &quot;VECTOR_3D_MEAN&quot;,</div>
<div class="line">                        &quot;SCALAR_MEAN&quot;</div>
<div class="line">                    ],</div>
<div class="line">                    &quot;output_variance_variables&quot;: [</div>
<div class="line">                        &quot;VECTOR_3D_VARIANCE&quot;,</div>
<div class="line">                        &quot;SCALAR_VARIANCE&quot;</div>
<div class="line">                    ]</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        ],</div>
<div class="line">        &quot;statistics_start_point_control_variable_name&quot;: &quot;TIME&quot;,</div>
<div class="line">        &quot;statistics_start_point_control_value&quot;: 2.5</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1>Method definitions</h1>
<p>There are two types of methods under each <b>Spatial</b> and <b><a class="el" href="../../de/d7a/class_temporal.html" title="A temporal controller to control behavior based on temporal values.">Temporal</a></b> method groups. They are namely <b>Value</b> and <b>Norm</b> methods. In these methods, <code>i</code> index refers to spatial domain element index, and <code>k</code> index refers to time step.</p>
<h2>Value methods</h2>
<h3>Sum</h3>
<p>In the case of spatial domain, it adds up all the variable values for a given container and returns summed up value as shown in following equation. x<sub>i</sub> is the i<sup>th</sup> element's variable value of the corresponding container. Result will have the same type as the type of the variable specified by the user</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=\color{Black}{\underline{r}&space;=&space;\sum_{i=1}^N{\underline{x}_i}}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\color{Black}{\underline{r}&space;=&space;\sum_{i=1}^N{\underline{x}_i}}" alt="" title="\color{Black}{\underline{r} = \sum_{i=1}^N{\underline{x}_i}}" class="inline"/></a></p>
<p>Following is an example of summation of non historical <code>VELOCITY</code> over the whole model part's nodes</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">sum = KratosStats.SpatialMethods.NonHistorical.Nodes.ValueMethods.Sum(model_part, Kratos.VELOCITY)</div>
</div><!-- fragment --><p>In the case of temporal domain, <b>Sum</b> methods is the time integrated quantity for a specific variable. It will be stored each element under user specified variable and a user specified container. x<sub>i</sub> is the i<sup>th</sup> element's variable value of the corresponding container. Result will have the same type as the type of the variable specified by the user.</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=\color{Black}{\underline{r}&space;=&space;\sum_{k=1}^{P}{\underline{x}_k\Delta&space;t_k}&space;\quad&space;where&space;\quad&space;\Delta&space;t_k&space;=&space;T_{k}&space;-&space;T_{k-1}&space;\quad&space;\forall&space;T_k&space;\in&space;\left\lbrace&space;T_{initial},&space;...,&space;T_{end}&space;\right\rbrace}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\color{Black}{\underline{r}&space;=&space;\sum_{k=1}^{P}{\underline{x}_k\Delta&space;t_k}&space;\quad&space;where&space;\quad&space;\Delta&space;t_k&space;=&space;T_{k}&space;-&space;T_{k-1}&space;\quad&space;\forall&space;T_k&space;\in&space;\left\lbrace&space;T_{initial},&space;...,&space;T_{end}&space;\right\rbrace}" alt="" title="\color{Black}{\underline{r} = \sum_{k=1}^{P}{\underline{x}_k\Delta t_k} \quad where \quad \Delta t_k = T_{k} - T_{k-1} \quad \forall T_k \in \left\lbrace T_{initial}, ..., T_{end} \right\rbrace}" class="inline"/></a></p>
<p>Following is an example of integration calculation of non historical velocity. Input variable is node's non-historical container's <code>VELOCITY</code> and output variable is same containers <code>DISPLACEMENT</code> where integrated value will be stored for each node. The <code>0</code> represents echo level for this method object. Blank "" indicates that value method is used.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">sum_method = KratosStats.TemporalMethods.NonHistorical.Nodes.ValueMethods.Sum.Array(model_part, &quot;&quot;, Kratos.VELOCITY, 0, Kratos.DISPLACEMENT)</div>
<div class="line">integration_starting_time = 2.0</div>
<div class="line">sum_method.InitializeStatisticsMethod(integration_starting_time)</div>
<div class="line">for t in range(3, 6):</div>
<div class="line">    sum_method.CalculateStatistics()</div>
</div><!-- fragment --><h3>Mean</h3>
<p>In the case of spatial domain, it calculates mean of a given variable for a given container and returns it as shown in following equation. x<sub>i</sub> is the i<sup>th</sup> element's variable value of the corresponding container. Result will have the same type as the type of the variable specified by the user. (If it has higher dimension than a scalar, mean of each dimension will be calculated seperately resulting with a mean having same dimension as the input dimension)</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=\color{Black}{\underline{r}&space;=&space;\frac{1}{N}\sum_{i=1}^{N}\underline{x}_i}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\color{Black}{\underline{r}&space;=&space;\frac{1}{N}\sum_{i=1}^{N}\underline{x}_i}" alt="" title="\color{Black}{\underline{r} = \frac{1}{N}\sum_{i=1}^{N}\underline{x}_i}" class="inline"/></a></p>
<p>Following is an example of mean calculation of non historical <code>VELOCITY</code> over the whole model part's nodes</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">mean = KratosStats.SpatialMethods.NonHistorical.Nodes.ValueMethods.Mean(model_part, Kratos.VELOCITY)</div>
</div><!-- fragment --><p>In the case of temporal domain, <b>Mean</b> methods is the time integrated quantity's mean for a specific variable. It will be stored each element under user specified variable and a user specified container. x<sub>i</sub> is the i<sup>th</sup> element's variable value of the corresponding container. Result will have the same type as the type of the variable specified by the user preserving the dimensionality as in the spatial case.</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=\color{Black}{\underline{\bar{x}}&space;=&space;\frac{1}{T_{total}}\sum_{k=1}^{P}{\underline{x}_k\Delta&space;t_k}&space;\quad&space;where&space;\quad&space;T_{total}&space;=&space;T_{end}&space;-&space;T_{initial}&space;\quad&space;and&space;\quad&space;\Delta&space;t_k&space;=&space;T_{k}&space;-&space;T_{k-1}&space;\quad&space;\forall&space;T_k&space;\in&space;\left\lbrace&space;T_{initial},&space;...,&space;T_{end}&space;\right\rbrace}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\color{Black}{\underline{\bar{x}}&space;=&space;\frac{1}{T_{total}}\sum_{k=1}^{P}{\underline{x}_k\Delta&space;t_k}&space;\quad&space;where&space;\quad&space;T_{total}&space;=&space;T_{end}&space;-&space;T_{initial}&space;\quad&space;and&space;\quad&space;\Delta&space;t_k&space;=&space;T_{k}&space;-&space;T_{k-1}&space;\quad&space;\forall&space;T_k&space;\in&space;\left\lbrace&space;T_{initial},&space;...,&space;T_{end}&space;\right\rbrace}" alt="" title="\color{Black}{\underline{\bar{x}} = \frac{1}{T_{total}}\sum_{k=1}^{P}{\underline{x}_k\Delta t_k} \quad where \quad T_{total} = T_{end} - T_{initial} \quad and \quad \Delta t_k = T_{k} - T_{k-1} \quad \forall T_k \in \left\lbrace T_{initial}, ..., T_{end} \right\rbrace}" class="inline"/></a></p>
<p>Following is an example of mean calculation of non historical velocity. Input variable is node's non-historical container's <code>VELOCITY</code> and output variable is same containers <code>VECTOR_3D_MEAN</code> where mean will be stored for each node. The <code>0</code> represents echo level for this method object. Blank "" indicates that value method is used.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">mean_method = KratosStats.TemporalMethods.NonHistorical.Nodes.ValueMethods.Mean.Array(model_part, &quot;&quot;, Kratos.VELOCITY, 0, KratosStats.VECTOR_3D_MEAN)</div>
<div class="line">integration_starting_time = 2.0</div>
<div class="line">mean_method.InitializeStatisticsMethod(integration_starting_time)</div>
<div class="line">for t in range(3, 6):</div>
<div class="line">    mean_method.CalculateStatistics()</div>
</div><!-- fragment --><h3>Root mean square</h3>
<p>In the case of spatial domain, it calculates root mean square of a given variable for a given container and returns it as shown in following equation. x<sub>i</sub> is the i<sup>th</sup> element's variable value of the corresponding container. Result will have the same type as the type of the variable specified by the user. (If it has higher dimension than a scalar, root mean square of each dimension will be calculated seperately resulting with a mean having same dimension as the input dimension)</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=\color{Black}{\underline{r}&space;=&space;\sqrt{\frac{1}{N}\sum_{i=1}^{N}{\underline{x}^2_i}&space;}}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\color{Black}{\underline{r}&space;=&space;\sqrt{\frac{1}{N}\sum_{i=1}^{N}{\underline{x}^2_i}&space;}}" alt="" title="\color{Black}{\underline{r} = \sqrt{\frac{1}{N}\sum_{i=1}^{N}{\underline{x}^2_i} }}" class="inline"/></a></p>
<p>Following is an example of root mean square calculation of non historical <code>VELOCITY</code> over the whole model part's nodes</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">rms = KratosStats.SpatialMethods.NonHistorical.Nodes.ValueMethods.RootMeanSquare(model_part, Kratos.VELOCITY)</div>
</div><!-- fragment --><p>In the case of temporal domain, <b>Root Mean Square</b> methods is the time integrated quantity's root mean square for a specific variable. It will be stored each element under user specified variable and a user specified container. x<sub>i</sub> is the i<sup>th</sup> element's variable value of the corresponding container. Result will have the same type as the type of the variable specified by the user preserving the dimensionality as in the spatial case.</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=\color{Black}{\underline{r}&space;=&space;\sqrt{\frac{1}{T_{total}}\sum_{k=1}^{P}{\underline{x}_k^2\Delta&space;t_k}}&space;\quad&space;where&space;\quad&space;T_{total}&space;=&space;T_{end}&space;-&space;T_{initial}&space;\quad&space;and&space;\quad&space;\Delta&space;t_k&space;=&space;T_{k}&space;-&space;T_{k-1}&space;\quad&space;\forall&space;T_k&space;\in&space;\left\lbrace&space;T_{initial},&space;...,&space;T_{end}&space;\right\rbrace}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\color{Black}{\underline{r}&space;=&space;\sqrt{\frac{1}{T_{total}}\sum_{k=1}^{P}{\underline{x}_k^2\Delta&space;t_k}}&space;\quad&space;where&space;\quad&space;T_{total}&space;=&space;T_{end}&space;-&space;T_{initial}&space;\quad&space;and&space;\quad&space;\Delta&space;t_k&space;=&space;T_{k}&space;-&space;T_{k-1}&space;\quad&space;\forall&space;T_k&space;\in&space;\left\lbrace&space;T_{initial},&space;...,&space;T_{end}&space;\right\rbrace}" alt="" title="\color{Black}{\underline{r} = \sqrt{\frac{1}{T_{total}}\sum_{k=1}^{P}{\underline{x}_k^2\Delta t_k}} \quad where \quad T_{total} = T_{end} - T_{initial} \quad and \quad \Delta t_k = T_{k} - T_{k-1} \quad \forall T_k \in \left\lbrace T_{initial}, ..., T_{end} \right\rbrace}" class="inline"/></a></p>
<p>Following is an example of root mean square calculation of non historical velocity. Input variable is node's non-historical container's <code>VELOCITY</code> and output variable is same containers <code>VECTOR_3D_MEAN</code> where root mean square value will be stored for each node. The <code>0</code> represents echo level for this method object. Blank "" indicates that value method is used.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">rms_method = KratosStats.TemporalMethods.NonHistorical.Nodes.ValueMethods.RootMeanSquare.Array(model_part, &quot;&quot;, Kratos.VELOCITY, 0, KratosStats.VECTOR_3D_MEAN)</div>
<div class="line">integration_starting_time = 2.0</div>
<div class="line">rms_method.InitializeStatisticsMethod(integration_starting_time)</div>
<div class="line">for t in range(3, 6):</div>
<div class="line">    rms_method.CalculateStatistics()</div>
</div><!-- fragment --><h3>Variance</h3>
<p>In the case of spatial domain, it calculates variance of a given variable for a given container and returns mean and variance as shown in following equations. x<sub>i</sub> is the i<sup>th</sup> element's variable value of the corresponding container. Results will have the same type as the type of the variable specified by the user. (If it has higher dimension than a scalar, mean of each dimension will be calculated seperately resulting with a mean having same dimension as the input dimension)</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=\color{Black}{\underline{\bar{x}}&space;=&space;\frac{1}{N}\sum_{i=1}^N{\underline{x}_i}}&space;\\&space;\color{Black}{\underline{v}&space;=&space;\frac{1}{N}\sum_{i=1}^N{\left(\underline{x}_i&space;-&space;\underline{\bar{x}}&space;\right&space;)^2}}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\color{Black}{\underline{\bar{x}}&space;=&space;\frac{1}{N}\sum_{i=1}^N{\underline{x}_i}}&space;\\&space;\color{Black}{\underline{v}&space;=&space;\frac{1}{N}\sum_{i=1}^N{\left(\underline{x}_i&space;-&space;\underline{\bar{x}}&space;\right&space;)^2}}" alt="" title="\color{Black}{\underline{\bar{x}} = \frac{1}{N}\sum_{i=1}^N{\underline{x}_i}} \\ \color{Black}{\underline{v} = \frac{1}{N}\sum_{i=1}^N{\left(\underline{x}_i - \underline{\bar{x}} \right )^2}}" class="inline"/></a></p>
<p>Following is an example of variance calculation of non historical <code>VELOCITY</code> over the whole model part's nodes</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">mean, variance = KratosStats.SpatialMethods.NonHistorical.Nodes.ValueMethods.Variance(model_part, Kratos.VELOCITY)</div>
</div><!-- fragment --><p>In the case of temporal domain, <b>Variance</b> method is the time integrated quantity's variance for a specific variable. Mean and variance will be stored each element under user specified variables and a user specified container. x<sub>i</sub> is the i<sup>th</sup> element's variable value of the corresponding container. Results will have the same type as the type of the variable specified by the user preserving the dimensionality as in the spatial case.</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=\color{Black}{\underline{\bar{x}}&space;=&space;\frac{1}{T_{total}}\sum_{k=1}^{P}{\underline{x}_k\Delta&space;t_k}}&space;\\&space;\color{Black}{Var\left(\underline{x}&space;\right&space;)&space;=&space;\frac{1}{T_{total}}\sum_{k=1}^{P}{\left(\underline{x}_k&space;-&space;\underline{\bar{x}}&space;\right&space;)^2\Delta&space;t_k}}&space;\\&space;\\&space;\color{Black}{&space;\quad&space;where}&space;\\&space;\\&space;\color{Black}{&space;T_{total}&space;=&space;T_{end}&space;-&space;T_{initial}&space;\quad&space;and&space;\quad&space;\Delta&space;t_k&space;=&space;T_{k}&space;-&space;T_{k-1}&space;\quad&space;\forall&space;T_k&space;\in&space;\left\lbrace&space;T_{initial},&space;...,&space;T_{end}&space;\right\rbrace}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\color{Black}{\underline{\bar{x}}&space;=&space;\frac{1}{T_{total}}\sum_{k=1}^{P}{\underline{x}_k\Delta&space;t_k}}&space;\\&space;\color{Black}{Var\left(\underline{x}&space;\right&space;)&space;=&space;\frac{1}{T_{total}}\sum_{k=1}^{P}{\left(\underline{x}_k&space;-&space;\underline{\bar{x}}&space;\right&space;)^2\Delta&space;t_k}}&space;\\&space;\\&space;\color{Black}{&space;\quad&space;where}&space;\\&space;\\&space;\color{Black}{&space;T_{total}&space;=&space;T_{end}&space;-&space;T_{initial}&space;\quad&space;and&space;\quad&space;\Delta&space;t_k&space;=&space;T_{k}&space;-&space;T_{k-1}&space;\quad&space;\forall&space;T_k&space;\in&space;\left\lbrace&space;T_{initial},&space;...,&space;T_{end}&space;\right\rbrace}" alt="" title="\color{Black}{\underline{\bar{x}} = \frac{1}{T_{total}}\sum_{k=1}^{P}{\underline{x}_k\Delta t_k}} \\ \color{Black}{Var\left(\underline{x} \right ) = \frac{1}{T_{total}}\sum_{k=1}^{P}{\left(\underline{x}_k - \underline{\bar{x}} \right )^2\Delta t_k}} \\ \\ \color{Black}{ \quad where} \\ \\ \color{Black}{ T_{total} = T_{end} - T_{initial} \quad and \quad \Delta t_k = T_{k} - T_{k-1} \quad \forall T_k \in \left\lbrace T_{initial}, ..., T_{end} \right\rbrace}" class="inline"/></a></p>
<p>Following is an example of root mean square calculation of non historical velocity. Input variable is node's non-historical container's <code>VELOCITY</code> and output variable <code>VECTOR_3D_MEAN</code> will store mean and <code>VECTOR_3D_VARIANCE</code> will store variance in same container for each node. The <code>0</code> represents echo level for this method object. Blank "" indicates that value method is used.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">variance_method = KratosStats.TemporalMethods.NonHistorical.Nodes.ValueMethods.Variance.Array(model_part, &quot;&quot;, Kratos.VELOCITY, 0, KratosStats.VECTOR_3D_MEAN, KratosStats.VECTOR_3D_VARIANCE)</div>
<div class="line">integration_starting_time = 2.0</div>
<div class="line">variance_method.InitializeStatisticsMethod(integration_starting_time)</div>
<div class="line">for t in range(3, 6):</div>
<div class="line">    variance_method.CalculateStatistics()</div>
</div><!-- fragment --><h3>Min</h3>
<p>In the case of spatial domain, it returns minimum of a given variable's norm for a given container, and the corresponding items id. x<sub>i</sub> is the i<sup>th</sup> element's variable value of the corresponding container. Results will be double and integer, irrespective of the input type, since higher dimensional variable types will be reduced to scalars by the use of norms.</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=\color{Black}{v&space;=&space;\min_{\underline{x}_i&space;\in&space;\mathbf{T}}&space;|\underline{x}_i|}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\color{Black}{v&space;=&space;\min_{\underline{x}_i&space;\in&space;\mathbf{T}}&space;|\underline{x}_i|}" alt="" title="\color{Black}{v = \min_{\underline{x}_i \in \mathbf{T}} |\underline{x}_i|}" class="inline"/></a></p>
<p>Following is an example of min method of non historical <code>VELOCITY</code>'s magnitude over the whole model part's nodes. It returns a tuple, first argument being the minimum, and the second argument being the id of the node where the minimum is found.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">min_value, min_id = KratosStats.SpatialMethods.NonHistorical.Nodes.NormMethods.Min(model_part, Kratos.VELOCITY, &quot;magnitude&quot;)</div>
</div><!-- fragment --><p>In the case of temporal domain, <b>Min</b> method returns minimum value in the temporal domain, and the time minimum is found. Minimum and its occurring time will be stored each element under user specified variables and a user specified container. x<sub>k</sub> is the k<sup>th</sup> time step element's variable value of the corresponding container. Results will have the same type as the type of the variable specified by the user preserving the dimensionality as in the spatial case.</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=\color{Black}{v&space;=&space;\min_{\underline{x}_k&space;\in&space;\mathbf{T}}&space;|\underline{x}_k|}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\color{Black}{v&space;=&space;\min_{\underline{x}_k&space;\in&space;\mathbf{T}}&space;|\underline{x}_k|}" alt="" title="\color{Black}{v = \min_{\underline{x}_k \in \mathbf{T}} |\underline{x}_k|}" class="inline"/></a></p>
<p>Following is an example of min method in non historical velocity. Input variable is node's non-historical container's <code>VELOCITY</code> and output variable <code>VECTOR_3D_NORM</code> will store minimum and <code>TIME</code> will store the time minimum occured for each node. The <code>0</code> represents echo level for this method object. "magnitude" indicates that magnitude norm is used.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">min_method = KratosStats.TemporalMethods.NonHistorical.Nodes.NormMethods.Min.Array(model_part, &quot;magnitude&quot;, Kratos.VELOCITY, 0, KratosStats.VECTOR_3D_NORM, Kratos.TIME)</div>
<div class="line">integration_starting_time = 2.0</div>
<div class="line">min_method.InitializeStatisticsMethod(integration_starting_time)</div>
<div class="line">for t in range(3, 6):</div>
<div class="line">    min_method.CalculateStatistics()</div>
</div><!-- fragment --><h3>Max</h3>
<p>In the case of spatial domain, it returns maximum of a given variable's norm for a given container, and the corresponding items id. x<sub>i</sub> is the i<sup>th</sup> element's variable value of the corresponding container. Results will be double and integer, irrespective of the input type, since higher dimensional variable types will be reduced to scalars by the use of norms.</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=\color{Black}{v&space;=&space;\max_{\underline{x}_i&space;\in&space;\Omega}&space;|\underline{x}_i|}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\color{Black}{v&space;=&space;\max_{\underline{x}_i&space;\in&space;\Omega}&space;|\underline{x}_i|}" alt="" title="\color{Black}{v = \max_{\underline{x}_i \in \Omega} |\underline{x}_i|}" class="inline"/></a></p>
<p>Following is an example of max method of non historical <code>VELOCITY</code>'s magnitude over the whole model part's nodes. It returns a tuple, first argument being the maximum, and the second argument being the id of the node where the maximum is found.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">max_value, max_id = KratosStats.SpatialMethods.NonHistorical.Nodes.NormMethods.Max(model_part, Kratos.VELOCITY, &quot;magnitude&quot;)</div>
</div><!-- fragment --><p>In the case of temporal domain, <b>Max</b> method returns maximum value in the temporal domain, and the time maximum is found. Maximum and its occurring time will be stored each element under user specified variables and a user specified container. x<sub>k</sub> is the k<sup>th</sup> time step element's variable value of the corresponding container. Results will have the same type as the type of the variable specified by the user preserving the dimensionality as in the spatial case.</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=\color{Black}{v&space;=&space;\max_{\underline{x}_k&space;\in&space;\mathbf{T}}&space;|\underline{x}_k|}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?\color{Black}{v&space;=&space;\max_{\underline{x}_k&space;\in&space;\mathbf{T}}&space;|\underline{x}_k|}" alt="" title="\color{Black}{v = \max_{\underline{x}_k \in \mathbf{T}} |\underline{x}_k|}" class="inline"/></a></p>
<p>Following is an example of max method in non historical velocity. Input variable is node's non-historical container's <code>VELOCITY</code> and output variable <code>VECTOR_3D_NORM</code> will store maximum and <code>TIME</code> will store the time maximum occured for each node. The <code>0</code> represents echo level for this method object. "magnitude" indicates that magnitude norm is used.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">max_method = KratosStats.TemporalMethods.NonHistorical.Nodes.NormMethods.Max.Array(model_part, &quot;magnitude&quot;, Kratos.VELOCITY, 0, KratosStats.VECTOR_3D_NORM, Kratos.TIME)</div>
<div class="line">integration_starting_time = 2.0</div>
<div class="line">max_method.InitializeStatisticsMethod(integration_starting_time)</div>
<div class="line">for t in range(3, 6):</div>
<div class="line">    max_method.CalculateStatistics()</div>
</div><!-- fragment --><h3>Median</h3>
<p>Median returns the median value in spatial domain of a given variable's norm for a given container. x<sub>i</sub> is the i<sup>th</sup> element's variable value of the corresponding container. Results will be double value type, irrespective of the input type, since higher dimensional variable types will be reduced to scalars by the use of norms.</p>
<p>Following is an example of median method of non historical <code>VELOCITY</code>'s magnitude over the whole model part's nodes. It returns a double which is the median.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">median_value = KratosStats.SpatialMethods.NonHistorical.Nodes.NormMethods.Median(model_part, Kratos.VELOCITY, &quot;magnitude&quot;)</div>
</div><!-- fragment --><h3>Distribution</h3>
<p>Distribution methods calculates distribution of a given variable with respect to given norm in a given container in spatial domain. x<sub>i</sub> is the i<sup>th</sup> element's variable value of the corresponding container. Result will be a tuple with followings in the same order:</p>
<ol type="1">
<li>min in the domain or user specified min value</li>
<li>max in the domain or user specified min value</li>
<li>group limits of the distribution (only upper limit) (double array)</li>
<li>number of occurences of items within each group (int array)</li>
<li>percentage distribution of number of occurences of items within each group (double array)</li>
<li>Each group's seperate means</li>
<li>Eash group's seperate variances</li>
</ol>
<p>This method requires followings as the parameters as a object of <a class="el" href="../../dd/da0/class_kratos_1_1_parameters.html" title="This class provides to Kratos a data structure for I/O based on the standard of JSON.">Kratos.Parameters</a>, if nothing is provided, then followings are assumed as defaults.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    &quot;number_of_value_groups&quot; : 10,</div>
<div class="line">    &quot;min_value&quot;              : &quot;min&quot;,</div>
<div class="line">    &quot;max_value&quot;              : &quot;max&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><p>In here, <code>"min_value"</code> can either be <code>"min"</code> or a <code>double</code> value. In the case of a double, it will be used as the minimum when creating groups to identify distribution. <code>"max_value"</code> also can either be <code>"max"</code> of <code>double</code> value, which will determine the maximum value when creating the groups. This will create 2 additional groups to represent values below the specified <code>"min_value"</code> and <code>"max_value"</code> apart from the <code>"number_of_value_groups"</code> specified by the user.</p>
<p>Following is an example of median method of non historical <code>VELOCITY</code>'s magnitude over the whole model part's nodes.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">min_value, max_value, group_upper_values, group_histogram, group_percentage_distribution, group_means, group_variances = KratosStats.SpatialMethods.NonHistorical.Nodes.NormMethods.Distribution(model_part, Kratos.VELOCITY, &quot;magnitude&quot;)</div>
</div><!-- fragment --><h2>Norm methods</h2>
<p>All of the value methods mentioned before supports norm version of it, in these methods, higher dimensional values are transformed in to scalar values by a use specified norm, and then statistics are calculated based on the chosen method. Supported norm types may differ based on the variable data type being used. There are few methods, which only supports norm methods. Following table summarize availability of value and norm methods.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Statistical Methods   </th><th class="markdownTableHeadNone">Value Method   </th><th class="markdownTableHeadNone">Norm Method    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="../../#sum">Sum</a>   </td><td class="markdownTableBodyNone">[x]   </td><td class="markdownTableBodyNone">[x]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="../../#mean">Mean</a>   </td><td class="markdownTableBodyNone">[x]   </td><td class="markdownTableBodyNone">[x]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="../../#root-mean-square">Root mean square</a>   </td><td class="markdownTableBodyNone">[x]   </td><td class="markdownTableBodyNone">[x]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="../../#variance">Variance</a>   </td><td class="markdownTableBodyNone">[x]   </td><td class="markdownTableBodyNone">[x]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="../../#min">Min</a>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">[x]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="../../#max">Max</a>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">[x]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="../../#median">Median</a>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">[x]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="../../#distribution">Distribution</a>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">[x]   </td></tr>
</table>
<p>Following example shows variance method, under <b>value</b> category and <b>norm</b> category for nodal non historical velocity. Norm method uses <code>"magnitude"</code> as the norm to reduce <code>VELOCITY</code> to a scalar value. <code>value_mean</code> and <code>value_variance</code> will be of <code>Array 3D</code> type, whereas <code>norm_mean</code> and <code>norm_variance</code> will be of <code>Double</code> type.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">value_mean, value_variance = KratosStats.SpatialMethods.NonHistorical.Nodes.ValueMethods.Variance(model_part, Kratos.VELOCITY)</div>
<div class="line">norm_mean, norm_variance = KratosStats.SpatialMethods.NonHistorical.Nodes.NormMethods.Variance(model_part, Kratos.VELOCITY, &quot;magnitude&quot;)</div>
</div><!-- fragment --><h1>Norm definitions</h1>
<p>Few different norms are predefined in this application. Following table summarize</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">Double   </th><th class="markdownTableHeadNone">Array 3D   </th><th class="markdownTableHeadNone">Vector   </th><th class="markdownTableHeadNone">Matrix    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="../../#value">Value</a>   </td><td class="markdownTableBodyNone">[x]   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="../../#magnitude">Magnitude</a>   </td><td class="markdownTableBodyNone">[x]   </td><td class="markdownTableBodyNone">[x]   </td><td class="markdownTableBodyNone">[x]   </td><td class="markdownTableBodyNone">[x]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="../../#euclidean">Euclidean</a>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">[x]   </td><td class="markdownTableBodyNone">[x]   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="../../#infinity">Infinity</a>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">[x]   </td><td class="markdownTableBodyNone">[x]   </td><td class="markdownTableBodyNone">[x]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="../../#p-norm">P-Norm</a>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">[x]   </td><td class="markdownTableBodyNone">[x]   </td><td class="markdownTableBodyNone">[x]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="../../#lpq-norm">Lpq-Norm</a>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">[x]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="../../#frobenius">Frobenius</a>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">[x]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="../../#trace">Trace</a>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">[x]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="../../#index-based">Index</a>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">[x]   </td><td class="markdownTableBodyNone">[x]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="../../#component-based">Component</a>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">[x]   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
</table>
<h2>Value</h2>
<p>This returns the exact value. Only available for <code>Double</code> type variables.</p>
<h2>Magnitude</h2>
<p>This returns the second norm of the variable.</p>
<ol type="1">
<li>For a <code>Double</code> type, it returns the absolute value.</li>
<li>For a <code>Array 3D</code> type, it returns the magnitude of the 3D vector.</li>
<li>For a <code>Vector</code> type, it returns root square sum of the vector.</li>
<li>For a <code>Matrix</code> type, it returns the <a href="../../#frobenius">frobenius</a> norm.</li>
</ol>
<h2>Euclidean</h2>
<p>This again returns the second norm of the variable for following variable types.</p>
<ol type="1">
<li>For a <code>Array 3D</code> type, it returns the magnitude of the 3D vector.</li>
<li>For a <code>Vector</code> type, it returns root square sum of the vector.</li>
</ol>
<h2>Frobenius</h2>
<p>This is only available for <code>Matrix</code> data type variables only. Following equation illustrates the norm, where <code>A</code> is the matrix and a<sub>ij</sub> is the i<sup>th</sup> row, j<sup>th</sup> column value.</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex={\color{Black}&space;||A||_F&space;=&space;\sqrt{\sum_i&space;{\sum_j{||a_{ij}||^2}}}}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?{\color{Black}&space;||A||_F&space;=&space;\sqrt{\sum_i&space;{\sum_j{||a_{ij}||^2}}}}" alt="" title="{\color{Black} ||A||_F = \sqrt{\sum_i {\sum_j{||a_{ij}||^2}}}}" class="inline"/></a></p>
<h2>Infinity</h2>
<p>This is infinity (i.e. max norm) which is available for <code>Array 3D</code>, <code>Vector</code> and <code>Matrix</code> type. For an <code>Array 3D</code> variable following equation is used.</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex={\color{Black}&space;||\underline{V}||_\infty&space;=&space;\max\left&space;\lbrace&space;{|V_X|,&space;|V_Y|,&space;|V_Z|}\right&space;\rbrace}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?{\color{Black}&space;||\underline{V}||_\infty&space;=&space;\max\left&space;\lbrace&space;{|V_X|,&space;|V_Y|,&space;|V_Z|}\right&space;\rbrace}" alt="" title="{\color{Black} ||\underline{V}||_\infty = \max\left \lbrace {|V_X|, |V_Y|, |V_Z|}\right \rbrace}" class="inline"/></a></p>
<p>For a <code>Vector</code> variable following equation is used.</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex={\color{Black}&space;||\underline{V}||_\infty&space;=&space;\max\left&space;\lbrace&space;{|V_0|,&space;|V_1|,&space;|V_2|,...,{V_{n-1}}}\right&space;\rbrace}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?{\color{Black}&space;||\underline{V}||_\infty&space;=&space;\max\left&space;\lbrace&space;{|V_0|,&space;|V_1|,&space;|V_2|,...,{V_{n-1}}}\right&space;\rbrace}" alt="" title="{\color{Black} ||\underline{V}||_\infty = \max\left \lbrace {|V_0|, |V_1|, |V_2|,...,{V_{n-1}}}\right \rbrace}" class="inline"/></a></p>
<p>For a <code>Matrix</code> variable following equation is used.</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex={\color{Black}&space;||\underline{A}||_\infty&space;=&space;\max_{0&space;\leq&space;i&space;&lt;&space;n}\left(&space;\sum_{j=0}^{n-1}&space;|a_{ij}|\right&space;)}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?{\color{Black}&space;||\underline{A}||_\infty&space;=&space;\max_{0&space;\leq&space;i&space;&lt;&space;n}\left(&space;\sum_{j=0}^{n-1}&space;|a_{ij}|\right&space;)}" alt="" title="{\color{Black} ||\underline{A}||_\infty = \max_{0 \leq i &lt; n}\left( \sum_{j=0}^{n-1} |a_{ij}|\right )}" class="inline"/></a></p>
<h2>Trace</h2>
<p>Trace is only for <code>Matrix</code> type variables. If the given matrix is not squre, an error is thrown.</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex={\color{Black}&space;||\underline{A}||_{trace}&space;=&space;\sum_{i=0}^{n-1}a_{ij}}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?{\color{Black}&space;||\underline{A}||_{trace}&space;=&space;\sum_{i=0}^{n-1}a_{ij}}" alt="" title="{\color{Black} ||\underline{A}||_{trace} = \sum_{i=0}^{n-1}a_{ij}}" class="inline"/></a></p>
<h2>P norm</h2>
<p>P norm is applicable for <code>Array 3D</code>, <code>Vector</code> and <code>Matrix</code> variables. The p-norm is used as <code>pnorm_p</code> where, <code>p</code> represents the value to be used as <code>p</code> in the p-norm equation given below. <code>p</code> should be greater than or equal to 1.0.</p>
<p>For <code>Array 3D</code> and <code>Vector</code>:</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex={\color{Black}&space;||\underline{V}||_{p}&space;=&space;\left(\sum_{i=0}^{n-1}|v_{i}|^p&space;\right&space;)^{1/p}}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?{\color{Black}&space;||\underline{V}||_{p}&space;=&space;\left(\sum_{i=0}^{n-1}|v_{i}|^p&space;\right&space;)^{1/p}}" alt="" title="{\color{Black} ||\underline{V}||_{p} = \left(\sum_{i=0}^{n-1}|v_{i}|^p \right )^{1/p}}" class="inline"/></a></p>
<p>For <code>Matrix</code>:</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex={\color{Black}&space;||\underline{A}||_{p}&space;=&space;\left(\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}|a_{ij}|^p&space;\right&space;)^{1/p}}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?{\color{Black}&space;||\underline{A}||_{p}&space;=&space;\left(\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}|a_{ij}|^p&space;\right&space;)^{1/p}}" alt="" title="{\color{Black} ||\underline{A}||_{p} = \left(\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}|a_{ij}|^p \right )^{1/p}}" class="inline"/></a></p>
<h2>Lpq norm</h2>
<p>This norm is only applicable to <code>Matrix</code> type variables.</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex={\color{Black}&space;||\underline{A}||_{lpq}&space;=&space;\left(\sum_{j=0}^{n-1}\left(\sum_{i=0}^{n-1}|a_{ij}|^p&space;\right&space;)^{q/p}&space;\right&space;)^{1/q}}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?{\color{Black}&space;||\underline{A}||_{lpq}&space;=&space;\left(\sum_{j=0}^{n-1}\left(\sum_{i=0}^{n-1}|a_{ij}|^p&space;\right&space;)^{q/p}&space;\right&space;)^{1/q}}" alt="" title="{\color{Black} ||\underline{A}||_{lpq} = \left(\sum_{j=0}^{n-1}\left(\sum_{i=0}^{n-1}|a_{ij}|^p \right )^{q/p} \right )^{1/q}}" class="inline"/></a></p>
<h2>Index based</h2>
<p>Index based norms are available for both <code>Vector</code> and <code>Matrix</code> based variable types. <code>index_i</code> is used for <code>Vector</code> variables, where <code>i</code> represents the index of the vector to be used as the scalar representing a corresponding vector. <code>index_(i,j)</code> is used for <code>Matrix</code> variables, where <code>i</code> represents the row index and <code>j</code> represents the column index of the matrix value which to be used as the scalar representation of the given matrix.</p>
<h2>Component based</h2>
<p>Component based norms are available only for <code>Array 3D</code> type variables. <code>component_x</code> represents the <code>x</code> component of 3D variable, <code>component_y</code> represents <code>y</code> component, <code>component_z</code> represents the <code>z</code> component.</p>
<h1>Spatial methods</h1>
<p>All the spatial statistical methods can be found in the <code>SpatialMethods</code> submodule. <code>ValueMethods</code> container will contain all available spatial value methods, and <code>NormMethods</code> container will contain all available norm methods.</p>
<p>Following example illustrates all the available value methods executed on nodal non historical variable velocity.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">sum_value = KratosStats.SpatialMethods.NonHistorical.Nodes.ValueMethods.Sum(model_part, Kratos.VELOCITY)</div>
<div class="line">mean_value = KratosStats.SpatialMethods.NonHistorical.Nodes.ValueMethods.Mean(model_part, Kratos.VELOCITY)</div>
<div class="line">rms_value = KratosStats.SpatialMethods.NonHistorical.Nodes.ValueMethods.RootMeanSquare(model_part, Kratos.VELOCITY)</div>
<div class="line">mean_value, variance_value = KratosStats.SpatialMethods.NonHistorical.Nodes.ValueMethods.Variance(model_part, Kratos.VELOCITY)</div>
</div><!-- fragment --><p>Following example illustrates all the available norm methods executed on nodal non historical variable velocity's magnitude.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">sum_norm = KratosStats.SpatialMethods.NonHistorical.Nodes.NormMethods.Sum(model_part, Kratos.VELOCITY, &quot;magnitude&quot;)</div>
<div class="line">mean_norm = KratosStats.SpatialMethods.NonHistorical.Nodes.NormMethods.Mean(model_part, Kratos.VELOCITY, &quot;magnitude&quot;)</div>
<div class="line">rms_norm = KratosStats.SpatialMethods.NonHistorical.Nodes.NormMethods.RootMeanSquare(model_part, Kratos.VELOCITY, &quot;magnitude&quot;)</div>
<div class="line">mean_norm, variance_norm = KratosStats.SpatialMethods.NonHistorical.Nodes.NormMethods.Variance(model_part, Kratos.VELOCITY, &quot;magnitude&quot;)</div>
<div class="line">min_norm, min_norm_id = KratosStats.SpatialMethods.NonHistorical.Nodes.NormMethods.Min(model_part, Kratos.VELOCITY, &quot;magnitude&quot;)</div>
<div class="line">max_norm, max_norm_id = KratosStats.SpatialMethods.NonHistorical.Nodes.NormMethods.Max(model_part, Kratos.VELOCITY, &quot;magnitude&quot;)</div>
<div class="line">min_norm, max_norm, group_upper_norms, group_histogram, group_percentage_distribution = KratosStats.SpatialMethods.NonHistorical.Nodes.NormMethods.Distribution(model_part, Kratos.VELOCITY, &quot;magnitude&quot;)</div>
</div><!-- fragment --><h2>Spatial containers</h2>
<p>Four different types of containers are supported for spatial methods.</p>
<ol type="1">
<li><a href="../../#spatial-nodal-historical">nodal_historical</a></li>
<li><a href="../../#spatial-nodal-non-historical">nodal_non_historical</a></li>
<li><a href="../../#spatial-condition-non-historical">condition_non_historical</a></li>
<li><a href="../../#spatial-element-non-historical">element_non_historical</a></li>
</ol>
<h3>Spatial nodal historical</h3>
<p>Nodal historical containers methods can be accessed through <code>Historical</code> submodule in <code>SpatialMethods</code>. This calculates chosen statistics of the variable in the nodal historical data. Following example illustrates use of value and norm methods.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">model_part.AddNodalSolutionStepVariable(Kratos.VELOCITY)</div>
<div class="line">sum_value = KratosStats.SpatialMethods.Historical.ValueMethods.Sum(model_part, Kratos.VELOCITY)</div>
<div class="line">sum_norm = KratosStats.SpatialMethods.Historical.NormMethods.Sum(model_part, Kratos.VELOCITY, &quot;magnitude&quot;)</div>
</div><!-- fragment --><h3>Spatial nodal non historical</h3>
<p>Nodal non historical containers methods can be accessed through <code>NonHistorical.Nodes</code> submodule in <code>SpatialMethods</code>. This calculates chosen statistics of the variable in the nodal non historical data. Following example illustrates use of value and norm methods.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">sum_value = KratosStats.SpatialMethods.NonHistorical.Nodes.ValueMethods.Sum(model_part, Kratos.VELOCITY)</div>
<div class="line">sum_norm = KratosStats.SpatialMethods.NonHistorical.Nodes.NormMethods.Sum(model_part, Kratos.VELOCITY, &quot;magnitude&quot;)</div>
</div><!-- fragment --><h3>Spatial condition non historical</h3>
<p>Condition non historical containers methods can be accessed through <code>NonHistorical.Conditions</code> submodule in <code>SpatialMethods</code>. This calculates chosen statistics of the variable in the condition non historical data. Following example illustrates use of value and norm methods.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">sum_value = KratosStats.SpatialMethods.NonHistorical.Conditions.ValueMethods.Sum(model_part, Kratos.VELOCITY)</div>
<div class="line">sum_norm = KratosStats.SpatialMethods.NonHistorical.Conditions.NormMethods.Sum(model_part, Kratos.VELOCITY, &quot;magnitude&quot;)</div>
</div><!-- fragment --><h3>Spatial element non historical</h3>
<p>Element non historical containers methods can be accessed through <code>NonHistorical.Elements</code> submodule in <code>SpatialMethods</code>. This calculates chosen statistics of the variable in the element non historical data. Following example illustrates use of value and norm methods.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">sum_value = KratosStats.SpatialMethods.NonHistorical.Elements.ValueMethods.Sum(model_part, Kratos.VELOCITY)</div>
<div class="line">sum_norm = KratosStats.SpatialMethods.NonHistorical.Elements.NormMethods.Sum(model_part, Kratos.VELOCITY, &quot;magnitude&quot;)</div>
</div><!-- fragment --><h2>Spatial statistics process</h2>
<p>This is a seperate process, which can be included in the json file as an auxiliary process. Followings are the defaults used in this process.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    &quot;model_part_name&quot; : &quot;PLEASE_SPECIFY_MODEL_PART_NAME&quot;,</div>
<div class="line">    &quot;input_variable_settings&quot; : [</div>
<div class="line">        {</div>
<div class="line">            &quot;method_name&quot;    : &quot;sum&quot;,</div>
<div class="line">            &quot;norm_type&quot;      : &quot;none&quot;,</div>
<div class="line">            &quot;container&quot;      : &quot;nodal_historical&quot;,</div>
<div class="line">            &quot;variable_names&quot; : [],</div>
<div class="line">            &quot;method_settings&quot;: {}</div>
<div class="line">        }</div>
<div class="line">    ],</div>
<div class="line">    &quot;output_settings&quot; : {</div>
<div class="line">        &quot;output_control_variable&quot;: &quot;STEP&quot;,</div>
<div class="line">        &quot;output_time_interval&quot;   : 1,</div>
<div class="line">        &quot;write_kratos_version&quot;   : true,</div>
<div class="line">        &quot;write_time_stamp&quot;       : true,</div>
<div class="line">        &quot;output_file_settings&quot;   : {</div>
<div class="line">            &quot;file_name&quot;  : &quot;&lt;model_part_name&gt;_&lt;container&gt;_&lt;norm_type&gt;_&lt;method_name&gt;.dat&quot;,</div>
<div class="line">            &quot;output_path&quot;: &quot;spatial_statistics_output&quot;,</div>
<div class="line">            &quot;write_buffer_size&quot; : -1</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>model_part_name</code> indicates which model part to be operated on for statistics calculation. <code>input_variable_settings</code> contains list of statistics and/or norm methods along with their acting containers of the model part. <code>method_name</code> is the statistics method name (always everything is in lower case). <code>norm_type</code> is the applied norm, <code>none</code> means, value methods are used, otherwise specified norm is used. <code>container</code> is the <a href="../../#spatial-method-containers">container</a> to be specified for statistical value calculation. <code>method_settings</code> is used to pass additional information required by statistics method such as in <a href="../../#distribution">Distribution</a> method. Output is written to a file in the format given at <code>file_name</code>, under the folder <code>folder_name</code>. This process can be used, if someone prefers not to modify their python scripts to calculate statistics as mentioned in the previous sections</p>
<h1><a class="el" href="../../de/d7a/class_temporal.html" title="A temporal controller to control behavior based on temporal values.">Temporal</a> methods</h1>
<p>All the temporal methods are available through <code>TemporalMethods</code> submodule under <code><a class="el" href="../../db/d39/namespace_statistics_application.html">StatisticsApplication</a></code>. In the case of temporal methods, seperate objects needs to be created for each input variable for different type of variables as shown in following example for nodal non historical data container value methods.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">sum_double_method = KratosStats.TemporalMethods.NonHistorical.Nodes.ValueMethods.Sum.Double(model_part, &quot;&quot;, Kratos.PRESSURE, 0, Kratos.DENSITY)</div>
<div class="line">sum_array_method = KratosStats.TemporalMethods.NonHistorical.Nodes.ValueMethods.Sum.Array(model_part, &quot;&quot;, Kratos.VELOCITY, 0, Kratos.DISPLACEMENT)</div>
<div class="line">sum_vector_method = KratosStats.TemporalMethods.NonHistorical.Nodes.ValueMethods.Sum.Vector(model_part, &quot;&quot;, Kratos.LOAD_MESHES, 0, Kratos.MATERIAL_PARAMETERS)</div>
<div class="line">sum_matrix_method = KratosStats.TemporalMethods.NonHistorical.Nodes.ValueMethods.Sum.Matrix(model_part, &quot;&quot;, Kratos.GREEN_LAGRANGE_STRAIN_TENSOR, 0, Kratos.CAUCHY_STRESS_TENSOR)</div>
</div><!-- fragment --><p>In order to remove the hassle of using different names (such as <code>Double</code>, <code>Array</code>...), one can get the advantage of common methods available in each of the containers. Following example will create the same objects as in the previous example in one go using simplified sum method.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">params = Kratos.Parameters(r&quot;&quot;&quot;</div>
<div class="line">{</div>
<div class="line">    &quot;input_variables&quot; : [&quot;PRESSURE&quot;, &quot;VELOCITY&quot;, &quot;LOAD_MESHES&quot;, &quot;GREEN_LAGRANGE_STRAIN_TENSOR&quot;],</div>
<div class="line">    &quot;output_variables&quot; : [&quot;DENSITY&quot;, &quot;DISPLACEMENT&quot;, &quot;MATERIAL_PARAMETERS&quot;, &quot;CAUCHY_STRESS_TENSOR&quot;]</div>
<div class="line">}&quot;&quot;&quot;)</div>
<div class="line">sum_methods = KratosStats.TemporalMethods.NonHistorical.Nodes.Sum(model_part, &quot;none&quot;, 0, params)</div>
</div><!-- fragment --><p>For <b>Sum</b>, <b>Mean</b>, <b>RootMeanSquare</b> methods, above <code><a class="el" href="../../dd/da0/class_kratos_1_1_parameters.html" title="This class provides to Kratos a data structure for I/O based on the standard of JSON.">Kratos.Parameters</a></code> object keys will remain the same. But for <b>Variance</b> method following <code>json</code> parameters are used.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    &quot;input_variables&quot;           : [],</div>
<div class="line">    &quot;output_mean_variables&quot;     : [],</div>
<div class="line">    &quot;output_variance_variables&quot; : []</div>
<div class="line">}</div>
</div><!-- fragment --><p>When using these simplified, one needs to take care of compatibility of input and output variables depending on the method and norm type, otherwise runtime errors will be thrown.</p>
<h2><a class="el" href="../../de/d7a/class_temporal.html" title="A temporal controller to control behavior based on temporal values.">Temporal</a> containers</h2>
<p>In the temporal domain, there are five different containers available for user to calculate temporal statistics. They are,</p>
<ol type="1">
<li><a href="../../#temporal-nodal-historical-historical">nodal_historical_historical</a></li>
<li><a href="../../#temporal-nodal-historical-non-historical">nodal_historical_non_historical</a></li>
<li><a href="../../#temporal-nodal-non-historical">nodal_non_historical</a></li>
<li><a href="../../#temporal-condition-non-historical">condition_non_historical</a></li>
<li><a href="../../#temporal-element-non-historical">element_non_historical</a></li>
</ol>
<h3><a class="el" href="../../de/d7a/class_temporal.html" title="A temporal controller to control behavior based on temporal values.">Temporal</a> nodal historical historical</h3>
<p>In this container, statistics are calculated on user specified variables in the nodal historical container and, output is also written to the nodal historical container. Example is given below.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">sum_value = KratosStats.TemporalMethods.Historical.HistoricalOutput.ValueMethods.Sum.Array(model_part, &quot;&quot;, Kratos.VELOCITY, 0, Kratos.DISPLACEMENT)</div>
<div class="line">sum_norm = KratosStats.TemporalMethods.Historical.HistoricalOutput.NormMethods.Sum.Array(model_part, &quot;magnitude&quot;, Kratos.VELOCITY, 0, Kratos.DENSITY)</div>
</div><!-- fragment --><h3><a class="el" href="../../de/d7a/class_temporal.html" title="A temporal controller to control behavior based on temporal values.">Temporal</a> nodal historical non historical</h3>
<p>In this container, statistics are calculated on user specified variables in the nodal historical container and, output is also written to the nodal non historical container. Example is given below.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">sum_value = KratosStats.TemporalMethods.Historical.NonHistoricalOutput.ValueMethods.Sum.Array(model_part, &quot;&quot;, Kratos.VELOCITY, 0, Kratos.DISPLACEMENT)</div>
<div class="line">sum_norm = KratosStats.TemporalMethods.Historical.NonHistoricalOutput.NormMethods.Sum.Array(model_part, &quot;magnitude&quot;, Kratos.VELOCITY, 0, Kratos.DENSITY)</div>
</div><!-- fragment --><h3><a class="el" href="../../de/d7a/class_temporal.html" title="A temporal controller to control behavior based on temporal values.">Temporal</a> nodal non historical</h3>
<p>In this container, statistics are calculated on user specified variables in the nodal non historical container and, output is also written to the nodal non historical container. Example is given below.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">sum_value = KratosStats.TemporalMethods.NonHistorical.Nodes.ValueMethods.Sum.Array(model_part, &quot;&quot;, Kratos.VELOCITY, 0, Kratos.DISPLACEMENT)</div>
<div class="line">sum_norm = KratosStats.TemporalMethods.NonHistorical.Nodes.NormMethods.Sum.Array(model_part, &quot;magnitude&quot;, Kratos.VELOCITY, 0, Kratos.DENSITY)</div>
</div><!-- fragment --><h3><a class="el" href="../../de/d7a/class_temporal.html" title="A temporal controller to control behavior based on temporal values.">Temporal</a> condition non historical</h3>
<p>In this container, statistics are calculated on user specified variables in the condition non historical container and, output is also written to the condition non historical container. Example is given below.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">sum_value = KratosStats.TemporalMethods.NonHistorical.Conditions.ValueMethods.Sum.Array(model_part, &quot;&quot;, Kratos.VELOCITY, 0, Kratos.DISPLACEMENT)</div>
<div class="line">sum_norm = KratosStats.TemporalMethods.NonHistorical.Conditions.NormMethods.Sum.Array(model_part, &quot;magnitude&quot;, Kratos.VELOCITY, 0, Kratos.DENSITY)</div>
</div><!-- fragment --><h3><a class="el" href="../../de/d7a/class_temporal.html" title="A temporal controller to control behavior based on temporal values.">Temporal</a> element non historical</h3>
<p>In this container, statistics are calculated on user specified variables in the element non historical container and, output is also written to the element non historical container. Example is given below.</p>
<div class="fragment"><div class="line">import KratosMultiphysics as Kratos</div>
<div class="line">import KratosMultiphysics.StatisticsApplication as KratosStats</div>
<div class="line">model = Kratos.Model()</div>
<div class="line">model_part = model.CreateModelPart(&quot;test_model_part&quot;)</div>
<div class="line">sum_value = KratosStats.TemporalMethods.NonHistorical.Elements.ValueMethods.Sum.Array(model_part, &quot;&quot;, Kratos.VELOCITY, 0, Kratos.DISPLACEMENT)</div>
<div class="line">sum_norm = KratosStats.TemporalMethods.NonHistorical.Elements.NormMethods.Sum.Array(model_part, &quot;magnitude&quot;, Kratos.VELOCITY, 0, Kratos.DENSITY)</div>
</div><!-- fragment --><h2><a class="el" href="../../de/d7a/class_temporal.html" title="A temporal controller to control behavior based on temporal values.">Temporal</a> statistics process</h2>
<p>This is a seperate process, which can be included in the json file as an auxiliary process. Followings are the defaults used in this process.</p>
<div class="fragment"><div class="line">&quot;model_part_name&quot; : &quot;PLEASE_SPECIFY_MODEL_PART_NAME&quot;,</div>
<div class="line">&quot;input_variable_settings&quot; : [</div>
<div class="line">    {</div>
<div class="line">        &quot;method_name&quot;     : &quot;sum&quot;,</div>
<div class="line">        &quot;norm_type&quot;       : &quot;none&quot;,</div>
<div class="line">        &quot;container&quot;       : &quot;nodal_historical_non_historical&quot;,</div>
<div class="line">        &quot;echo_level&quot;      : 0,</div>
<div class="line">        &quot;method_settings&quot; : {}</div>
<div class="line">    }</div>
<div class="line">],</div>
<div class="line">&quot;echo_level&quot; : 0,</div>
<div class="line">&quot;statistics_start_point_control_variable_name&quot; : &quot;TIME&quot;,</div>
<div class="line">&quot;statistics_start_point_control_value&quot;         : 0.0</div>
</div><!-- fragment --><p><code>model_part_name</code> is the model part which all of the mentioned statistics will be calculated. <code>input_variable_settings</code> contains list of statistical methods, their norms and container combinations where statistics will be calculated. under each <code>input_variable_settings_block</code>, <code>method_name</code> is the statistics method, <code>norm_type</code> is the norm type (<code>"none"</code> for value methods, other wise norms are used), <code>container</code> to tell from which container to read/write, <code>method_settings</code> to specifiy input/output variables for the method. Apart from that, there are few global settings. <code>statistics_start_point_control_variable_name</code> is the temporal statistics calculation start control variable name. This variable should be present in the model_part specified in order to calculate temporal statistics. Statistics calculation will start when this variable's value passes user specified value in <code>statistics_start_point_control_value</code>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Feb 13 2024 02:54:14 for KratosMultiphysics by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
