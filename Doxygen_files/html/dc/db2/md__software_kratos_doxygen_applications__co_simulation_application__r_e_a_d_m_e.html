<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KratosMultiphysics: CoSimulation Application</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../kratos_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">KratosMultiphysics
   </div>
   <div id="projectbrief">KRATOS Multiphysics (Kratos) is a framework for building parallel, multi-disciplinary simulation software, aiming at modularity, extensibility, and high performance. Kratos is written in C++, and counts with an extensive Python interface.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">CoSimulation Application </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The CoSimulation Application contains the core developments in coupling black-box solvers and other software-tools within <a class="el" href="../../db/d66/namespace_kratos.html" title="REF: G. R. Cowper, GAUSSIAN QUADRATURE FORMULAS FOR TRIANGLES.">Kratos</a> Multiphysics.</p>
<h1>Overview</h1>
<ul>
<li>List of features</li>
<li>Dependencies</li>
<li>Examples</li>
<li>User Guide<ul>
<li>Setting up a coupled simulation</li>
<li>The json configuration file</li>
</ul>
</li>
<li>Developer Guide<ul>
<li>Structure of the Application</li>
<li>How to couple a new solver / software-tool?</li>
<li>Using a solver in MPI</li>
</ul>
</li>
<li>References</li>
</ul>
<h1>List of features</h1>
<ul>
<li>Various features available for CoSimulation:<ul>
<li><a href="../../python_scripts/coupled_solvers">Coupling Algorithms</a></li>
<li><a href="../../python_scripts/solver_wrappers">Wrappers for various solvers and other software-tools</a></li>
<li><a href="../../python_scripts/data_transfer_operators">Data Transfer Operators (including Mapping)</a></li>
<li><a href="../../python_scripts/convergence_accelerators">Convergence Accelerators</a></li>
<li><a href="../../python_scripts/convergence_criteria">Convergence Criteria</a></li>
<li><a href="../../python_scripts/predictors">Predictors</a></li>
</ul>
</li>
<li>Support for MPI parallelization. This is independent of whether or not the ued solvers support/run in MPI.</li>
<li>Coupling of <a class="el" href="../../db/d66/namespace_kratos.html" title="REF: G. R. Cowper, GAUSSIAN QUADRATURE FORMULAS FOR TRIANGLES.">Kratos</a> &lt;=&gt; <a class="el" href="../../db/d66/namespace_kratos.html" title="REF: G. R. Cowper, GAUSSIAN QUADRATURE FORMULAS FOR TRIANGLES.">Kratos</a> without overhead since the same database is used and data duplication is avoided.</li>
<li>The <a href="../../../MappingApplication">MappingApplication</a> is used for mapping between nonmatching grids.</li>
</ul>
<h1>Dependencies</h1>
<p>The CoSimulation Application itself doesn't have any dependencies (except the <code>KratosCore</code> / <code>KratosMPICore</code> for serial/MPI-compilation).</p>
<p>For running coupled simulations the solvers to be used have to be available. Those dependencies are python-only.</p>
<p>The <a href="../../../MappingApplication">MappingApplication</a> is required when mapping is used.</p>
<h1>Examples</h1>
<p>The examples can be found in the <a href="https://github.com/KratosMultiphysics/Examples/tree/master/co_simulation">examples repository</a>. Please also refer to the [tests](tests) for examples of how the coupling can be configured. Especially the <a href="../../tests/fsi_mok">Mok-FSI</a> and the <a href="../../tests/fsi_wall">Wall-FSI</a> tests are very suitable for getting a basic understanding.</p>
<h1>User Guide</h1>
<p>This section guides users of the <em><a class="el" href="../../de/dbc/namespace_co_simulation_application.html">CoSimulationApplication</a></em> to setting up and performing coupled simulations. The overall workflow is the same as what is used for most <a class="el" href="../../db/d66/namespace_kratos.html" title="REF: G. R. Cowper, GAUSSIAN QUADRATURE FORMULAS FOR TRIANGLES.">Kratos</a> applications. It consists of the following files:</p>
<ul>
<li><b><a class="el" href="../../d9/d3e/_main_kratos_co_sim_8py.html">MainKratosCoSim.py</a></b> This file is to be executed with python to run the coupled simulation</li>
<li><b>ProjectParametersCoSim.json</b> This file contains the configuration for the coupled simulation</li>
</ul>
<h2>Setting up a coupled simulation</h2>
<p>For running a coulpled simulation at least the two files above are required. In addition, the input for the solvers / codes participating in the coupled simulation are necessary.</p>
<p>The <b><a class="el" href="../../d9/d3e/_main_kratos_co_sim_8py.html">MainKratosCoSim.py</a></b> file looks like this (see also <a href="../../python_scripts/MainKratosCoSim.py">here</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> KratosMultiphysics <span class="keyword">as</span> KM</div>
<div class="line"><span class="keyword">from</span> KratosMultiphysics.CoSimulationApplication.co_simulation_analysis <span class="keyword">import</span> CoSimulationAnalysis</div>
<div class="line"> </div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">For user-scripting it is intended that a new class is derived</span></div>
<div class="line"><span class="stringliteral">from CoSimulationAnalysis to do modifications</span></div>
<div class="line"><span class="stringliteral">Check also &quot;kratos/python_scripts/analysis-stage.py&quot; for available methods that can be overridden</span></div>
<div class="line"><span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">parameter_file_name = <span class="stringliteral">&quot;ProjectParametersCoSim.json&quot;</span></div>
<div class="line"><span class="keyword">with</span> open(parameter_file_name,<span class="stringliteral">&#39;r&#39;</span>) <span class="keyword">as</span> parameter_file:</div>
<div class="line">    parameters = KM.Parameters(parameter_file.read())</div>
<div class="line"> </div>
<div class="line">simulation = CoSimulationAnalysis(parameters)</div>
<div class="line">simulation.Run()</div>
</div><!-- fragment --><p>It can be executed with python:</p>
<div class="fragment"><div class="line">python MainKratosCoSim.py</div>
</div><!-- fragment --><p>If the coupled simulation runs in a distributed environment (MPI) then MPI is required to launch the script</p>
<div class="fragment"><div class="line">mpiexec -np 4 python MainKratosCoSim.py --using-mpi</div>
<div class="line">~~~~</div>
<div class="line"> </div>
<div class="line">Not the passing of the `--using-mpi` flag which tells Kratos that it runs in MPI.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">### The json configuration file</div>
<div class="line"> </div>
<div class="line">The configuration of the coupled simulation is written in `json` format, same as for the rest of Kratos.</div>
<div class="line"> </div>
<div class="line">It contains two settings:</div>
<div class="line">- _problem_data_: this setting contains global settings of the coupled problem.</div>
<div class="line">  ~~~js</div>
<div class="line">  &quot;start_time&quot; : 0.0,</div>
<div class="line">  &quot;end_time&quot; : 15.0,</div>
<div class="line">  &quot;echo_level&quot; : 0, // verbosity, higher values mean more output</div>
<div class="line">  &quot;print_colors&quot; : true, // use colors in the prints</div>
<div class="line">  &quot;parallel_type&quot; : &quot;OpenMP&quot; // or &quot;MPI&quot;</div>
</div><!-- fragment --><ul>
<li><em>solver_settings</em>: the settings of the coupled solver. <div class="fragment"><div class="line">  &quot;type&quot; : &quot;coupled_solvers.gauss_seidel_weak&quot;, // type of the coupled solver, see python_scripts/coupled_solvers</div>
<div class="line">  &quot;predictors&quot; : [], // list of predictors</div>
<div class="line">  &quot;num_coupling_iterations&quot; : 10, // max number of coupling iterations, only available for strongly coupled solvers</div>
<div class="line">  &quot;convergence_accelerators&quot; : [] // list of convergence accelerators, only available for strongly coupled solvers</div>
<div class="line">  &quot;convergence_criteria&quot; : [] // list of convergence criteria, only available for strongly coupled solvers</div>
<div class="line">  &quot;data_transfer_operators&quot; : {} // map of data transfer operators (e.g. mapping)</div>
<div class="line">  &quot;coupling_sequence&quot; : [] // list specifying in which order the solvers are called</div>
<div class="line">  &quot;solvers&quot; : {} // map of solvers participating in the coupled simulation, specifying their input and interfaces</div>
<div class="line">  ~~~~</div>
<div class="line"> </div>
<div class="line">See the next section for a basic example with more explanations.</div>
<div class="line">### Basic FSI example</div>
<div class="line"> </div>
<div class="line">This example is the Wall FSI benchmark, see [1], chapter 7.5.3. The Kratos solvers are used to solve this problem. The input files for this example can be found [here](tests/fsi_wall)</div>
<div class="line"> </div>
<div class="line">~~~js</div>
<div class="line">{</div>
<div class="line">    &quot;problem_data&quot; :</div>
<div class="line">    {</div>
<div class="line">        &quot;start_time&quot; : 0.0,</div>
<div class="line">        &quot;end_time&quot; : 3.0,</div>
<div class="line">        &quot;echo_level&quot; : 0, // printing no additional output</div>
<div class="line">        &quot;print_colors&quot; : true, // using colors for prints</div>
<div class="line">        &quot;parallel_type&quot; : &quot;OpenMP&quot;</div>
<div class="line">    },</div>
<div class="line">    &quot;solver_settings&quot; :</div>
<div class="line">    {</div>
<div class="line">        &quot;type&quot; : &quot;coupled_solvers.gauss_seidel_weak&quot;, // weakly coupled simulation, no interface convergence is checked</div>
<div class="line">        &quot;echo_level&quot; : 0, // no additional output from the coupled solver</div>
<div class="line">        &quot;predictors&quot; : [ // using a predictor to improve the stability of the simulation</div>
<div class="line">            {</div>
<div class="line">                &quot;type&quot; : &quot;average_value_based&quot;,</div>
<div class="line">                &quot;solver&quot;         : &quot;fluid&quot;,</div>
<div class="line">                &quot;data_name&quot;      : &quot;load&quot;</div>
<div class="line">            }</div>
<div class="line">        ],</div>
<div class="line">        &quot;data_transfer_operators&quot; : {</div>
<div class="line">            &quot;mapper&quot; : {</div>
<div class="line">                &quot;type&quot; : &quot;kratos_mapping&quot;,</div>
<div class="line">                &quot;mapper_settings&quot; : {</div>
<div class="line">                    &quot;mapper_type&quot; : &quot;nearest_neighbor&quot; // using a simple mapper, see the README in the MappingApplications</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        },</div>
<div class="line">        &quot;coupling_sequence&quot;:</div>
<div class="line">        [</div>
<div class="line">        {</div>
<div class="line">            &quot;name&quot;: &quot;structure&quot;, // the structural solver comes first</div>
<div class="line">            &quot;input_data_list&quot;: [ // before solving, the following data is imported in the structural solver</div>
<div class="line">                {</div>
<div class="line">                    &quot;data&quot;              : &quot;load&quot;,</div>
<div class="line">                    &quot;from_solver&quot;       : &quot;fluid&quot;,</div>
<div class="line">                    &quot;from_solver_data&quot;  : &quot;load&quot;, // the fluid loads are mapped onto the structure</div>
<div class="line">                    &quot;data_transfer_operator&quot; : &quot;mapper&quot;, // using the mapper defined above (nearest neighbor)</div>
<div class="line">                    &quot;data_transfer_operator_options&quot; : [&quot;swap_sign&quot;] // in Kratos, the loads have the opposite sign, hence it has to be swapped</div>
<div class="line">                }</div>
<div class="line">            ],</div>
<div class="line">            &quot;output_data_list&quot;: [ // after solving, the displacements are mapped to the fluid solver</div>
<div class="line">                {</div>
<div class="line">                    &quot;data&quot;           : &quot;disp&quot;,</div>
<div class="line">                    &quot;to_solver&quot;      : &quot;fluid&quot;,</div>
<div class="line">                    &quot;to_solver_data&quot; : &quot;disp&quot;,</div>
<div class="line">                    &quot;data_transfer_operator&quot; : &quot;mapper&quot;</div>
<div class="line">                }</div>
<div class="line">            ]</div>
<div class="line">        },</div>
<div class="line">        {</div>
<div class="line">            &quot;name&quot;: &quot;fluid&quot;, // the fluid solver solves after the structure</div>
<div class="line">            &quot;output_data_list&quot;: [],</div>
<div class="line">            &quot;input_data_list&quot;: []</div>
<div class="line">        }</div>
<div class="line">        ],</div>
<div class="line">        &quot;solvers&quot; : // here we specify the solvers, their input and interfaces for CoSimulation</div>
<div class="line">        {</div>
<div class="line">            &quot;fluid&quot;:</div>
<div class="line">            {</div>
<div class="line">                &quot;type&quot; : &quot;solver_wrappers.kratos.fluid_dynamics_wrapper&quot;, // using the Kratos FluidDynamicsApplication for the fluid</div>
<div class="line">                &quot;solver_wrapper_settings&quot; : {</div>
<div class="line">                    &quot;input_file&quot;  : &quot;fsi_wall/ProjectParametersCFD&quot; // input file for the fluid solver</div>
<div class="line">                },</div>
<div class="line">                &quot;data&quot; : { // definition of interfaces used in the simulation</div>
<div class="line">                    &quot;disp&quot; : {</div>
<div class="line">                        &quot;model_part_name&quot; : &quot;FluidModelPart.NoSlip2D_FSI_Interface&quot;,</div>
<div class="line">                        &quot;variable_name&quot; : &quot;MESH_DISPLACEMENT&quot;,</div>
<div class="line">                        &quot;dimension&quot; : 2</div>
<div class="line">                    },</div>
<div class="line">                    &quot;load&quot; : {</div>
<div class="line">                        &quot;model_part_name&quot; : &quot;FluidModelPart.NoSlip2D_FSI_Interface&quot;,</div>
<div class="line">                        &quot;variable_name&quot; : &quot;REACTION&quot;,</div>
<div class="line">                        &quot;dimension&quot; : 2</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            },</div>
<div class="line">            &quot;structure&quot; :</div>
<div class="line">            {</div>
<div class="line">                &quot;type&quot; : &quot;solver_wrappers.kratos.structural_mechanics_wrapper&quot;, // using the Kratos StructuralMechanicsApplication for the structure</div>
<div class="line">                &quot;solver_wrapper_settings&quot; : {</div>
<div class="line">                    &quot;input_file&quot;  : &quot;fsi_wall/ProjectParametersCSM&quot; // input file for the structural solver</div>
<div class="line">                },</div>
<div class="line">                &quot;data&quot; : { // definition of interfaces used in the simulation</div>
<div class="line">                    &quot;disp&quot; : {</div>
<div class="line">                        &quot;model_part_name&quot; : &quot;Structure.GENERIC_FSI_Interface&quot;,</div>
<div class="line">                        &quot;variable_name&quot; : &quot;DISPLACEMENT&quot;,</div>
<div class="line">                        &quot;dimension&quot; : 2</div>
<div class="line">                    },</div>
<div class="line">                    &quot;load&quot; : {</div>
<div class="line">                        &quot;model_part_name&quot; : &quot;Structure.GENERIC_FSI_Interface&quot;,</div>
<div class="line">                        &quot;variable_name&quot; : &quot;POINT_LOAD&quot;,</div>
<div class="line">                        &quot;dimension&quot; : 2</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ul>
<h1>Developer Guide</h1>
<h2>Structure of the Application</h2>
<p>The <em><a class="el" href="../../de/dbc/namespace_co_simulation_application.html">CoSimulationApplication</a></em> consists of the following main components (taken from [2]):</p><ul>
<li><b>SolverWrapper</b>: Baseclass and CoSimulationApplication-interface for all solvers/codes participating in the coupled simulation, each solver/code has its own specific version.</li>
<li><b>CoupledSolver</b>: Implements coupling schemes such as weak/strong coupling with Gauss-Seidel/Jacobi pattern. It derives from SolverWrapper such that it can beused in nested coupled simulations.</li>
<li><b><a class="el" href="../../d8/d24/class_i_o.html" title="IO provides different implementation of input output procedures which can be used to read and write w...">IO</a></b>: Responsible for communicating and data exchange with external solvers/codes</li>
<li><b>DataTransferOperator</b>: Transfers data from one discretization to another, e.g. by use of mapping techniques</li>
<li><b>CouplingOperation</b>: Tool for customizing coupled simulations</li>
<li><b>ConvergenceAccelerator</b>: Accelerating the solution in strongly coupled simulations by use of relaxation or Quasi-Newton techniques</li>
<li><b>ConvergenceCriteria</b>: Checks if convergence is achieved in a strongly coupled simulation.</li>
<li><b>Predictor</b>: Improves the convergence by using a prediction as initial guess for the coupled solution</li>
</ul>
<p>The following UML diagram shows the relation between these components:</p>
<p align="center"></p>
<p><img src="https://github.com/KratosMultiphysics/Documentation/blob/master/Readme_files/CoSimulationApplication/CoSimulation_uml.png" alt="" style="width: 300px;" class="inline"/> </p>
<p>Besides the functionalities listed above, the modular design of the application makes it straight forward to add a new or customized version of e.g. a <em>ConvergenceAccelerator</em>. It is not necessary to have those custom python scripts inside the <em><a class="el" href="../../de/dbc/namespace_co_simulation_application.html">CoSimulationApplication</a></em>, it is sufficient that they are in a directory that is included in the <em>PYTHONPATH</em> (e.g. the working directory).</p>
<h2>How to couple a new solver / software-tool?</h2>
<p>The <em><a class="el" href="../../de/dbc/namespace_co_simulation_application.html">CoSimulationApplication</a></em> is very modular and designed to be extended to coupling of more solvers / software-tools. This requires basically two components on the <a class="el" href="../../db/d66/namespace_kratos.html" title="REF: G. R. Cowper, GAUSSIAN QUADRATURE FORMULAS FOR TRIANGLES.">Kratos</a> side:</p>
<p>The interface between the <em><a class="el" href="../../de/dbc/namespace_co_simulation_application.html">CoSimulationApplication</a></em> and a solver is done with the <a href="../../python_scripts/base_classes/co_simulation_solver_wrapper.py"><b>SolverWrapper</b></a>. This wrapper is specific to every solver and calls the solver-custom methods based on the input of CoSimulation.</p>
<p>The second component necessary is an <a href="../../python_scripts/base_classes/co_simulation_io.py"><b>IO</b></a>. This component is used by the SolverWrapper and is responsible for the exchange of data (e.g. mesh, field-quantities, geomety etc) between the solver and the <em><a class="el" href="../../de/dbc/namespace_co_simulation_application.html">CoSimulationApplication</a></em>.</p>
<p>In principle three different options are possible for exchanging data with CoSimulation:</p>
<ul>
<li>For very simple solvers <a class="el" href="../../d8/d24/class_i_o.html" title="IO provides different implementation of input output procedures which can be used to read and write w...">IO</a> can directly be done in python inside the SolverWrapper, which makes a separate <a class="el" href="../../d8/d24/class_i_o.html" title="IO provides different implementation of input output procedures which can be used to read and write w...">IO</a> superfluous (see e.g. a <a href="../../python_scripts/solver_wrappers/sdof">python-only single degree of freedom solver</a>)</li>
<li>Using the <a href="https://github.com/KratosMultiphysics/CoSimIO"><em>CoSimIO</em></a>. This which is the preferred way of exchanging data with the <em><a class="el" href="../../de/dbc/namespace_co_simulation_application.html">CoSimulationApplication</a></em>. It is currently available for <em>C++</em>, <em>C</em>, and <em>Python</em>. The <em>CoSimIO</em> is included as the <a href="../../python_scripts/solver_wrappers/kratos_co_sim_io.py">KratosCoSimIO</a> and can be used directly. Its modular and Kratos-independent design as <em>detached interface</em> allows for easy integration into other codes.</li>
<li>Using a custom solution based on capabilities that are offered by the solver that is to be coupled.</li>
</ul>
<p>The following picture shows the interaction of these components with the <em><a class="el" href="../../de/dbc/namespace_co_simulation_application.html">CoSimulationApplication</a></em> and the external solver:</p>
<p align="center"></p>
<p><img src="https://github.com/KratosMultiphysics/Documentation/blob/master/Readme_files/CoSimulationApplication/detached_interface.png" alt="" style="width: 300px;" class="inline"/> </p>
<h3>Interface of SolverWrapper</h3>
<p>The <a href="../../python_scripts/base_classes/co_simulation_solver_wrapper.py"><b>SolverWrapper</b></a> is the interface in the <em><a class="el" href="../../de/dbc/namespace_co_simulation_application.html">CoSimulationApplication</a></em> to all involved codes / solvers. It provides the following interface (adapted from [2]), which is also called in this order:</p>
<ul>
<li><b>Initialize</b>: This function is called once at the beginning of the simulation, it e.g .reads the input files and prepares the internal data structures.\ the solution loop into split into the following six functions:<ul>
<li><b>AdvanceInTime</b>: Advancing in time and preparing the data structure for the next time step.</li>
<li><b>InitializeSolutionStep</b>: Applying boundary conditions</li>
<li><b>Predict</b>: Predicting the solution of this time step to accelerate the solution.\ iterate until convergence in a strongly coupled solution:<ul>
<li><b>SolveSolutionStep</b>: Solving the problem for this time step. This is the only function that can be called multiple times in an iterative (strongly coupled) solution procedure.</li>
</ul>
</li>
<li><b>FinalizeSolutionStep</b>: Updating internals after solving this time step.</li>
<li><b>OutputSolutionStep</b>: Writing output at the end of a time step</li>
</ul>
</li>
<li><b>Finalize</b>: Finalizing and cleaning up after the simulation</li>
</ul>
<p>Each of these functions can implement functionalities to communicate with the external solver, telling it what to do. However, this is often skipped if the data exchange is used for the synchronization of the solvers. This is often done in "classical" coupling tools. I.e. the code to couple internally duplicates the coupling sequence and synchronizes with the coupling tool through the data exchange.</p>
<p>An example of a <em>SolverWrapper</em> coupled to an external solver using this approach can be found <a href="../../python_scripts/solver_wrappers/external/external_solver_wrapper.py">here</a>. Only the mesh exchange is done explicitly at the beginning of the simulation, the data exchange is done inside <em>SolveSolutionStep</em>.</p>
<p>The coupled solver has to duplicate the coupling sequence, it would look e.g. like this (using <em>CoSimIO</em>) for a weak coupling: </p><div class="fragment"><div class="line"># solver initializes ...</div>
<div class="line"> </div>
<div class="line">CoSimIO::ExportMesh(...) # send meshes to the CoSimulationApplication</div>
<div class="line"> </div>
<div class="line"># start solution loop</div>
<div class="line">while time &lt; end_time:</div>
<div class="line">    CoSimIO::ImportData(...) # get interface data</div>
<div class="line"> </div>
<div class="line">    # solve the time step</div>
<div class="line"> </div>
<div class="line">    CoSimIO::ExportData(...) # send new data to the CoSimulationApplication</div>
</div><!-- fragment --><p>An example for an FSI problem where the structural solver of <a class="el" href="../../db/d66/namespace_kratos.html" title="REF: G. R. Cowper, GAUSSIAN QUADRATURE FORMULAS FOR TRIANGLES.">Kratos</a> is used as an external solver can be found <a href="../../tests/structural_mechanics_analysis_with_co_sim_io.py">here</a>. The <em>CoSimIO</em> is used for communicating between the <em><a class="el" href="../../de/dbc/namespace_co_simulation_application.html">CoSimulationApplication</a></em> and the structural solver</p>
<p>While this approach is commonly used, it has the significant drawback that the coupling sequence has to be duplicated, which not only has the potential for bugs and deadlocks but also severly limits the useability when it comes to trying different coupling algorithms. Then not only the input for the <em><a class="el" href="../../de/dbc/namespace_co_simulation_application.html">CoSimulationApplication</a></em> has to be changed but also the source code in the external solver!</p>
<p>Hence a better solution is proposed in the next section: </p><h3>Remote controlled CoSimulation</h3>
<p>A unique feature of <a class="el" href="../../db/d66/namespace_kratos.html" title="REF: G. R. Cowper, GAUSSIAN QUADRATURE FORMULAS FOR TRIANGLES.">Kratos</a> CoSimulation (in combination with the <em>CoSimIO</em>) is the remotely controlled CoSimulation. The main difference to the "classical" approach which duplicates the coupling sequence in the external solver is to give the full control to CoSimulation. This is the most flexible approach from the point of CoSimulation, as then neither the coupling sequence nor any other coupling logic has to be duplicated in the external solver.</p>
<p>In this approach the external solver registers the functions necessary to perform coupled simulations through the <em>CoSimIO</em>. These are then called remotely through the <em><a class="el" href="../../de/dbc/namespace_co_simulation_application.html">CoSimulationApplication</a></em>. This way any coupling algorithm can be used without changing anything in the external solver.</p>
<div class="fragment"><div class="line"># defining functions to be registered</div>
<div class="line">def SolveSolution()</div>
<div class="line">{</div>
<div class="line">    # external solver solves timestep</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">def ExportData()</div>
<div class="line">{</div>
<div class="line">    # external solver exports data to the CoSimulationApplication</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"># after defining the functions they can be registered in the CoSimIO:</div>
<div class="line"> </div>
<div class="line">CoSimIO::Register(SolveSolution)</div>
<div class="line">CoSimIO::Register(ExportData)</div>
<div class="line"># ...</div>
<div class="line"> </div>
<div class="line"># After all the functions are registered and the solver is fully initialized for CoSimulation, the Run method is called</div>
<div class="line">CoSimIO::Run() # this function runs the coupled simulation. It returns only after finishing</div>
</div><!-- fragment --><p>A <a href="https://github.com/KratosMultiphysics/CoSimIO/blob/master/tests/integration_tutorials/cpp/run.cpp">simple example of this can be found in the <em>CoSimIO</em></a>.</p>
<p>The <em>SolverWrapper</em> for this approach sends a small control signal in each of its functions to the external solver to tell it what to do. This could be implemented as the following:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>RemoteControlSolverWrapper(CoSimulationSolverWrapper):</div>
<div class="line">    <span class="comment"># ...</span></div>
<div class="line">    <span class="comment"># implement other methods as necessary</span></div>
<div class="line">    <span class="comment"># ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>InitializeSolutionStep(self):</div>
<div class="line">        data_config = {</div>
<div class="line">            <span class="stringliteral">&quot;type&quot;</span>           : <span class="stringliteral">&quot;control_signal&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;control_signal&quot;</span> : <span class="stringliteral">&quot;InitializeSolutionStep&quot;</span></div>
<div class="line">        }</div>
<div class="line">        self.ExportData(data_config)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>SolveSolutionStep(self):</div>
<div class="line">        <span class="keywordflow">for</span> data_name <span class="keywordflow">in</span> self.settings[<span class="stringliteral">&quot;solver_wrapper_settings&quot;</span>][<span class="stringliteral">&quot;export_data&quot;</span>].GetStringArray():</div>
<div class="line">            <span class="comment"># first tell the controlled solver to import data</span></div>
<div class="line">            data_config = {</div>
<div class="line">                <span class="stringliteral">&quot;type&quot;</span>            : <span class="stringliteral">&quot;control_signal&quot;</span>,</div>
<div class="line">                <span class="stringliteral">&quot;control_signal&quot;</span>  : <span class="stringliteral">&quot;ImportData&quot;</span>,</div>
<div class="line">                <span class="stringliteral">&quot;data_identifier&quot;</span> : data_name</div>
<div class="line">            }</div>
<div class="line">            self.ExportData(data_config)</div>
<div class="line"> </div>
<div class="line">            <span class="comment"># then export the data from Kratos</span></div>
<div class="line">            data_config = {</div>
<div class="line">                <span class="stringliteral">&quot;type&quot;</span> : <span class="stringliteral">&quot;coupling_interface_data&quot;</span>,</div>
<div class="line">                <span class="stringliteral">&quot;interface_data&quot;</span> : self.GetInterfaceData(data_name)</div>
<div class="line">            }</div>
<div class="line">            self.ExportData(data_config)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># now the external solver solves</span></div>
<div class="line">        super().SolveSolutionStep()</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> data_name <span class="keywordflow">in</span> self.settings[<span class="stringliteral">&quot;solver_wrapper_settings&quot;</span>][<span class="stringliteral">&quot;import_data&quot;</span>].GetStringArray():</div>
<div class="line">            <span class="comment"># first tell the controlled solver to export data</span></div>
<div class="line">            data_config = {</div>
<div class="line">                <span class="stringliteral">&quot;type&quot;</span>            : <span class="stringliteral">&quot;control_signal&quot;</span>,</div>
<div class="line">                <span class="stringliteral">&quot;control_signal&quot;</span>  : <span class="stringliteral">&quot;ExportData&quot;</span>,</div>
<div class="line">                <span class="stringliteral">&quot;data_identifier&quot;</span> : data_name</div>
<div class="line">            }</div>
<div class="line">            self.ExportData(data_config)</div>
<div class="line"> </div>
<div class="line">            <span class="comment"># then import the data to Kratos</span></div>
<div class="line">            data_config = {</div>
<div class="line">                <span class="stringliteral">&quot;type&quot;</span> : <span class="stringliteral">&quot;coupling_interface_data&quot;</span>,</div>
<div class="line">                <span class="stringliteral">&quot;interface_data&quot;</span> : self.GetInterfaceData(data_name)</div>
<div class="line">            }</div>
<div class="line">            self.ImportData(data_config)</div>
</div><!-- fragment --><p>A full example for this can be found <a href="../../tests/structural_mechanics_analysis_remote_controlled.py">here</a>.</p>
<p>If it is possible for an external solver to implement this approach, it is recommended to use it as it is the most robust and flexible.</p>
<p>Nevertheless both approaches are possible with the <em><a class="el" href="../../de/dbc/namespace_co_simulation_application.html">CoSimulationApplication</a></em>.</p>
<h2>Using a solver in MPI</h2>
<p>By default, each <em>SolverWrapper</em> makes use of all ranks in MPI. This can be changed if e.g. the solver that is wrapped by the <em>SolverWrapper</em> does not support MPI or to specify to use less rank.</p>
<p>The base <em>SolverWrapper</em> provides the <code>_GetDataCommunicator</code> funciton for this purpose. In the baseclass, the default <em>DataCommunicator</em> (which contains all ranks in MPI) is returned. The <em>SolverWrapper</em> will be instantiated on all the ranks on which this <em>DataCommunicator</em> is defined (i.e. on the ranks where <code>data_communicator.IsDefinedOnThisRank() == True</code>).</p>
<p>If a solver does not support MPI-parallelism then it can only run on one rank. In such cases it should return a <em>DataCommunicator</em> which contains only one rank. For this purpose the function <code>KratosMultiphysics.CoSimulationApplication.utilities.data_communicator_utilities.GetRankZeroDataCommunicator</code> can be used. Other custom solutions are also possible, see for example the <a href="https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/solver_wrappers/kratos/structural_mechanics_wrapper.py">structural_solver_wrapper</a>.</p>
<h1>References</h1>
<ul>
<li>[1] Wall, Wolfgang A., <em>Fluid structure interaction with stabilized finite elements</em>, PhD Thesis, University of Stuttgart, 1999, <a href="http://dx.doi.org/10.18419/opus-127">http://dx.doi.org/10.18419/opus-127</a></li>
<li>[2] Bucher et al., <em>Realizing CoSimulation in and with a multiphysics framework</em>, conference proceedings, IX International Conference on Computational Methods for Coupled Problems in Science and Engineering, 2021, <a href="https://www.scipedia.com/public/Bucher_et_al_2021a">https://www.scipedia.com/public/Bucher_et_al_2021a</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 2 2023 08:42:59 for KratosMultiphysics by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
