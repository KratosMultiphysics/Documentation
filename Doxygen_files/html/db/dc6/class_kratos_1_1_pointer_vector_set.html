<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KratosMultiphysics: Kratos::PointerVectorSet&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../kratos_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">KratosMultiphysics
   </div>
   <div id="projectbrief">KRATOS Multiphysics (Kratos) is a framework for building parallel, multi-disciplinary simulation software, aiming at modularity, extensibility, and high performance. Kratos is written in C++, and counts with an extensive Python interface.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../db/d66/namespace_kratos.html">Kratos</a></li><li class="navelem"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="../../dc/d13/class_kratos_1_1_pointer_vector_set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Kratos::PointerVectorSet&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span><div class="ingroups"><a class="el" href="../../d5/d4d/group___kratos_core.html">Kratos Core</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A sorted associative container similar to an STL set, but uses a vector to store pointers to its data.  
 <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d4/d35/pointer__vector__set_8h_source.html">pointer_vector_set.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Kratos::PointerVectorSet&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../d7/db4/class_kratos_1_1_pointer_vector_set__coll__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:a4d86d2359054ebdf0b7e941d8b50f857"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a> = boost::indirect_iterator&lt; typename TContainerType::iterator &gt;</td></tr>
<tr class="separator:a4d86d2359054ebdf0b7e941d8b50f857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c9895ef32d8cc0be148b13be9f7be0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab0c9895ef32d8cc0be148b13be9f7be0">const_iterator</a> = boost::indirect_iterator&lt; typename TContainerType::const_iterator &gt;</td></tr>
<tr class="separator:ab0c9895ef32d8cc0be148b13be9f7be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731f3f90c1bf62309910dc58539947ac"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a731f3f90c1bf62309910dc58539947ac">reverse_iterator</a> = boost::indirect_iterator&lt; typename TContainerType::reverse_iterator &gt;</td></tr>
<tr class="separator:a731f3f90c1bf62309910dc58539947ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982242ae1658b371d7b94db8bfcb8b67"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a982242ae1658b371d7b94db8bfcb8b67">const_reverse_iterator</a> = boost::indirect_iterator&lt; typename TContainerType::const_reverse_iterator &gt;</td></tr>
<tr class="separator:a982242ae1658b371d7b94db8bfcb8b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Other definitions</div></td></tr>
<tr class="memitem:a9f15f0eae9d29b51403cc5a6c4ea0377"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9f15f0eae9d29b51403cc5a6c4ea0377">size_type</a> = typename TContainerType::size_type</td></tr>
<tr class="separator:a9f15f0eae9d29b51403cc5a6c4ea0377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bb256b141e6d49dbd169c75b847a7f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ae1bb256b141e6d49dbd169c75b847a7f">ptr_iterator</a> = typename TContainerType::iterator</td></tr>
<tr class="separator:ae1bb256b141e6d49dbd169c75b847a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35723a3d56fbc10a31a5a632534bc0cc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a35723a3d56fbc10a31a5a632534bc0cc">ptr_const_iterator</a> = typename TContainerType::const_iterator</td></tr>
<tr class="separator:a35723a3d56fbc10a31a5a632534bc0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f71f32572e7f1b8cb3fe87f5a02ccb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a09f71f32572e7f1b8cb3fe87f5a02ccb">ptr_reverse_iterator</a> = typename TContainerType::reverse_iterator</td></tr>
<tr class="separator:a09f71f32572e7f1b8cb3fe87f5a02ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c1338fe46599db3bd5b43749cc2524"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a32c1338fe46599db3bd5b43749cc2524">ptr_const_reverse_iterator</a> = typename TContainerType::const_reverse_iterator</td></tr>
<tr class="separator:a32c1338fe46599db3bd5b43749cc2524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca357d043deb756c3a32664d807dba5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a5ca357d043deb756c3a32664d807dba5">difference_type</a> = typename TContainerType::difference_type</td></tr>
<tr class="separator:a5ca357d043deb756c3a32664d807dba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Life Cycle</div></td></tr>
<tr class="memitem:aa78dfa5cfb3d7e03a3f45b5dc6736c0b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#aa78dfa5cfb3d7e03a3f45b5dc6736c0b">PointerVectorSet</a> ()</td></tr>
<tr class="memdesc:aa78dfa5cfb3d7e03a3f45b5dc6736c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#aa78dfa5cfb3d7e03a3f45b5dc6736c0b">More...</a><br /></td></tr>
<tr class="separator:aa78dfa5cfb3d7e03a3f45b5dc6736c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c6436620a7195dbafc846841c29933"><td class="memTemplParams" colspan="2">template&lt;class TInputIteratorType &gt; </td></tr>
<tr class="memitem:ab5c6436620a7195dbafc846841c29933"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab5c6436620a7195dbafc846841c29933">PointerVectorSet</a> (TInputIteratorType First, TInputIteratorType Last, <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9f15f0eae9d29b51403cc5a6c4ea0377">size_type</a> NewMaxBufferSize=1)</td></tr>
<tr class="memdesc:ab5c6436620a7195dbafc846841c29933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> from a range of elements.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab5c6436620a7195dbafc846841c29933">More...</a><br /></td></tr>
<tr class="separator:ab5c6436620a7195dbafc846841c29933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad93dc8afceec2eea45b9e4a6c99547a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#aad93dc8afceec2eea45b9e4a6c99547a">PointerVectorSet</a> (const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a> &amp;rOther)</td></tr>
<tr class="memdesc:aad93dc8afceec2eea45b9e4a6c99547a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a>.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#aad93dc8afceec2eea45b9e4a6c99547a">More...</a><br /></td></tr>
<tr class="separator:aad93dc8afceec2eea45b9e4a6c99547a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04b2ad65d16b0d1114c5263542dd195"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ad04b2ad65d16b0d1114c5263542dd195">PointerVectorSet</a> (const TContainerType &amp;rContainer)</td></tr>
<tr class="memdesc:ad04b2ad65d16b0d1114c5263542dd195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> from a container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ad04b2ad65d16b0d1114c5263542dd195">More...</a><br /></td></tr>
<tr class="separator:ad04b2ad65d16b0d1114c5263542dd195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7566aea3723f37994018fada51f50562"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a7566aea3723f37994018fada51f50562">~PointerVectorSet</a> ()</td></tr>
<tr class="memdesc:a7566aea3723f37994018fada51f50562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a7566aea3723f37994018fada51f50562">More...</a><br /></td></tr>
<tr class="separator:a7566aea3723f37994018fada51f50562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators</div></td></tr>
<tr class="memitem:ab4b83508cdfed63ff09850456831782c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab4b83508cdfed63ff09850456831782c">operator=</a> (const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a> &amp;rOther)</td></tr>
<tr class="memdesc:ab4b83508cdfed63ff09850456831782c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a>.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab4b83508cdfed63ff09850456831782c">More...</a><br /></td></tr>
<tr class="separator:ab4b83508cdfed63ff09850456831782c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810d6a231dfea712bcaef646afdd89c8"><td class="memItemLeft" align="right" valign="top">TDataType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a810d6a231dfea712bcaef646afdd89c8">operator[]</a> (const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#af8a4fed0ce0280ee0e6771a160ae589e">key_type</a> &amp;Key)</td></tr>
<tr class="memdesc:a810d6a231dfea712bcaef646afdd89c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses an element by key and returns a reference.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a810d6a231dfea712bcaef646afdd89c8">More...</a><br /></td></tr>
<tr class="separator:a810d6a231dfea712bcaef646afdd89c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a2ed258b9f55866406eea859d3e9d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#af5aa8d23ac7f841d8af8d31d611e15b7">pointer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ad4a2ed258b9f55866406eea859d3e9d2">operator()</a> (const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#af8a4fed0ce0280ee0e6771a160ae589e">key_type</a> &amp;Key)</td></tr>
<tr class="memdesc:ad4a2ed258b9f55866406eea859d3e9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for inserting or retrieving a pointer associated with a key.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ad4a2ed258b9f55866406eea859d3e9d2">More...</a><br /></td></tr>
<tr class="separator:ad4a2ed258b9f55866406eea859d3e9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac163be01a5b710f7be15c1d317930ae6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d66/namespace_kratos.html#a14b9d687ed53c882489400b57cdf34cd">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ac163be01a5b710f7be15c1d317930ae6">operator==</a> (const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a> &amp;r) const noexcept</td></tr>
<tr class="memdesc:ac163be01a5b710f7be15c1d317930ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for two <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> objects.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ac163be01a5b710f7be15c1d317930ae6">More...</a><br /></td></tr>
<tr class="separator:ac163be01a5b710f7be15c1d317930ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f89fae0fd6307d75e3557f4fe27c5c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d66/namespace_kratos.html#a14b9d687ed53c882489400b57cdf34cd">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9f89fae0fd6307d75e3557f4fe27c5c7">operator&lt;</a> (const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a> &amp;r) const noexcept</td></tr>
<tr class="memdesc:a9f89fae0fd6307d75e3557f4fe27c5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than comparison operator for two <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> objects.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9f89fae0fd6307d75e3557f4fe27c5c7">More...</a><br /></td></tr>
<tr class="separator:a9f89fae0fd6307d75e3557f4fe27c5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operations</div></td></tr>
<tr class="memitem:aaba01bc27b154ddfb13c4875a1ee2cfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#aaba01bc27b154ddfb13c4875a1ee2cfb">begin</a> ()</td></tr>
<tr class="memdesc:aaba01bc27b154ddfb13c4875a1ee2cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the beginning of the container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#aaba01bc27b154ddfb13c4875a1ee2cfb">More...</a><br /></td></tr>
<tr class="separator:aaba01bc27b154ddfb13c4875a1ee2cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7554a81db1fc1b04d5963996369ca5c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab0c9895ef32d8cc0be148b13be9f7be0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a7554a81db1fc1b04d5963996369ca5c3">begin</a> () const</td></tr>
<tr class="memdesc:a7554a81db1fc1b04d5963996369ca5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the beginning of the container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a7554a81db1fc1b04d5963996369ca5c3">More...</a><br /></td></tr>
<tr class="separator:a7554a81db1fc1b04d5963996369ca5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5df2cb372080576e7ed3ed776e68226"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab0c9895ef32d8cc0be148b13be9f7be0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ac5df2cb372080576e7ed3ed776e68226">cbegin</a> ()</td></tr>
<tr class="memdesc:ac5df2cb372080576e7ed3ed776e68226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the beginning of the container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ac5df2cb372080576e7ed3ed776e68226">More...</a><br /></td></tr>
<tr class="separator:ac5df2cb372080576e7ed3ed776e68226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2051aff8d20dc33737b1e78cd41c22d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab0c9895ef32d8cc0be148b13be9f7be0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a2051aff8d20dc33737b1e78cd41c22d8">cbegin</a> () const</td></tr>
<tr class="memdesc:a2051aff8d20dc33737b1e78cd41c22d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the beginning of the container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a2051aff8d20dc33737b1e78cd41c22d8">More...</a><br /></td></tr>
<tr class="separator:a2051aff8d20dc33737b1e78cd41c22d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc410959c998f861779d4e180822b78b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#acc410959c998f861779d4e180822b78b">end</a> ()</td></tr>
<tr class="memdesc:acc410959c998f861779d4e180822b78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the end of the container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#acc410959c998f861779d4e180822b78b">More...</a><br /></td></tr>
<tr class="separator:acc410959c998f861779d4e180822b78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2caff98e6ec42bec7bc4eba25bfcfe3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab0c9895ef32d8cc0be148b13be9f7be0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a2caff98e6ec42bec7bc4eba25bfcfe3f">end</a> () const</td></tr>
<tr class="memdesc:a2caff98e6ec42bec7bc4eba25bfcfe3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the end of the container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a2caff98e6ec42bec7bc4eba25bfcfe3f">More...</a><br /></td></tr>
<tr class="separator:a2caff98e6ec42bec7bc4eba25bfcfe3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7b918947f7e471f09731e30a76c7a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab0c9895ef32d8cc0be148b13be9f7be0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9e7b918947f7e471f09731e30a76c7a3">cend</a> ()</td></tr>
<tr class="memdesc:a9e7b918947f7e471f09731e30a76c7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the end of the container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9e7b918947f7e471f09731e30a76c7a3">More...</a><br /></td></tr>
<tr class="separator:a9e7b918947f7e471f09731e30a76c7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a6e7cba3fd8a97d797d6430e0e3ba0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab0c9895ef32d8cc0be148b13be9f7be0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a18a6e7cba3fd8a97d797d6430e0e3ba0">cend</a> () const</td></tr>
<tr class="memdesc:a18a6e7cba3fd8a97d797d6430e0e3ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the end of the container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a18a6e7cba3fd8a97d797d6430e0e3ba0">More...</a><br /></td></tr>
<tr class="separator:a18a6e7cba3fd8a97d797d6430e0e3ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04df723f946f80734ad4ffc4087ae09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a731f3f90c1bf62309910dc58539947ac">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ac04df723f946f80734ad4ffc4087ae09">rbegin</a> ()</td></tr>
<tr class="memdesc:ac04df723f946f80734ad4ffc4087ae09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator pointing to the beginning of the container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ac04df723f946f80734ad4ffc4087ae09">More...</a><br /></td></tr>
<tr class="separator:ac04df723f946f80734ad4ffc4087ae09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb601c0ba75590a5160f19b170706227"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a982242ae1658b371d7b94db8bfcb8b67">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#aeb601c0ba75590a5160f19b170706227">rbegin</a> () const</td></tr>
<tr class="memdesc:aeb601c0ba75590a5160f19b170706227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reverse iterator pointing to the beginning of the container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#aeb601c0ba75590a5160f19b170706227">More...</a><br /></td></tr>
<tr class="separator:aeb601c0ba75590a5160f19b170706227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa02dde364140f40e6d2807c1390f3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a731f3f90c1bf62309910dc58539947ac">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a7fa02dde364140f40e6d2807c1390f3a">rend</a> ()</td></tr>
<tr class="memdesc:a7fa02dde364140f40e6d2807c1390f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator pointing to the end of the container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a7fa02dde364140f40e6d2807c1390f3a">More...</a><br /></td></tr>
<tr class="separator:a7fa02dde364140f40e6d2807c1390f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824a63157f688e2af1e6ccd4af39b1e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a982242ae1658b371d7b94db8bfcb8b67">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a824a63157f688e2af1e6ccd4af39b1e6">rend</a> () const</td></tr>
<tr class="memdesc:a824a63157f688e2af1e6ccd4af39b1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reverse iterator pointing to the end of the container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a824a63157f688e2af1e6ccd4af39b1e6">More...</a><br /></td></tr>
<tr class="separator:a824a63157f688e2af1e6ccd4af39b1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4998c693d7262809d3a818c9995311"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ae1bb256b141e6d49dbd169c75b847a7f">ptr_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4e4998c693d7262809d3a818c9995311">ptr_begin</a> ()</td></tr>
<tr class="memdesc:a4e4998c693d7262809d3a818c9995311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the beginning of the underlying data container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4e4998c693d7262809d3a818c9995311">More...</a><br /></td></tr>
<tr class="separator:a4e4998c693d7262809d3a818c9995311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ff47c567428535ed8731ddc181d074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a35723a3d56fbc10a31a5a632534bc0cc">ptr_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a78ff47c567428535ed8731ddc181d074">ptr_begin</a> () const</td></tr>
<tr class="memdesc:a78ff47c567428535ed8731ddc181d074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the beginning of the underlying data container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a78ff47c567428535ed8731ddc181d074">More...</a><br /></td></tr>
<tr class="separator:a78ff47c567428535ed8731ddc181d074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3061ba89e3e5ba034a316fde4635b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ae1bb256b141e6d49dbd169c75b847a7f">ptr_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a3e3061ba89e3e5ba034a316fde4635b2">ptr_end</a> ()</td></tr>
<tr class="memdesc:a3e3061ba89e3e5ba034a316fde4635b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the end of the underlying data container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a3e3061ba89e3e5ba034a316fde4635b2">More...</a><br /></td></tr>
<tr class="separator:a3e3061ba89e3e5ba034a316fde4635b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429f3c4cdbeed613f895eebbc1cfb791"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a35723a3d56fbc10a31a5a632534bc0cc">ptr_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a429f3c4cdbeed613f895eebbc1cfb791">ptr_end</a> () const</td></tr>
<tr class="memdesc:a429f3c4cdbeed613f895eebbc1cfb791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the end of the underlying data container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a429f3c4cdbeed613f895eebbc1cfb791">More...</a><br /></td></tr>
<tr class="separator:a429f3c4cdbeed613f895eebbc1cfb791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123b2dd335e4cd2f1fe71bfcb421db8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a09f71f32572e7f1b8cb3fe87f5a02ccb">ptr_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a123b2dd335e4cd2f1fe71bfcb421db8d">ptr_rbegin</a> ()</td></tr>
<tr class="memdesc:a123b2dd335e4cd2f1fe71bfcb421db8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator pointing to the beginning of the underlying data container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a123b2dd335e4cd2f1fe71bfcb421db8d">More...</a><br /></td></tr>
<tr class="separator:a123b2dd335e4cd2f1fe71bfcb421db8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc58960c179f85f62fa0158cfb5794ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a32c1338fe46599db3bd5b43749cc2524">ptr_const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#abc58960c179f85f62fa0158cfb5794ce">ptr_rbegin</a> () const</td></tr>
<tr class="memdesc:abc58960c179f85f62fa0158cfb5794ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reverse iterator pointing to the beginning of the underlying data container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#abc58960c179f85f62fa0158cfb5794ce">More...</a><br /></td></tr>
<tr class="separator:abc58960c179f85f62fa0158cfb5794ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa769b3c3c5990960082b309d6e6db202"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a09f71f32572e7f1b8cb3fe87f5a02ccb">ptr_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#aa769b3c3c5990960082b309d6e6db202">ptr_rend</a> ()</td></tr>
<tr class="memdesc:aa769b3c3c5990960082b309d6e6db202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator pointing to the end of the underlying data container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#aa769b3c3c5990960082b309d6e6db202">More...</a><br /></td></tr>
<tr class="separator:aa769b3c3c5990960082b309d6e6db202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647e56987697fa2c944e47ec9587ca20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a32c1338fe46599db3bd5b43749cc2524">ptr_const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a647e56987697fa2c944e47ec9587ca20">ptr_rend</a> () const</td></tr>
<tr class="memdesc:a647e56987697fa2c944e47ec9587ca20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reverse iterator pointing to the end of the underlying data container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a647e56987697fa2c944e47ec9587ca20">More...</a><br /></td></tr>
<tr class="separator:a647e56987697fa2c944e47ec9587ca20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437759ea41af3ce466398ecfad458b72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a09e20335661a4e1bd0aebef9e9a7deae">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a437759ea41af3ce466398ecfad458b72">front</a> () noexcept</td></tr>
<tr class="memdesc:a437759ea41af3ce466398ecfad458b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a437759ea41af3ce466398ecfad458b72">More...</a><br /></td></tr>
<tr class="separator:a437759ea41af3ce466398ecfad458b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f53a09d2b4ddaaf77c896fc238be04c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a2e5f9f12d8d62ddd4fc07b5732b6ad28">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a5f53a09d2b4ddaaf77c896fc238be04c">front</a> () const noexcept</td></tr>
<tr class="memdesc:a5f53a09d2b4ddaaf77c896fc238be04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the first element in the container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a5f53a09d2b4ddaaf77c896fc238be04c">More...</a><br /></td></tr>
<tr class="separator:a5f53a09d2b4ddaaf77c896fc238be04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49220d813516ed00526ddf1fad50834d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a09e20335661a4e1bd0aebef9e9a7deae">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a49220d813516ed00526ddf1fad50834d">back</a> () noexcept</td></tr>
<tr class="memdesc:a49220d813516ed00526ddf1fad50834d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a49220d813516ed00526ddf1fad50834d">More...</a><br /></td></tr>
<tr class="separator:a49220d813516ed00526ddf1fad50834d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd5d03d41a80ab0162e89d737e2a3e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a2e5f9f12d8d62ddd4fc07b5732b6ad28">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#abdd5d03d41a80ab0162e89d737e2a3e4">back</a> () const noexcept</td></tr>
<tr class="memdesc:abdd5d03d41a80ab0162e89d737e2a3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the last element in the container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#abdd5d03d41a80ab0162e89d737e2a3e4">More...</a><br /></td></tr>
<tr class="separator:abdd5d03d41a80ab0162e89d737e2a3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510c92d5ebe9a4beeb063269530ef31a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9f15f0eae9d29b51403cc5a6c4ea0377">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a510c92d5ebe9a4beeb063269530ef31a">size</a> () const</td></tr>
<tr class="memdesc:a510c92d5ebe9a4beeb063269530ef31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a510c92d5ebe9a4beeb063269530ef31a">More...</a><br /></td></tr>
<tr class="separator:a510c92d5ebe9a4beeb063269530ef31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a878acb729a33919350410564fc080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9f15f0eae9d29b51403cc5a6c4ea0377">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a33a878acb729a33919350410564fc080">max_size</a> () const</td></tr>
<tr class="memdesc:a33a878acb729a33919350410564fc080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum possible number of elements the container can hold.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a33a878acb729a33919350410564fc080">More...</a><br /></td></tr>
<tr class="separator:a33a878acb729a33919350410564fc080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f8120945960a9c8aa9e71545c98ba8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a18ac299876078bab0f6c1274aa2c1afa">key_compare</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ae8f8120945960a9c8aa9e71545c98ba8">key_comp</a> () const</td></tr>
<tr class="memdesc:ae8f8120945960a9c8aa9e71545c98ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the key comparison function used for ordering elements in the container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ae8f8120945960a9c8aa9e71545c98ba8">More...</a><br /></td></tr>
<tr class="separator:ae8f8120945960a9c8aa9e71545c98ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519817f38830be9013c5af58273ffab7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a519817f38830be9013c5af58273ffab7">swap</a> (<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a> &amp;rOther)</td></tr>
<tr class="memdesc:a519817f38830be9013c5af58273ffab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> with another.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a519817f38830be9013c5af58273ffab7">More...</a><br /></td></tr>
<tr class="separator:a519817f38830be9013c5af58273ffab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d223f7af1848345c2d25830364314f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9d223f7af1848345c2d25830364314f0">push_back</a> (TPointerType x)</td></tr>
<tr class="memdesc:a9d223f7af1848345c2d25830364314f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a pointer to the end of the set.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9d223f7af1848345c2d25830364314f0">More...</a><br /></td></tr>
<tr class="separator:a9d223f7af1848345c2d25830364314f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dffb1e73a06bb2fc756b0134f5879cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a5dffb1e73a06bb2fc756b0134f5879cc">pop_back</a> ()</td></tr>
<tr class="memdesc:a5dffb1e73a06bb2fc756b0134f5879cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element from the set.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a5dffb1e73a06bb2fc756b0134f5879cc">More...</a><br /></td></tr>
<tr class="separator:a5dffb1e73a06bb2fc756b0134f5879cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669530068394cbcb58219555a3f7059e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a669530068394cbcb58219555a3f7059e">insert</a> (const TPointerType &amp;value)</td></tr>
<tr class="memdesc:a669530068394cbcb58219555a3f7059e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a pointer.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a669530068394cbcb58219555a3f7059e">More...</a><br /></td></tr>
<tr class="separator:a669530068394cbcb58219555a3f7059e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88e8f852ff528d96652d429ec311233"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#aa88e8f852ff528d96652d429ec311233">insert</a> (<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab0c9895ef32d8cc0be148b13be9f7be0">const_iterator</a> position_hint, const TPointerType &amp;value)</td></tr>
<tr class="memdesc:aa88e8f852ff528d96652d429ec311233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a pointer at the specified position.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#aa88e8f852ff528d96652d429ec311233">More...</a><br /></td></tr>
<tr class="separator:aa88e8f852ff528d96652d429ec311233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d15b443820ba8d92718a731f8b1531"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a95d15b443820ba8d92718a731f8b1531"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a95d15b443820ba8d92718a731f8b1531">insert</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a95d15b443820ba8d92718a731f8b1531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements from a range of iterators.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a95d15b443820ba8d92718a731f8b1531">More...</a><br /></td></tr>
<tr class="separator:a95d15b443820ba8d92718a731f8b1531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67f548f43d1fb79dd6acfe2e19191d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ac67f548f43d1fb79dd6acfe2e19191d4">insert</a> (<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab0c9895ef32d8cc0be148b13be9f7be0">PointerVectorSet::const_iterator</a> first, <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab0c9895ef32d8cc0be148b13be9f7be0">PointerVectorSet::const_iterator</a> last)</td></tr>
<tr class="memdesc:ac67f548f43d1fb79dd6acfe2e19191d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements from another <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> range.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ac67f548f43d1fb79dd6acfe2e19191d4">More...</a><br /></td></tr>
<tr class="separator:ac67f548f43d1fb79dd6acfe2e19191d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14db40ca708dd745ef9c06af5bdd93d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a14db40ca708dd745ef9c06af5bdd93d4">insert</a> (const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a> &amp;rOther)</td></tr>
<tr class="separator:a14db40ca708dd745ef9c06af5bdd93d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c9a79626ecb4b2505f2a0e47d274d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a20c9a79626ecb4b2505f2a0e47d274d4">erase</a> (<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a> pos)</td></tr>
<tr class="memdesc:a20c9a79626ecb4b2505f2a0e47d274d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an element at the specified position.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a20c9a79626ecb4b2505f2a0e47d274d4">More...</a><br /></td></tr>
<tr class="separator:a20c9a79626ecb4b2505f2a0e47d274d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc997f2ff4fd58bd5233b478abf6a166"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#acc997f2ff4fd58bd5233b478abf6a166">erase</a> (<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a> first, <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a> last)</td></tr>
<tr class="memdesc:acc997f2ff4fd58bd5233b478abf6a166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a range of elements defined by iterators.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#acc997f2ff4fd58bd5233b478abf6a166">More...</a><br /></td></tr>
<tr class="separator:acc997f2ff4fd58bd5233b478abf6a166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf785fbfbb0a06909b30819704445f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#acbf785fbfbb0a06909b30819704445f4">erase</a> (const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#af8a4fed0ce0280ee0e6771a160ae589e">key_type</a> &amp;k)</td></tr>
<tr class="memdesc:acbf785fbfbb0a06909b30819704445f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an element with the specified key.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#acbf785fbfbb0a06909b30819704445f4">More...</a><br /></td></tr>
<tr class="separator:acbf785fbfbb0a06909b30819704445f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404edde77c0022da427c4ac24e389a66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a404edde77c0022da427c4ac24e389a66">clear</a> ()</td></tr>
<tr class="memdesc:a404edde77c0022da427c4ac24e389a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the set, removing all elements.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a404edde77c0022da427c4ac24e389a66">More...</a><br /></td></tr>
<tr class="separator:a404edde77c0022da427c4ac24e389a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43952d7627f9ec050badbe7b3c37545"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab43952d7627f9ec050badbe7b3c37545">find</a> (const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#af8a4fed0ce0280ee0e6771a160ae589e">key_type</a> &amp;Key)</td></tr>
<tr class="memdesc:ab43952d7627f9ec050badbe7b3c37545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an element with the specified key.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab43952d7627f9ec050badbe7b3c37545">More...</a><br /></td></tr>
<tr class="separator:ab43952d7627f9ec050badbe7b3c37545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac925c6aa3e8effc15c8ee3d0fcc2c12e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab0c9895ef32d8cc0be148b13be9f7be0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ac925c6aa3e8effc15c8ee3d0fcc2c12e">find</a> (const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#af8a4fed0ce0280ee0e6771a160ae589e">key_type</a> &amp;Key) const</td></tr>
<tr class="memdesc:ac925c6aa3e8effc15c8ee3d0fcc2c12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an element with the specified key (const version).  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ac925c6aa3e8effc15c8ee3d0fcc2c12e">More...</a><br /></td></tr>
<tr class="separator:ac925c6aa3e8effc15c8ee3d0fcc2c12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c2c3993d3bbeb0320128d3abca0b07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9f15f0eae9d29b51403cc5a6c4ea0377">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a94c2c3993d3bbeb0320128d3abca0b07">count</a> (const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#af8a4fed0ce0280ee0e6771a160ae589e">key_type</a> &amp;Key)</td></tr>
<tr class="memdesc:a94c2c3993d3bbeb0320128d3abca0b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of elements with the specified key.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a94c2c3993d3bbeb0320128d3abca0b07">More...</a><br /></td></tr>
<tr class="separator:a94c2c3993d3bbeb0320128d3abca0b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36a7d1445d4eadf75b341924f3aa4dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ac36a7d1445d4eadf75b341924f3aa4dd">reserve</a> (<a class="el" href="../../db/d66/namespace_kratos.html#ac398e9982e45de7167981e05b7f5ff57">int</a> reservedsize)</td></tr>
<tr class="memdesc:ac36a7d1445d4eadf75b341924f3aa4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves memory for a specified number of elements.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ac36a7d1445d4eadf75b341924f3aa4dd">More...</a><br /></td></tr>
<tr class="separator:ac36a7d1445d4eadf75b341924f3aa4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3632be090875177f1d4e068440d1f1a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d66/namespace_kratos.html#ac398e9982e45de7167981e05b7f5ff57">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a3632be090875177f1d4e068440d1f1a3">capacity</a> ()</td></tr>
<tr class="memdesc:a3632be090875177f1d4e068440d1f1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current capacity of the underlying data container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a3632be090875177f1d4e068440d1f1a3">More...</a><br /></td></tr>
<tr class="separator:a3632be090875177f1d4e068440d1f1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7542007a871149bde5d4edfb73829d4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a7542007a871149bde5d4edfb73829d4f">Sort</a> ()</td></tr>
<tr class="memdesc:a7542007a871149bde5d4edfb73829d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the elements in the set.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a7542007a871149bde5d4edfb73829d4f">More...</a><br /></td></tr>
<tr class="separator:a7542007a871149bde5d4edfb73829d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b4b6cbbe3e808fc3e612ee815d09a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a00b4b6cbbe3e808fc3e612ee815d09a9">Unique</a> ()</td></tr>
<tr class="memdesc:a00b4b6cbbe3e808fc3e612ee815d09a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicate elements from the set.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a00b4b6cbbe3e808fc3e612ee815d09a9">More...</a><br /></td></tr>
<tr class="separator:a00b4b6cbbe3e808fc3e612ee815d09a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access</div></td></tr>
<tr class="memitem:a9e0191b0541cf064e235f4c507f705cb"><td class="memItemLeft" align="right" valign="top">TContainerType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9e0191b0541cf064e235f4c507f705cb">GetContainer</a> ()</td></tr>
<tr class="separator:a9e0191b0541cf064e235f4c507f705cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3ed07ae7047004de1ab566a6f30e7e"><td class="memItemLeft" align="right" valign="top">const TContainerType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a5d3ed07ae7047004de1ab566a6f30e7e">GetContainer</a> () const</td></tr>
<tr class="separator:a5d3ed07ae7047004de1ab566a6f30e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986c96a2aa91cd316639948b5caadf6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9f15f0eae9d29b51403cc5a6c4ea0377">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a986c96a2aa91cd316639948b5caadf6d">GetMaxBufferSize</a> () const</td></tr>
<tr class="memdesc:a986c96a2aa91cd316639948b5caadf6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum size of buffer used in the container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a986c96a2aa91cd316639948b5caadf6d">More...</a><br /></td></tr>
<tr class="separator:a986c96a2aa91cd316639948b5caadf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad596433592bb75505dee457903fda899"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ad596433592bb75505dee457903fda899">SetMaxBufferSize</a> (const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9f15f0eae9d29b51403cc5a6c4ea0377">size_type</a> NewSize)</td></tr>
<tr class="memdesc:ad596433592bb75505dee457903fda899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum size of buffer used in the container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ad596433592bb75505dee457903fda899">More...</a><br /></td></tr>
<tr class="separator:ad596433592bb75505dee457903fda899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8a1a6a738015c7dde576fbdb5b134d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9f15f0eae9d29b51403cc5a6c4ea0377">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#aaa8a1a6a738015c7dde576fbdb5b134d">GetSortedPartSize</a> () const</td></tr>
<tr class="memdesc:aaa8a1a6a738015c7dde576fbdb5b134d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sorted part size of buffer used in the container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#aaa8a1a6a738015c7dde576fbdb5b134d">More...</a><br /></td></tr>
<tr class="separator:aaa8a1a6a738015c7dde576fbdb5b134d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfe731c1844b327ef0d466091db4082"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a3cfe731c1844b327ef0d466091db4082">SetSortedPartSize</a> (const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9f15f0eae9d29b51403cc5a6c4ea0377">size_type</a> NewSize)</td></tr>
<tr class="memdesc:a3cfe731c1844b327ef0d466091db4082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sorted part size of buffer used in the container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a3cfe731c1844b327ef0d466091db4082">More...</a><br /></td></tr>
<tr class="separator:a3cfe731c1844b327ef0d466091db4082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Inquiry</div></td></tr>
<tr class="memitem:a1342499dd436307bfc67a5c1a2b9d030"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d66/namespace_kratos.html#a14b9d687ed53c882489400b57cdf34cd">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a1342499dd436307bfc67a5c1a2b9d030">empty</a> () const</td></tr>
<tr class="memdesc:a1342499dd436307bfc67a5c1a2b9d030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the data container is empty.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a1342499dd436307bfc67a5c1a2b9d030">More...</a><br /></td></tr>
<tr class="separator:a1342499dd436307bfc67a5c1a2b9d030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189330db09787fee10fe05219053c0c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d66/namespace_kratos.html#a14b9d687ed53c882489400b57cdf34cd">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a189330db09787fee10fe05219053c0c4">IsSorted</a> () const</td></tr>
<tr class="memdesc:a189330db09787fee10fe05219053c0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the data container is sorted.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a189330db09787fee10fe05219053c0c4">More...</a><br /></td></tr>
<tr class="separator:a189330db09787fee10fe05219053c0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Input and output</div></td></tr>
<tr class="memitem:abdb848256181b043631f420438928614"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#abdb848256181b043631f420438928614">Info</a> () const</td></tr>
<tr class="memdesc:abdb848256181b043631f420438928614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn back information as a string.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#abdb848256181b043631f420438928614">More...</a><br /></td></tr>
<tr class="separator:abdb848256181b043631f420438928614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7498ec887e73ea0028eaf2762595d6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#af7498ec887e73ea0028eaf2762595d6e">PrintInfo</a> (std::ostream &amp;rOStream) const</td></tr>
<tr class="memdesc:af7498ec887e73ea0028eaf2762595d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print information about this object.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#af7498ec887e73ea0028eaf2762595d6e">More...</a><br /></td></tr>
<tr class="separator:af7498ec887e73ea0028eaf2762595d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b63b88582cccbd39944c89c9695ebb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a02b63b88582cccbd39944c89c9695ebb">PrintData</a> (std::ostream &amp;rOStream) const</td></tr>
<tr class="memdesc:a02b63b88582cccbd39944c89c9695ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print object's data.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a02b63b88582cccbd39944c89c9695ebb">More...</a><br /></td></tr>
<tr class="separator:a02b63b88582cccbd39944c89c9695ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Type Definitions</h2></td></tr>
<tr class="memitem:af8a4fed0ce0280ee0e6771a160ae589e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#af8a4fed0ce0280ee0e6771a160ae589e">key_type</a> = typename std::remove_reference&lt; decltype(std::declval&lt; TGetKeyType &gt;()(std::declval&lt; TDataType &gt;()))&gt;::type</td></tr>
<tr class="memdesc:af8a4fed0ce0280ee0e6771a160ae589e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key type for searching in this container.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#af8a4fed0ce0280ee0e6771a160ae589e">More...</a><br /></td></tr>
<tr class="separator:af8a4fed0ce0280ee0e6771a160ae589e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d912e5fb7e3681b3963f931170ddb3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a71d912e5fb7e3681b3963f931170ddb3">data_type</a> = TDataType</td></tr>
<tr class="separator:a71d912e5fb7e3681b3963f931170ddb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ebdbde8c06a8e4b5bc0df892f2b157"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ac9ebdbde8c06a8e4b5bc0df892f2b157">value_type</a> = TDataType</td></tr>
<tr class="separator:ac9ebdbde8c06a8e4b5bc0df892f2b157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ac299876078bab0f6c1274aa2c1afa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a18ac299876078bab0f6c1274aa2c1afa">key_compare</a> = TCompareType</td></tr>
<tr class="separator:a18ac299876078bab0f6c1274aa2c1afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5aa8d23ac7f841d8af8d31d611e15b7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#af5aa8d23ac7f841d8af8d31d611e15b7">pointer</a> = TPointerType</td></tr>
<tr class="separator:af5aa8d23ac7f841d8af8d31d611e15b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e20335661a4e1bd0aebef9e9a7deae"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a09e20335661a4e1bd0aebef9e9a7deae">reference</a> = TDataType &amp;</td></tr>
<tr class="separator:a09e20335661a4e1bd0aebef9e9a7deae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5f9f12d8d62ddd4fc07b5732b6ad28"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a2e5f9f12d8d62ddd4fc07b5732b6ad28">const_reference</a> = const TDataType &amp;</td></tr>
<tr class="separator:a2e5f9f12d8d62ddd4fc07b5732b6ad28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa702882c24c592f8fcd87937b2583e54"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#aa702882c24c592f8fcd87937b2583e54">ContainerType</a> = TContainerType</td></tr>
<tr class="separator:aa702882c24c592f8fcd87937b2583e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbf3ba9187f1eb4aa3f211328a7640e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9fbf3ba9187f1eb4aa3f211328a7640e">KRATOS_CLASS_POINTER_DEFINITION</a> (<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a>)</td></tr>
<tr class="memdesc:a9fbf3ba9187f1eb4aa3f211328a7640e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer definition of <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a>.  <a href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9fbf3ba9187f1eb4aa3f211328a7640e">More...</a><br /></td></tr>
<tr class="separator:a9fbf3ba9187f1eb4aa3f211328a7640e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Serialization</h2></td></tr>
<tr class="memitem:ad3f5346f31d572dd2ab4fcd658de5bc4"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ad3f5346f31d572dd2ab4fcd658de5bc4">Serializer</a></td></tr>
<tr class="separator:ad3f5346f31d572dd2ab4fcd658de5bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class TDataType, class TGetKeyType = KeyGenerator&lt;TDataType&gt;, class TCompareType = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType = typename TDataType::Pointer, class TContainerType = std::vector&lt;TPointerType&gt;&gt;<br />
class Kratos::PointerVectorSet&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;</h3>

<p>A sorted associative container similar to an STL set, but uses a vector to store pointers to its data. </p>
<p>The <code><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a></code> is a sorted associative container that behaves like an STL set but employs a vector to store pointers to its data elements. Many of its methods are inspired by the Boost ptr_container library, with modifications to support shared pointers. </p><dl class="section note"><dt>Note</dt><dd>Unlike the Boost counterpart, this container does not manage memory deallocation automatically. It relies on the use of smart pointers or manual memory management for resource cleanup. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Pooyan Dadvand </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab0c9895ef32d8cc0be148b13be9f7be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c9895ef32d8cc0be148b13be9f7be0">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab0c9895ef32d8cc0be148b13be9f7be0">const_iterator</a> =  boost::indirect_iterator&lt;typename TContainerType::const_iterator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e5f9f12d8d62ddd4fc07b5732b6ad28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5f9f12d8d62ddd4fc07b5732b6ad28">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a2e5f9f12d8d62ddd4fc07b5732b6ad28">const_reference</a> =  const TDataType&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a982242ae1658b371d7b94db8bfcb8b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982242ae1658b371d7b94db8bfcb8b67">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a982242ae1658b371d7b94db8bfcb8b67">const_reverse_iterator</a> =  boost::indirect_iterator&lt;typename TContainerType::const_reverse_iterator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa702882c24c592f8fcd87937b2583e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa702882c24c592f8fcd87937b2583e54">&#9670;&nbsp;</a></span>ContainerType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#aa702882c24c592f8fcd87937b2583e54">ContainerType</a> =  TContainerType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a71d912e5fb7e3681b3963f931170ddb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d912e5fb7e3681b3963f931170ddb3">&#9670;&nbsp;</a></span>data_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a71d912e5fb7e3681b3963f931170ddb3">data_type</a> =  TDataType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ca357d043deb756c3a32664d807dba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca357d043deb756c3a32664d807dba5">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a5ca357d043deb756c3a32664d807dba5">difference_type</a> =  typename TContainerType::difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d86d2359054ebdf0b7e941d8b50f857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d86d2359054ebdf0b7e941d8b50f857">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a> =  boost::indirect_iterator&lt;typename TContainerType::iterator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18ac299876078bab0f6c1274aa2c1afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ac299876078bab0f6c1274aa2c1afa">&#9670;&nbsp;</a></span>key_compare</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a18ac299876078bab0f6c1274aa2c1afa">key_compare</a> =  TCompareType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8a4fed0ce0280ee0e6771a160ae589e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a4fed0ce0280ee0e6771a160ae589e">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#af8a4fed0ce0280ee0e6771a160ae589e">key_type</a> =  typename std::remove_reference&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Key type for searching in this container. </p>

</div>
</div>
<a id="af5aa8d23ac7f841d8af8d31d611e15b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5aa8d23ac7f841d8af8d31d611e15b7">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#af5aa8d23ac7f841d8af8d31d611e15b7">pointer</a> =  TPointerType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a35723a3d56fbc10a31a5a632534bc0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35723a3d56fbc10a31a5a632534bc0cc">&#9670;&nbsp;</a></span>ptr_const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a35723a3d56fbc10a31a5a632534bc0cc">ptr_const_iterator</a> =  typename TContainerType::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a32c1338fe46599db3bd5b43749cc2524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c1338fe46599db3bd5b43749cc2524">&#9670;&nbsp;</a></span>ptr_const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a32c1338fe46599db3bd5b43749cc2524">ptr_const_reverse_iterator</a> =  typename TContainerType::const_reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1bb256b141e6d49dbd169c75b847a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1bb256b141e6d49dbd169c75b847a7f">&#9670;&nbsp;</a></span>ptr_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ae1bb256b141e6d49dbd169c75b847a7f">ptr_iterator</a> =  typename TContainerType::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09f71f32572e7f1b8cb3fe87f5a02ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f71f32572e7f1b8cb3fe87f5a02ccb">&#9670;&nbsp;</a></span>ptr_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a09f71f32572e7f1b8cb3fe87f5a02ccb">ptr_reverse_iterator</a> =  typename TContainerType::reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09e20335661a4e1bd0aebef9e9a7deae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e20335661a4e1bd0aebef9e9a7deae">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a09e20335661a4e1bd0aebef9e9a7deae">reference</a> =  TDataType&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a731f3f90c1bf62309910dc58539947ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731f3f90c1bf62309910dc58539947ac">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a731f3f90c1bf62309910dc58539947ac">reverse_iterator</a> =  boost::indirect_iterator&lt;typename TContainerType::reverse_iterator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f15f0eae9d29b51403cc5a6c4ea0377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f15f0eae9d29b51403cc5a6c4ea0377">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9f15f0eae9d29b51403cc5a6c4ea0377">size_type</a> =  typename TContainerType::size_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9ebdbde8c06a8e4b5bc0df892f2b157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ebdbde8c06a8e4b5bc0df892f2b157">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ac9ebdbde8c06a8e4b5bc0df892f2b157">value_type</a> =  TDataType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa78dfa5cfb3d7e03a3f45b5dc6736c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78dfa5cfb3d7e03a3f45b5dc6736c0b">&#9670;&nbsp;</a></span>PointerVectorSet() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="ab5c6436620a7195dbafc846841c29933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c6436620a7195dbafc846841c29933">&#9670;&nbsp;</a></span>PointerVectorSet() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<div class="memtemplate">
template&lt;class TInputIteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a> </td>
          <td>(</td>
          <td class="paramtype">TInputIteratorType&#160;</td>
          <td class="paramname"><em>First</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInputIteratorType&#160;</td>
          <td class="paramname"><em>Last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9f15f0eae9d29b51403cc5a6c4ea0377">size_type</a>&#160;</td>
          <td class="paramname"><em>NewMaxBufferSize</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> from a range of elements. </p>
<p>This constructor initializes a <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> with elements in the range [First, Last). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInputIteratorType</td><td>The type of the input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">First</td><td>An input iterator pointing to the beginning of the range. </td></tr>
    <tr><td class="paramname">Last</td><td>An input iterator pointing to the end of the range. </td></tr>
    <tr><td class="paramname">NewMaxBufferSize</td><td>The maximum buffer size (default is 1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad93dc8afceec2eea45b9e4a6c99547a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad93dc8afceec2eea45b9e4a6c99547a">&#9670;&nbsp;</a></span>PointerVectorSet() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rOther</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor for <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rOther</td><td>The <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> to copy from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad04b2ad65d16b0d1114c5263542dd195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04b2ad65d16b0d1114c5263542dd195">&#9670;&nbsp;</a></span>PointerVectorSet() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a> </td>
          <td>(</td>
          <td class="paramtype">const TContainerType &amp;&#160;</td>
          <td class="paramname"><em>rContainer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> from a container. </p>
<p>This constructor initializes a <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> with elements from a container. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rContainer</td><td>The container to copy elements from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7566aea3723f37994018fada51f50562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7566aea3723f37994018fada51f50562">&#9670;&nbsp;</a></span>~PointerVectorSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::~<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abdd5d03d41a80ab0162e89d737e2a3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd5d03d41a80ab0162e89d737e2a3e4">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a2e5f9f12d8d62ddd4fc07b5732b6ad28">const_reference</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the last element in the container. </p>
<dl class="section note"><dt>Note</dt><dd>This function is marked as "noexcept," and it asserts that the container is not empty. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the last element in the container. </dd></dl>

</div>
</div>
<a id="a49220d813516ed00526ddf1fad50834d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49220d813516ed00526ddf1fad50834d">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a09e20335661a4e1bd0aebef9e9a7deae">reference</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>
<dl class="section note"><dt>Note</dt><dd>This function is marked as "noexcept," and it asserts that the container is not empty. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the last element in the container. </dd></dl>

</div>
</div>
<a id="aaba01bc27b154ddfb13c4875a1ee2cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba01bc27b154ddfb13c4875a1ee2cfb">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the beginning of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the beginning of the container. </dd></dl>

</div>
</div>
<a id="a7554a81db1fc1b04d5963996369ca5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7554a81db1fc1b04d5963996369ca5c3">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab0c9895ef32d8cc0be148b13be9f7be0">const_iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the beginning of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the beginning of the container. </dd></dl>

</div>
</div>
<a id="a3632be090875177f1d4e068440d1f1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3632be090875177f1d4e068440d1f1a3">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d66/namespace_kratos.html#ac398e9982e45de7167981e05b7f5ff57">int</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current capacity of the underlying data container. </p>
<p>This function returns the current capacity of the underlying data container. </p><dl class="section return"><dt>Returns</dt><dd>The current capacity of the data container. </dd></dl>

</div>
</div>
<a id="ac5df2cb372080576e7ed3ed776e68226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5df2cb372080576e7ed3ed776e68226">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab0c9895ef32d8cc0be148b13be9f7be0">const_iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the beginning of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the beginning of the container. </dd></dl>

</div>
</div>
<a id="a2051aff8d20dc33737b1e78cd41c22d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2051aff8d20dc33737b1e78cd41c22d8">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab0c9895ef32d8cc0be148b13be9f7be0">const_iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the beginning of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the beginning of the container. </dd></dl>

</div>
</div>
<a id="a9e7b918947f7e471f09731e30a76c7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7b918947f7e471f09731e30a76c7a3">&#9670;&nbsp;</a></span>cend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab0c9895ef32d8cc0be148b13be9f7be0">const_iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the end of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the end of the container. </dd></dl>

</div>
</div>
<a id="a18a6e7cba3fd8a97d797d6430e0e3ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a6e7cba3fd8a97d797d6430e0e3ba0">&#9670;&nbsp;</a></span>cend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab0c9895ef32d8cc0be148b13be9f7be0">const_iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the end of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the end of the container. </dd></dl>

</div>
</div>
<a id="a404edde77c0022da427c4ac24e389a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404edde77c0022da427c4ac24e389a66">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the set, removing all elements. </p>
<p>This function clears the set by removing all elements, resetting <code>mSortedPartSize</code> to zero, and setting <code>mMaxBufferSize</code> to 1. </p>

</div>
</div>
<a id="a94c2c3993d3bbeb0320128d3abca0b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c2c3993d3bbeb0320128d3abca0b07">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9f15f0eae9d29b51403cc5a6c4ea0377">size_type</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#af8a4fed0ce0280ee0e6771a160ae589e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>Key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of elements with the specified key. </p>
<p>This function counts the number of elements with the specified key in the set. It returns 1 if the element is found and 0 if it's not found. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>The key to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements with the specified key (0 or 1). </dd></dl>

</div>
</div>
<a id="a1342499dd436307bfc67a5c1a2b9d030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1342499dd436307bfc67a5c1a2b9d030">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d66/namespace_kratos.html#a14b9d687ed53c882489400b57cdf34cd">bool</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the data container is empty. </p>
<p>This function checks if the data container, represented by the member variable mData, is empty. </p><dl class="section return"><dt>Returns</dt><dd>True if the data container is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="acc410959c998f861779d4e180822b78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc410959c998f861779d4e180822b78b">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the end of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the end of the container. </dd></dl>

</div>
</div>
<a id="a2caff98e6ec42bec7bc4eba25bfcfe3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2caff98e6ec42bec7bc4eba25bfcfe3f">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab0c9895ef32d8cc0be148b13be9f7be0">const_iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the end of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the end of the container. </dd></dl>

</div>
</div>
<a id="acbf785fbfbb0a06909b30819704445f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf785fbfbb0a06909b30819704445f4">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#af8a4fed0ce0280ee0e6771a160ae589e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase an element with the specified key. </p>
<p>This function erases an element with the specified key by first finding the element using the <code>find</code> function and then erasing it using the <code><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a20c9a79626ecb4b2505f2a0e47d274d4" title="Erase an element at the specified position.">erase(iterator)</a></code> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key of the element to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element following the erased element, or <code><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#acc410959c998f861779d4e180822b78b" title="Returns an iterator pointing to the end of the container.">end()</a></code> if the element with the specified key was not found. </dd></dl>

</div>
</div>
<a id="acc997f2ff4fd58bd5233b478abf6a166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc997f2ff4fd58bd5233b478abf6a166">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase a range of elements defined by iterators. </p>
<p>This function erases a range of elements defined by the iterators <code>first</code> and <code>last</code> and updates <code>mSortedPartSize</code> to match the size of the data container. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator pointing to the beginning of the range to erase. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator pointing to the end of the range to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element following the last erased element. </dd></dl>

</div>
</div>
<a id="a20c9a79626ecb4b2505f2a0e47d274d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c9a79626ecb4b2505f2a0e47d274d4">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase an element at the specified position. </p>
<p>This function erases the element at the specified position and updates <code>mSortedPartSize</code> to match the size of the data container. If the provided position is equal to <code><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#acc410959c998f861779d4e180822b78b" title="Returns an iterator pointing to the end of the container.">end()</a></code>, it returns <code><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#acc410959c998f861779d4e180822b78b" title="Returns an iterator pointing to the end of the container.">end()</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>An iterator pointing to the position of the element to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element following the erased element, or <code><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#acc410959c998f861779d4e180822b78b" title="Returns an iterator pointing to the end of the container.">end()</a></code> if the provided position was equal to <code><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#acc410959c998f861779d4e180822b78b" title="Returns an iterator pointing to the end of the container.">end()</a></code>. </dd></dl>

</div>
</div>
<a id="ab43952d7627f9ec050badbe7b3c37545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43952d7627f9ec050badbe7b3c37545">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#af8a4fed0ce0280ee0e6771a160ae589e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>Key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find an element with the specified key. </p>
<p>This function searches for an element with the specified key in the set. If the element is found, it returns an iterator to the found element. If the element is not found, it returns an iterator pointing to the end of the set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the found element or the end of the set if not found. </dd></dl>

</div>
</div>
<a id="ac925c6aa3e8effc15c8ee3d0fcc2c12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac925c6aa3e8effc15c8ee3d0fcc2c12e">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab0c9895ef32d8cc0be148b13be9f7be0">const_iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#af8a4fed0ce0280ee0e6771a160ae589e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>Key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find an element with the specified key (const version). </p>
<p>This function is a const version of <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab43952d7627f9ec050badbe7b3c37545" title="Find an element with the specified key.">find()</a> and searches for an element with the specified key in the set. If the element is found, it returns a const_iterator to the found element. If the element is not found, it returns a const_iterator pointing to the end of the set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const_iterator pointing to the found element or the end of the set if not found. </dd></dl>

</div>
</div>
<a id="a5f53a09d2b4ddaaf77c896fc238be04c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f53a09d2b4ddaaf77c896fc238be04c">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a2e5f9f12d8d62ddd4fc07b5732b6ad28">const_reference</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the first element in the container. </p>
<dl class="section note"><dt>Note</dt><dd>This function is marked as "noexcept," and it asserts that the container is not empty. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the first element in the container. </dd></dl>

</div>
</div>
<a id="a437759ea41af3ce466398ecfad458b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437759ea41af3ce466398ecfad458b72">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a09e20335661a4e1bd0aebef9e9a7deae">reference</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>
<dl class="section note"><dt>Note</dt><dd>This function is marked as "noexcept," and it asserts that the container is not empty. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the first element in the container. </dd></dl>

</div>
</div>
<a id="a9e0191b0541cf064e235f4c507f705cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0191b0541cf064e235f4c507f705cb">&#9670;&nbsp;</a></span>GetContainer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TContainerType&amp; <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::GetContainer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gives a reference to underly normal container. </p>

</div>
</div>
<a id="a5d3ed07ae7047004de1ab566a6f30e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3ed07ae7047004de1ab566a6f30e7e">&#9670;&nbsp;</a></span>GetContainer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const TContainerType&amp; <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::GetContainer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gives a constant reference to underly normal container. </p>

</div>
</div>
<a id="a986c96a2aa91cd316639948b5caadf6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a986c96a2aa91cd316639948b5caadf6d">&#9670;&nbsp;</a></span>GetMaxBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9f15f0eae9d29b51403cc5a6c4ea0377">size_type</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::GetMaxBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum size of buffer used in the container. </p>

</div>
</div>
<a id="aaa8a1a6a738015c7dde576fbdb5b134d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8a1a6a738015c7dde576fbdb5b134d">&#9670;&nbsp;</a></span>GetSortedPartSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9f15f0eae9d29b51403cc5a6c4ea0377">size_type</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::GetSortedPartSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the sorted part size of buffer used in the container. </p>

</div>
</div>
<a id="abdb848256181b043631f420438928614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb848256181b043631f420438928614">&#9670;&nbsp;</a></span>Info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::Info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turn back information as a string. </p>

</div>
</div>
<a id="a14db40ca708dd745ef9c06af5bdd93d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14db40ca708dd745ef9c06af5bdd93d4">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rOther</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a669530068394cbcb58219555a3f7059e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669530068394cbcb58219555a3f7059e">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const TPointerType &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a pointer. </p>
<p>This function inserts a given pointer such that the resulting <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> is kept sorted. If there exists already a pointer with a key same as the key of the value, then this will return iterator of that existing pointer (The value will not be inserted.) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The pointer to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the inserted element. </dd></dl>

</div>
</div>
<a id="aa88e8f852ff528d96652d429ec311233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88e8f852ff528d96652d429ec311233">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a4d86d2359054ebdf0b7e941d8b50f857">iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab0c9895ef32d8cc0be148b13be9f7be0">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position_hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TPointerType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a pointer at the specified position. </p>
<p>This function inserts a given pointer. If the given position_hint is valid, then it uses that to insert the value, otherwise the position_hint is discarded to maintain the dataset sorted. If there is an existing element with the same key as in the value, then an iterator for the existing element is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position_hint</td><td>An iterator pointing to the position where the pointer may be inserted. </td></tr>
    <tr><td class="paramname">value</td><td>The pointer to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the inserted element. </dd></dl>

</div>
</div>
<a id="a95d15b443820ba8d92718a731f8b1531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d15b443820ba8d92718a731f8b1531">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements from a range of iterators. </p>
<p>This function inserts element pointers from a range defined by the iterators <code>first</code> and <code>last</code> into the set. This will not insert any elements in the range, if there exists an element with a key which is equal to an element's key in the input range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An input iterator pointing to the beginning of the range to insert. </td></tr>
    <tr><td class="paramname">last</td><td>An input iterator pointing to the end of the range to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac67f548f43d1fb79dd6acfe2e19191d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67f548f43d1fb79dd6acfe2e19191d4">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab0c9895ef32d8cc0be148b13be9f7be0">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::<a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ab0c9895ef32d8cc0be148b13be9f7be0">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements from another <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> range. </p>
<p>This function inserts element pointers from another <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> range specified by first and last into the current set. Since, <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> is assumed to be sorted and unique, the incoming <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> is not sorted and made unique again. This will not insert any elements in the incoming set, if there exists an element with a key which is equal to an element's key in the input range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Other <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> starting iterator </td></tr>
    <tr><td class="paramname">last</td><td>Other <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> ending iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a189330db09787fee10fe05219053c0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189330db09787fee10fe05219053c0c4">&#9670;&nbsp;</a></span>IsSorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d66/namespace_kratos.html#a14b9d687ed53c882489400b57cdf34cd">bool</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::IsSorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the data container is sorted. </p>
<p>This function checks if the sorted portion of the data, indicated by the member variable mSortedPartSize, is equal to the total size of the data container mData. This is used to determine if the data is sorted. </p><dl class="section return"><dt>Returns</dt><dd>True if the data is sorted, false otherwise. </dd></dl>

</div>
</div>
<a id="ae8f8120945960a9c8aa9e71545c98ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f8120945960a9c8aa9e71545c98ba8">&#9670;&nbsp;</a></span>key_comp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a18ac299876078bab0f6c1274aa2c1afa">key_compare</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::key_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the key comparison function used for ordering elements in the container. </p>
<p>This function returns an instance of the key comparison function (TCompareType) used for ordering elements in the container. </p><dl class="section return"><dt>Returns</dt><dd>The key comparison function. </dd></dl>

</div>
</div>
<a id="a9fbf3ba9187f1eb4aa3f211328a7640e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fbf3ba9187f1eb4aa3f211328a7640e">&#9670;&nbsp;</a></span>KRATOS_CLASS_POINTER_DEFINITION()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::KRATOS_CLASS_POINTER_DEFINITION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer definition of <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a>. </p>

</div>
</div>
<a id="a33a878acb729a33919350410564fc080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a878acb729a33919350410564fc080">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9f15f0eae9d29b51403cc5a6c4ea0377">size_type</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum possible number of elements the container can hold. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum possible number of elements the container can hold. </dd></dl>

</div>
</div>
<a id="ad4a2ed258b9f55866406eea859d3e9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a2ed258b9f55866406eea859d3e9d2">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#af5aa8d23ac7f841d8af8d31d611e15b7">pointer</a>&amp; <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#af8a4fed0ce0280ee0e6771a160ae589e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>Key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function for inserting or retrieving a pointer associated with a key. </p>
<p>This function allows you to insert or retrieve a pointer associated with a key in the set. If the key already exists in the set, it returns the corresponding pointer. If not, it inserts the key and a new pointer into the set and returns the newly inserted pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>The key for which you want to insert or retrieve a pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the pointer associated with the given key. </dd></dl>

</div>
</div>
<a id="a9f89fae0fd6307d75e3557f4fe27c5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f89fae0fd6307d75e3557f4fe27c5c7">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d66/namespace_kratos.html#a14b9d687ed53c882489400b57cdf34cd">bool</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than comparison operator for two <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> objects. </p>
<p>This operator checks if one <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> is less than another by comparing their elements using the CompareKey comparison function in a lexicographical order. </p><dl class="section note"><dt>Note</dt><dd>This function is marked as "noexcept," and it asserts that the container is not empty. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this set is less than r, false otherwise. </dd></dl>

</div>
</div>
<a id="ab4b83508cdfed63ff09850456831782c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b83508cdfed63ff09850456831782c">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a>&amp; <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rOther</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator for <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a>. </p>
<p>Assigns the contents of another <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> to this one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rOther</td><td>The <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> to assign from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the modified <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a>. </dd></dl>

</div>
</div>
<a id="ac163be01a5b710f7be15c1d317930ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac163be01a5b710f7be15c1d317930ae6">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d66/namespace_kratos.html#a14b9d687ed53c882489400b57cdf34cd">bool</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator for two <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> objects. </p>
<p>This operator checks if two <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> objects are equal by comparing their sizes and the equality of their elements using the EqualKeyTo comparison function. </p><dl class="section note"><dt>Note</dt><dd>This function is marked as "noexcept," and it asserts that the container is not empty. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two sets are equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a810d6a231dfea712bcaef646afdd89c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810d6a231dfea712bcaef646afdd89c8">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TDataType&amp; <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#af8a4fed0ce0280ee0e6771a160ae589e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>Key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses an element by key and returns a reference. </p>
<p>This operator allows you to access an element in the <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> by its key. If the key is not found, a new element with the provided key is inserted into the set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>The key of the element to access or insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed or newly inserted element. </dd></dl>

</div>
</div>
<a id="a5dffb1e73a06bb2fc756b0134f5879cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dffb1e73a06bb2fc756b0134f5879cc">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last element from the set. </p>
<p>This function removes the last element (pointer) from the set and updates mSortedPartSize if necessary. </p>

</div>
</div>
<a id="a02b63b88582cccbd39944c89c9695ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02b63b88582cccbd39944c89c9695ebb">&#9670;&nbsp;</a></span>PrintData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::PrintData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>rOStream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print object's data. </p>

</div>
</div>
<a id="af7498ec887e73ea0028eaf2762595d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7498ec887e73ea0028eaf2762595d6e">&#9670;&nbsp;</a></span>PrintInfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::PrintInfo </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>rOStream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print information about this object. </p>

</div>
</div>
<a id="a4e4998c693d7262809d3a818c9995311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4998c693d7262809d3a818c9995311">&#9670;&nbsp;</a></span>ptr_begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ae1bb256b141e6d49dbd169c75b847a7f">ptr_iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::ptr_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the beginning of the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the beginning of the underlying data container. </dd></dl>

</div>
</div>
<a id="a78ff47c567428535ed8731ddc181d074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ff47c567428535ed8731ddc181d074">&#9670;&nbsp;</a></span>ptr_begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a35723a3d56fbc10a31a5a632534bc0cc">ptr_const_iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::ptr_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the beginning of the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the beginning of the underlying data container. </dd></dl>

</div>
</div>
<a id="a3e3061ba89e3e5ba034a316fde4635b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3061ba89e3e5ba034a316fde4635b2">&#9670;&nbsp;</a></span>ptr_end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#ae1bb256b141e6d49dbd169c75b847a7f">ptr_iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::ptr_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the end of the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the end of the underlying data container. </dd></dl>

</div>
</div>
<a id="a429f3c4cdbeed613f895eebbc1cfb791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429f3c4cdbeed613f895eebbc1cfb791">&#9670;&nbsp;</a></span>ptr_end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a35723a3d56fbc10a31a5a632534bc0cc">ptr_const_iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::ptr_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the end of the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the end of the underlying data container. </dd></dl>

</div>
</div>
<a id="a123b2dd335e4cd2f1fe71bfcb421db8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123b2dd335e4cd2f1fe71bfcb421db8d">&#9670;&nbsp;</a></span>ptr_rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a09f71f32572e7f1b8cb3fe87f5a02ccb">ptr_reverse_iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::ptr_rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator pointing to the beginning of the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>A reverse iterator pointing to the beginning of the underlying data container. </dd></dl>

</div>
</div>
<a id="abc58960c179f85f62fa0158cfb5794ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc58960c179f85f62fa0158cfb5794ce">&#9670;&nbsp;</a></span>ptr_rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a32c1338fe46599db3bd5b43749cc2524">ptr_const_reverse_iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::ptr_rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reverse iterator pointing to the beginning of the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant reverse iterator pointing to the beginning of the underlying data container. </dd></dl>

</div>
</div>
<a id="aa769b3c3c5990960082b309d6e6db202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa769b3c3c5990960082b309d6e6db202">&#9670;&nbsp;</a></span>ptr_rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a09f71f32572e7f1b8cb3fe87f5a02ccb">ptr_reverse_iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::ptr_rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator pointing to the end of the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>A reverse iterator pointing to the end of the underlying data container. </dd></dl>

</div>
</div>
<a id="a647e56987697fa2c944e47ec9587ca20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647e56987697fa2c944e47ec9587ca20">&#9670;&nbsp;</a></span>ptr_rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a32c1338fe46599db3bd5b43749cc2524">ptr_const_reverse_iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::ptr_rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reverse iterator pointing to the end of the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant reverse iterator pointing to the end of the underlying data container. </dd></dl>

</div>
</div>
<a id="a9d223f7af1848345c2d25830364314f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d223f7af1848345c2d25830364314f0">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">TPointerType&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a pointer to the end of the set. </p>
<p>This function appends a given pointer to the end of the set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The pointer to be added to the end of the set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac04df723f946f80734ad4ffc4087ae09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04df723f946f80734ad4ffc4087ae09">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a731f3f90c1bf62309910dc58539947ac">reverse_iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator pointing to the beginning of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>A reverse iterator pointing to the beginning of the container. </dd></dl>

</div>
</div>
<a id="aeb601c0ba75590a5160f19b170706227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb601c0ba75590a5160f19b170706227">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a982242ae1658b371d7b94db8bfcb8b67">const_reverse_iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reverse iterator pointing to the beginning of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant reverse iterator pointing to the beginning of the container. </dd></dl>

</div>
</div>
<a id="a7fa02dde364140f40e6d2807c1390f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa02dde364140f40e6d2807c1390f3a">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a731f3f90c1bf62309910dc58539947ac">reverse_iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator pointing to the end of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>A reverse iterator pointing to the end of the container. </dd></dl>

</div>
</div>
<a id="a824a63157f688e2af1e6ccd4af39b1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824a63157f688e2af1e6ccd4af39b1e6">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a982242ae1658b371d7b94db8bfcb8b67">const_reverse_iterator</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reverse iterator pointing to the end of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant reverse iterator pointing to the end of the container. </dd></dl>

</div>
</div>
<a id="ac36a7d1445d4eadf75b341924f3aa4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36a7d1445d4eadf75b341924f3aa4dd">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d66/namespace_kratos.html#ac398e9982e45de7167981e05b7f5ff57">int</a>&#160;</td>
          <td class="paramname"><em>reservedsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves memory for a specified number of elements. </p>
<p>This function reserves memory in the underlying data container for a specified number of elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reservedsize</td><td>The number of elements to reserve memory for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad596433592bb75505dee457903fda899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad596433592bb75505dee457903fda899">&#9670;&nbsp;</a></span>SetMaxBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::SetMaxBufferSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9f15f0eae9d29b51403cc5a6c4ea0377">size_type</a>&#160;</td>
          <td class="paramname"><em>NewSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum size of buffer used in the container. </p>
<p>This container uses a buffer which keep data unsorted. After buffer size arrived to the MaxBufferSize it will sort all container and empties buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NewSize</td><td>Is the new buffer maximum size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cfe731c1844b327ef0d466091db4082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfe731c1844b327ef0d466091db4082">&#9670;&nbsp;</a></span>SetSortedPartSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::SetSortedPartSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9f15f0eae9d29b51403cc5a6c4ea0377">size_type</a>&#160;</td>
          <td class="paramname"><em>NewSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the sorted part size of buffer used in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NewSize</td><td>Is the new buffer maximum size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a510c92d5ebe9a4beeb063269530ef31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510c92d5ebe9a4beeb063269530ef31a">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html#a9f15f0eae9d29b51403cc5a6c4ea0377">size_type</a> <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container. </dd></dl>

</div>
</div>
<a id="a7542007a871149bde5d4edfb73829d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7542007a871149bde5d4edfb73829d4f">&#9670;&nbsp;</a></span>Sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::Sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the elements in the set. </p>
<p>This function sorts the elements in the set using the CompareKey comparison function. After sorting, it updates mSortedPartSize to match the size of the data container. </p>

</div>
</div>
<a id="a519817f38830be9013c5af58273ffab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519817f38830be9013c5af58273ffab7">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rOther</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> with another. </p>
<p>This function swaps the contents of this <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> with another set, including mSortedPartSize, mMaxBufferSize, and mData. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rOther</td><td>The other <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html" title="A sorted associative container similar to an STL set, but uses a vector to store pointers to its data...">PointerVectorSet</a> to swap with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00b4b6cbbe3e808fc3e612ee815d09a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b4b6cbbe3e808fc3e612ee815d09a9">&#9670;&nbsp;</a></span>Unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/dc6/class_kratos_1_1_pointer_vector_set.html">Kratos::PointerVectorSet</a>&lt; TDataType, TGetKeyType, TCompareType, TEqualType, TPointerType, TContainerType &gt;::Unique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove duplicate elements from the set. </p>
<p>This function removes duplicate elements from the set using the EqualKeyTo comparison function. After removing duplicates, it updates mSortedPartSize to match the size of the data container. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ad3f5346f31d572dd2ab4fcd658de5bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f5346f31d572dd2ab4fcd658de5bc4">&#9670;&nbsp;</a></span>Serializer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDataType , class TGetKeyType  = KeyGenerator&lt;TDataType&gt;, class TCompareType  = std::less&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TEqualType  = std::equal_to&lt;decltype(std::declval&lt;TGetKeyType&gt;()(std::declval&lt;TDataType&gt;()))&gt;, class TPointerType  = typename TDataType::Pointer, class TContainerType  = std::vector&lt;TPointerType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="../../dd/d32/class_kratos_1_1_serializer.html">Serializer</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/Documentation/Documentation/master/kratos/containers/<a class="el" href="../../d4/d35/pointer__vector__set_8h_source.html">pointer_vector_set.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 30 2024 03:20:30 for KratosMultiphysics by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
