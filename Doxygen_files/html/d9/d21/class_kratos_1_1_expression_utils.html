<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KratosMultiphysics: Kratos::ExpressionUtils Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../kratos_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">KratosMultiphysics
   </div>
   <div id="projectbrief">KRATOS Multiphysics (Kratos) is a framework for building parallel, multi-disciplinary simulation software, aiming at modularity, extensibility, and high performance. Kratos is written in C++, and counts with an extensive Python interface.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../db/d66/namespace_kratos.html">Kratos</a></li><li class="navelem"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html">ExpressionUtils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="../../d0/d64/class_kratos_1_1_expression_utils-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Kratos::ExpressionUtils Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="../../d5/da4/expression__utils_8h_source.html">expression_utils.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Kratos::ExpressionUtils:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../db/d3c/class_kratos_1_1_expression_utils__coll__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Type definitions</div></td></tr>
<tr class="memitem:a3cf2546c42481c4106f3735e4b14b540"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a3cf2546c42481c4106f3735e4b14b540">IndexType</a> = std::size_t</td></tr>
<tr class="separator:a3cf2546c42481c4106f3735e4b14b540"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Static entity value operations</div></td></tr>
<tr class="memitem:a6d558dae353813bef7818428f57a967b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a6d558dae353813bef7818428f57a967b">Collapse</a> (const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;rpExpression)</td></tr>
<tr class="memdesc:a6d558dae353813bef7818428f57a967b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse the lazy expression tree structure in the expression.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a6d558dae353813bef7818428f57a967b">More...</a><br /></td></tr>
<tr class="separator:a6d558dae353813bef7818428f57a967b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c5356213a929b5273f89bae07c566d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a73c5356213a929b5273f89bae07c566d">Slice</a> (const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;rpExpression, std::size_t Offset, std::size_t Stride)</td></tr>
<tr class="memdesc:a73c5356213a929b5273f89bae07c566d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an expression containing a subset of the components of all items.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a73c5356213a929b5273f89bae07c566d">More...</a><br /></td></tr>
<tr class="separator:a73c5356213a929b5273f89bae07c566d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff1546ae9efe2a5a3f7ee9b3d4b155f"><td class="memTemplParams" colspan="2">template&lt;class TIterator &gt; </td></tr>
<tr class="memitem:acff1546ae9efe2a5a3f7ee9b3d4b155f"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#acff1546ae9efe2a5a3f7ee9b3d4b155f">Reshape</a> (const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;rpExpression, TIterator NewShapeBegin, TIterator NewShapeEnd)</td></tr>
<tr class="memdesc:acff1546ae9efe2a5a3f7ee9b3d4b155f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an expression with identical data but interpreted with a new item shape.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#acff1546ae9efe2a5a3f7ee9b3d4b155f">More...</a><br /></td></tr>
<tr class="separator:acff1546ae9efe2a5a3f7ee9b3d4b155f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a96c3e95187e535f9566716a14c904e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a0a96c3e95187e535f9566716a14c904e">Reshape</a> (const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;rpExpression, const std::vector&lt; <a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a3cf2546c42481c4106f3735e4b14b540">IndexType</a> &gt; &amp;rNewShape)</td></tr>
<tr class="memdesc:a0a96c3e95187e535f9566716a14c904e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an expression with identical data but interpreted with a new item shape.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a0a96c3e95187e535f9566716a14c904e">More...</a><br /></td></tr>
<tr class="separator:a0a96c3e95187e535f9566716a14c904e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635878f798e10e7cb5abd5fe93dae638"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a635878f798e10e7cb5abd5fe93dae638">Comb</a> (const std::vector&lt; <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &gt; &amp;rpExpressions)</td></tr>
<tr class="memdesc:a635878f798e10e7cb5abd5fe93dae638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the components of a set of expressions to the current expression's components.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a635878f798e10e7cb5abd5fe93dae638">More...</a><br /></td></tr>
<tr class="separator:a635878f798e10e7cb5abd5fe93dae638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80b490e5967228062b8b86a70d03293"><td class="memTemplParams" colspan="2">template&lt;class TIterator &gt; </td></tr>
<tr class="memitem:ab80b490e5967228062b8b86a70d03293"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#ab80b490e5967228062b8b86a70d03293">Comb</a> (TIterator ExpressionBegin, TIterator ExpressionEnd)</td></tr>
<tr class="memdesc:ab80b490e5967228062b8b86a70d03293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the components of a set of expressions to the current expression's components.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#ab80b490e5967228062b8b86a70d03293">More...</a><br /></td></tr>
<tr class="separator:ab80b490e5967228062b8b86a70d03293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f49b1ae5b5b8fb7db5448ad5fbf3f63"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a3f49b1ae5b5b8fb7db5448ad5fbf3f63">Abs</a> (const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;rpExpression)</td></tr>
<tr class="memdesc:a3f49b1ae5b5b8fb7db5448ad5fbf3f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression which represents the component wise absolute value of the given expression.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a3f49b1ae5b5b8fb7db5448ad5fbf3f63">More...</a><br /></td></tr>
<tr class="separator:a3f49b1ae5b5b8fb7db5448ad5fbf3f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4b023ae06e54ef0ed74b2543e88f73"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a7f4b023ae06e54ef0ed74b2543e88f73">Log</a> (const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;rpExpression)</td></tr>
<tr class="memdesc:a7f4b023ae06e54ef0ed74b2543e88f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression which represents the component wise logarithmic value of the given expression.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a7f4b023ae06e54ef0ed74b2543e88f73">More...</a><br /></td></tr>
<tr class="separator:a7f4b023ae06e54ef0ed74b2543e88f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afa09e7d1254da2aed0c0f2070675e2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a8afa09e7d1254da2aed0c0f2070675e2">Pow</a> (const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;rpExpression, const <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a> Power)</td></tr>
<tr class="memdesc:a8afa09e7d1254da2aed0c0f2070675e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression which raises each component to the given power.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a8afa09e7d1254da2aed0c0f2070675e2">More...</a><br /></td></tr>
<tr class="separator:a8afa09e7d1254da2aed0c0f2070675e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d800c165fead9e2f7758305d9d269f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a34d800c165fead9e2f7758305d9d269f">Pow</a> (const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;rpExpression, const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;rpPowerpExpression)</td></tr>
<tr class="memdesc:a34d800c165fead9e2f7758305d9d269f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression which raises each component to the given power from another expression.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a34d800c165fead9e2f7758305d9d269f">More...</a><br /></td></tr>
<tr class="separator:a34d800c165fead9e2f7758305d9d269f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece580e1f1c217b209dbbb776e711fb9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#aece580e1f1c217b209dbbb776e711fb9">Scale</a> (const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;rpExpression, const <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a> Scale)</td></tr>
<tr class="memdesc:aece580e1f1c217b209dbbb776e711fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression which scales each component to the specified value.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#aece580e1f1c217b209dbbb776e711fb9">More...</a><br /></td></tr>
<tr class="separator:aece580e1f1c217b209dbbb776e711fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb29e543b2c1e5dc9477ddd32a694424"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#acb29e543b2c1e5dc9477ddd32a694424">Scale</a> (const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;rpExpression, const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;rpScaleExpression)</td></tr>
<tr class="memdesc:acb29e543b2c1e5dc9477ddd32a694424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression which scales each component by a value from another expression.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#acb29e543b2c1e5dc9477ddd32a694424">More...</a><br /></td></tr>
<tr class="separator:acb29e543b2c1e5dc9477ddd32a694424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5e73afde2b3dcdb47395403800be80"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a5f5e73afde2b3dcdb47395403800be80">EntityMin</a> (const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;rpExpression)</td></tr>
<tr class="memdesc:a5f5e73afde2b3dcdb47395403800be80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression having min value from all the components for each entity.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a5f5e73afde2b3dcdb47395403800be80">More...</a><br /></td></tr>
<tr class="separator:a5f5e73afde2b3dcdb47395403800be80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb37a909ff74c1be569ada46e467097"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#aedb37a909ff74c1be569ada46e467097">EntityMax</a> (const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;rpExpression)</td></tr>
<tr class="memdesc:aedb37a909ff74c1be569ada46e467097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression having max value from all the components for each entity.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#aedb37a909ff74c1be569ada46e467097">More...</a><br /></td></tr>
<tr class="separator:aedb37a909ff74c1be569ada46e467097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9689412fc997a6dcc0e58165b35349"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#aac9689412fc997a6dcc0e58165b35349">EntitySum</a> (const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;rpExpression)</td></tr>
<tr class="memdesc:aac9689412fc997a6dcc0e58165b35349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression having sum of component values for each entity.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#aac9689412fc997a6dcc0e58165b35349">More...</a><br /></td></tr>
<tr class="separator:aac9689412fc997a6dcc0e58165b35349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Static scalar reduction operations</div></td></tr>
<tr class="memitem:ac230ee14d14e633a3b4266c9923af8c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#ac230ee14d14e633a3b4266c9923af8c7">Sum</a> (const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;rpExpression, const <a class="el" href="../../dc/d92/class_kratos_1_1_data_communicator.html">DataCommunicator</a> &amp;rDataCommunicator)</td></tr>
<tr class="memdesc:ac230ee14d14e633a3b4266c9923af8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of the expression assuming it is a flat vector [Shape is not considered].  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#ac230ee14d14e633a3b4266c9923af8c7">More...</a><br /></td></tr>
<tr class="separator:ac230ee14d14e633a3b4266c9923af8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7a12cfe75778edef162a7490676d52"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a3c7a12cfe75778edef162a7490676d52">NormInf</a> (const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;rpExpression, const <a class="el" href="../../dc/d92/class_kratos_1_1_data_communicator.html">DataCommunicator</a> &amp;rDataCommunicator)</td></tr>
<tr class="memdesc:a3c7a12cfe75778edef162a7490676d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the infinity norm of the expression assuming it is a flat vector [Shape is not considered].  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a3c7a12cfe75778edef162a7490676d52">More...</a><br /></td></tr>
<tr class="separator:a3c7a12cfe75778edef162a7490676d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38dcb295629d921a2174997c54a1a624"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a38dcb295629d921a2174997c54a1a624">NormL2</a> (const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;rpExpression, const <a class="el" href="../../dc/d92/class_kratos_1_1_data_communicator.html">DataCommunicator</a> &amp;rDataCommunicator)</td></tr>
<tr class="memdesc:a38dcb295629d921a2174997c54a1a624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the L2 norm of the expression assuming it is a flat vector [Shape is not considered].  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a38dcb295629d921a2174997c54a1a624">More...</a><br /></td></tr>
<tr class="separator:a38dcb295629d921a2174997c54a1a624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef9c55ae78c6c4726434ad824e6d6ba"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a1ef9c55ae78c6c4726434ad824e6d6ba">NormP</a> (const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;rpExpression, const <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a> P, const <a class="el" href="../../dc/d92/class_kratos_1_1_data_communicator.html">DataCommunicator</a> &amp;rDataCommunicator)</td></tr>
<tr class="memdesc:a1ef9c55ae78c6c4726434ad824e6d6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the P norm of the expression assuming it is a flat vector [Shape is not considered].  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a1ef9c55ae78c6c4726434ad824e6d6ba">More...</a><br /></td></tr>
<tr class="separator:a1ef9c55ae78c6c4726434ad824e6d6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6856da86641d10957a997b6a8bc0fae5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a6856da86641d10957a997b6a8bc0fae5">InnerProduct</a> (const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;rpExpression1, const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;rpExpression2, const <a class="el" href="../../dc/d92/class_kratos_1_1_data_communicator.html">DataCommunicator</a> &amp;rDataCommunicator)</td></tr>
<tr class="memdesc:a6856da86641d10957a997b6a8bc0fae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inner product between two expressions.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a6856da86641d10957a997b6a8bc0fae5">More...</a><br /></td></tr>
<tr class="separator:a6856da86641d10957a997b6a8bc0fae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Static Container expression operations</div></td></tr>
<tr class="memitem:a03e652ffdbade7ef4c9dcbe773ca9080"><td class="memTemplParams" colspan="2">template&lt;class TContainerType &gt; </td></tr>
<tr class="memitem:a03e652ffdbade7ef4c9dcbe773ca9080"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a03e652ffdbade7ef4c9dcbe773ca9080">Collapse</a> (const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;rContainerExpression)</td></tr>
<tr class="memdesc:a03e652ffdbade7ef4c9dcbe773ca9080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a container expression having Collapse evaluated on the given <em>rContainerExpression's</em> expression.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a03e652ffdbade7ef4c9dcbe773ca9080">More...</a><br /></td></tr>
<tr class="separator:a03e652ffdbade7ef4c9dcbe773ca9080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48f5092a46f0ed4528b25126313f317"><td class="memTemplParams" colspan="2">template&lt;class TContainerType &gt; </td></tr>
<tr class="memitem:ad48f5092a46f0ed4528b25126313f317"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#ad48f5092a46f0ed4528b25126313f317">Abs</a> (const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;rContainerExpression)</td></tr>
<tr class="memdesc:ad48f5092a46f0ed4528b25126313f317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a container expression having Abs evaluated on the given <em>rContainerExpression's</em> expression.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#ad48f5092a46f0ed4528b25126313f317">More...</a><br /></td></tr>
<tr class="separator:ad48f5092a46f0ed4528b25126313f317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdeae3b726f57f3a03f999232264810"><td class="memTemplParams" colspan="2">template&lt;class TContainerType &gt; </td></tr>
<tr class="memitem:aecdeae3b726f57f3a03f999232264810"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#aecdeae3b726f57f3a03f999232264810">Log</a> (const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;rContainerExpression)</td></tr>
<tr class="memdesc:aecdeae3b726f57f3a03f999232264810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a container expression having Log evaluated on the given <em>rContainerExpression's</em> expression.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#aecdeae3b726f57f3a03f999232264810">More...</a><br /></td></tr>
<tr class="separator:aecdeae3b726f57f3a03f999232264810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0600404feed4edf3289e35b2ace89cd6"><td class="memTemplParams" colspan="2">template&lt;class TContainerType &gt; </td></tr>
<tr class="memitem:a0600404feed4edf3289e35b2ace89cd6"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a0600404feed4edf3289e35b2ace89cd6">EntityMin</a> (const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;rContainerExpression)</td></tr>
<tr class="memdesc:a0600404feed4edf3289e35b2ace89cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a container expression having EntityMin evaluated on the given <em>rContainerExpression's</em> expression.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a0600404feed4edf3289e35b2ace89cd6">More...</a><br /></td></tr>
<tr class="separator:a0600404feed4edf3289e35b2ace89cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ada8a10bcc12e748a7360b55456911"><td class="memTemplParams" colspan="2">template&lt;class TContainerType &gt; </td></tr>
<tr class="memitem:a11ada8a10bcc12e748a7360b55456911"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a11ada8a10bcc12e748a7360b55456911">EntityMax</a> (const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;rContainerExpression)</td></tr>
<tr class="memdesc:a11ada8a10bcc12e748a7360b55456911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a container expression having EntityMax evaluated on the given <em>rContainerExpression's</em> expression.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a11ada8a10bcc12e748a7360b55456911">More...</a><br /></td></tr>
<tr class="separator:a11ada8a10bcc12e748a7360b55456911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17ecbdddf19be7be573b97377db9743"><td class="memTemplParams" colspan="2">template&lt;class TContainerType &gt; </td></tr>
<tr class="memitem:ae17ecbdddf19be7be573b97377db9743"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#ae17ecbdddf19be7be573b97377db9743">EntitySum</a> (const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;rContainerExpression)</td></tr>
<tr class="memdesc:ae17ecbdddf19be7be573b97377db9743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a container expression having EntitySum evaluated on the given <em>rContainerExpression's</em> expression.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#ae17ecbdddf19be7be573b97377db9743">More...</a><br /></td></tr>
<tr class="separator:ae17ecbdddf19be7be573b97377db9743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb8bed8e90df9ff452c74865125ffb1"><td class="memTemplParams" colspan="2">template&lt;class TContainerType &gt; </td></tr>
<tr class="memitem:afdb8bed8e90df9ff452c74865125ffb1"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#afdb8bed8e90df9ff452c74865125ffb1">Sum</a> (const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;rContainerExpression)</td></tr>
<tr class="memdesc:afdb8bed8e90df9ff452c74865125ffb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reduced value by evaluating Sum on the given <em>rContainerExpression's</em> expression.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#afdb8bed8e90df9ff452c74865125ffb1">More...</a><br /></td></tr>
<tr class="separator:afdb8bed8e90df9ff452c74865125ffb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259b254d32a0edf6e5825df7d8b91776"><td class="memTemplParams" colspan="2">template&lt;class TContainerType &gt; </td></tr>
<tr class="memitem:a259b254d32a0edf6e5825df7d8b91776"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a259b254d32a0edf6e5825df7d8b91776">NormInf</a> (const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;rContainerExpression)</td></tr>
<tr class="memdesc:a259b254d32a0edf6e5825df7d8b91776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reduced value by evaluating NormInf on the given <em>rContainerExpression's</em> expression.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a259b254d32a0edf6e5825df7d8b91776">More...</a><br /></td></tr>
<tr class="separator:a259b254d32a0edf6e5825df7d8b91776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b9989e4bfa413ccb890266bfc15106"><td class="memTemplParams" colspan="2">template&lt;class TContainerType &gt; </td></tr>
<tr class="memitem:ab9b9989e4bfa413ccb890266bfc15106"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#ab9b9989e4bfa413ccb890266bfc15106">NormL2</a> (const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;rContainerExpression)</td></tr>
<tr class="memdesc:ab9b9989e4bfa413ccb890266bfc15106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reduced value by evaluating NormL2 on the given <em>rContainerExpression's</em> expression.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#ab9b9989e4bfa413ccb890266bfc15106">More...</a><br /></td></tr>
<tr class="separator:ab9b9989e4bfa413ccb890266bfc15106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7ec40be04c402341d0743e8a1e34ae"><td class="memTemplParams" colspan="2">template&lt;class TContainerType &gt; </td></tr>
<tr class="memitem:a5f7ec40be04c402341d0743e8a1e34ae"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a5f7ec40be04c402341d0743e8a1e34ae">Pow</a> (const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;rContainerExpression, const <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a> Value)</td></tr>
<tr class="memdesc:a5f7ec40be04c402341d0743e8a1e34ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a container expression by evaluating <a class="el" href="../../dd/de5/struct_kratos_1_1_pow.html">Pow</a> on the given <em>rContainerExpression's</em> expression using <em>Value</em>.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a5f7ec40be04c402341d0743e8a1e34ae">More...</a><br /></td></tr>
<tr class="separator:a5f7ec40be04c402341d0743e8a1e34ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf7237d8da0f95f82fbe8f7d9456627"><td class="memTemplParams" colspan="2">template&lt;class TContainerType &gt; </td></tr>
<tr class="memitem:acbf7237d8da0f95f82fbe8f7d9456627"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#acbf7237d8da0f95f82fbe8f7d9456627">Pow</a> (const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;rContainerExpression1, const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;rContainerExpression2)</td></tr>
<tr class="memdesc:acbf7237d8da0f95f82fbe8f7d9456627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a container expression by evaluating <a class="el" href="../../dd/de5/struct_kratos_1_1_pow.html">Pow</a> on the given <em>rContainerExpression's</em> expression using <em>rContainerExpression2's</em> expression.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#acbf7237d8da0f95f82fbe8f7d9456627">More...</a><br /></td></tr>
<tr class="separator:acbf7237d8da0f95f82fbe8f7d9456627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa096300be9b346ce4ac4509b23aeb744"><td class="memTemplParams" colspan="2">template&lt;class TContainerType &gt; </td></tr>
<tr class="memitem:aa096300be9b346ce4ac4509b23aeb744"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#aa096300be9b346ce4ac4509b23aeb744">Scale</a> (const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;rContainerExpression, const <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a> Value)</td></tr>
<tr class="memdesc:aa096300be9b346ce4ac4509b23aeb744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a container expression by evaluating Scale on the given <em>rContainerExpression's</em> expression using <em>Value</em>.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#aa096300be9b346ce4ac4509b23aeb744">More...</a><br /></td></tr>
<tr class="separator:aa096300be9b346ce4ac4509b23aeb744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d628ff22446c1027acd29b0f69726c"><td class="memTemplParams" colspan="2">template&lt;class TContainerType &gt; </td></tr>
<tr class="memitem:a81d628ff22446c1027acd29b0f69726c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a81d628ff22446c1027acd29b0f69726c">Scale</a> (const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;rContainerExpression1, const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;rContainerExpression2)</td></tr>
<tr class="memdesc:a81d628ff22446c1027acd29b0f69726c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a container expression by evaluating Scale on the given <em>rContainerExpression's</em> expression using <em>rContainerExpression2's</em> expression.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a81d628ff22446c1027acd29b0f69726c">More...</a><br /></td></tr>
<tr class="separator:a81d628ff22446c1027acd29b0f69726c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e5d432b0b37cdd290be8a19c2646f0"><td class="memTemplParams" colspan="2">template&lt;class TContainerType &gt; </td></tr>
<tr class="memitem:a87e5d432b0b37cdd290be8a19c2646f0"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a87e5d432b0b37cdd290be8a19c2646f0">Slice</a> (const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;rContainerExpression, std::size_t Offset, std::size_t Stride)</td></tr>
<tr class="memdesc:a87e5d432b0b37cdd290be8a19c2646f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slicing given container expression's expression.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a87e5d432b0b37cdd290be8a19c2646f0">More...</a><br /></td></tr>
<tr class="separator:a87e5d432b0b37cdd290be8a19c2646f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab711af24f8d573f58a0b63c793801cff"><td class="memTemplParams" colspan="2">template&lt;class TContainerType , class TIterator &gt; </td></tr>
<tr class="memitem:ab711af24f8d573f58a0b63c793801cff"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#ab711af24f8d573f58a0b63c793801cff">Reshape</a> (const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;rContainerExpression, TIterator NewShapeBegin, TIterator NewShapeEnd)</td></tr>
<tr class="memdesc:ab711af24f8d573f58a0b63c793801cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape the data in the given container expression's expression.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#ab711af24f8d573f58a0b63c793801cff">More...</a><br /></td></tr>
<tr class="separator:ab711af24f8d573f58a0b63c793801cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0472399899d26839e1044b7bd23eb751"><td class="memTemplParams" colspan="2">template&lt;class TContainerType &gt; </td></tr>
<tr class="memitem:a0472399899d26839e1044b7bd23eb751"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a0472399899d26839e1044b7bd23eb751">Reshape</a> (const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;rContainerExpression, const std::vector&lt; <a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a3cf2546c42481c4106f3735e4b14b540">IndexType</a> &gt; &amp;rNewShape)</td></tr>
<tr class="memdesc:a0472399899d26839e1044b7bd23eb751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape the data in the given container expression's expression.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a0472399899d26839e1044b7bd23eb751">More...</a><br /></td></tr>
<tr class="separator:a0472399899d26839e1044b7bd23eb751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0ca36fb7885fd377d02dd5cbe0e087"><td class="memTemplParams" colspan="2">template&lt;class TContainerType &gt; </td></tr>
<tr class="memitem:a3c0ca36fb7885fd377d02dd5cbe0e087"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a3c0ca36fb7885fd377d02dd5cbe0e087">Comb</a> (const std::vector&lt; typename <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt;::Pointer &gt; &amp;rpContainerExpressions)</td></tr>
<tr class="memdesc:a3c0ca36fb7885fd377d02dd5cbe0e087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the components of a set of container expressions' expression to the current container expression's expression components.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a3c0ca36fb7885fd377d02dd5cbe0e087">More...</a><br /></td></tr>
<tr class="separator:a3c0ca36fb7885fd377d02dd5cbe0e087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44312b8bce3251d0a4c9c5895a3b75bb"><td class="memTemplParams" colspan="2">template&lt;class TContainerType &gt; </td></tr>
<tr class="memitem:a44312b8bce3251d0a4c9c5895a3b75bb"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a44312b8bce3251d0a4c9c5895a3b75bb">NormP</a> (const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;rContainerExpression, const <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a> P)</td></tr>
<tr class="memdesc:a44312b8bce3251d0a4c9c5895a3b75bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the P norm of the given container expression's expression.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a44312b8bce3251d0a4c9c5895a3b75bb">More...</a><br /></td></tr>
<tr class="separator:a44312b8bce3251d0a4c9c5895a3b75bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4649d8c53d62c3caa32e4b830faf1b17"><td class="memTemplParams" colspan="2">template&lt;class TContainerType &gt; </td></tr>
<tr class="memitem:a4649d8c53d62c3caa32e4b830faf1b17"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a4649d8c53d62c3caa32e4b830faf1b17">InnerProduct</a> (const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;rContainerExpression1, const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;rContainerExpression2)</td></tr>
<tr class="memdesc:a4649d8c53d62c3caa32e4b830faf1b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes inner product between two container expressions's expressions.  <a href="../../d9/d21/class_kratos_1_1_expression_utils.html#a4649d8c53d62c3caa32e4b830faf1b17">More...</a><br /></td></tr>
<tr class="separator:a4649d8c53d62c3caa32e4b830faf1b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3cf2546c42481c4106f3735e4b14b540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf2546c42481c4106f3735e4b14b540">&#9670;&nbsp;</a></span>IndexType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a3cf2546c42481c4106f3735e4b14b540">Kratos::ExpressionUtils::IndexType</a> =  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad48f5092a46f0ed4528b25126313f317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48f5092a46f0ed4528b25126313f317">&#9670;&nbsp;</a></span>Abs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt;TContainerType&gt; Kratos::ExpressionUtils::Abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rContainerExpression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a container expression having Abs evaluated on the given <em>rContainerExpression's</em> expression. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a3f49b1ae5b5b8fb7db5448ad5fbf3f63" title="Returns an expression which represents the component wise absolute value of the given expression.">Abs</a> . </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TContainerType</td><td>Container type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContainerExpression&lt;TContainerType&gt;</td><td>Container expression to apply Abs . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ContainerExpression&lt;TContainerType&gt; Resulting container expression. </dd></dl>

</div>
</div>
<a id="a3f49b1ae5b5b8fb7db5448ad5fbf3f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f49b1ae5b5b8fb7db5448ad5fbf3f63">&#9670;&nbsp;</a></span>Abs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> Kratos::ExpressionUtils::Abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>rpExpression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an expression which represents the component wise absolute value of the given expression. </p>
<p>If the input <em>rpExpression</em> is \(\underline{\mathbb{u}}\), where \(u_{ij}\) represents \(j^{th}\) component of the flattened entity data for \(i^{th}\) entity , then the returned expression \(\left|\underline{\mathbb{u}}\right|\)</p>
<p class="formulaDsp">
\[ \left|\underline{\mathbb{u}}\right| = \left|u_{ij}\right| \]
</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html" title="Base class or all the expression types.">Expression</a> which computes component wise absolute value. </dd></dl>

</div>
</div>
<a id="a03e652ffdbade7ef4c9dcbe773ca9080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e652ffdbade7ef4c9dcbe773ca9080">&#9670;&nbsp;</a></span>Collapse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt;TContainerType&gt; Kratos::ExpressionUtils::Collapse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rContainerExpression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a container expression having Collapse evaluated on the given <em>rContainerExpression's</em> expression. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a6d558dae353813bef7818428f57a967b" title="Collapse the lazy expression tree structure in the expression.">Collapse</a> . </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TContainerType</td><td>Container type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContainerExpression&lt;TContainerType&gt;</td><td>Container expression to apply Collapse . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ContainerExpression&lt;TContainerType&gt; Resulting container expression. </dd></dl>

</div>
</div>
<a id="a6d558dae353813bef7818428f57a967b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d558dae353813bef7818428f57a967b">&#9670;&nbsp;</a></span>Collapse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> Kratos::ExpressionUtils::Collapse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>rpExpression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collapse the lazy expression tree structure in the expression. </p>
<p>This method returns an expression which is created by collapsing the tree structure in the rpExpression. This is useful in cases, when the expression tree becomes large and memory intensive, so the tree can be collapsed to a one leaf expression releasing memory. This has to evaluate the expression for each entity, hence this is a computationly expensive task.</p>
<p>This method is optimized and compatible with OpenMP and MPI.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rpExpression</td><td><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html" title="Base class or all the expression types.">Expression</a> to collapse the lazy expression tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> Collapsed expression. </dd></dl>

</div>
</div>
<a id="a635878f798e10e7cb5abd5fe93dae638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635878f798e10e7cb5abd5fe93dae638">&#9670;&nbsp;</a></span>Comb() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> Kratos::ExpressionUtils::Comb </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rpExpressions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append the components of a set of expressions to the current expression's components. </p>
<p>This method combines a set of expressions into the current one as explained in the following example: All provided expressions in <em>rpExpressions</em> must have the same number of items.</p>
<p>For example, let <em>rpExpressions</em> contain the following expressions: </p><div class="fragment"><div class="line">rpExpressions[0] = <a class="code" href="../../d0/df1/namespacemesh__to__mdpa__converter.html#ab9fda76a6237087d0714e405167d0868">data</a>{1, 2, 3} with 3 <a class="code" href="../../da/d07/namespace_kratos_1_1_python.html#a4849e62be252722af18344658acee2ee">items</a>, and item shape = []</div>
<div class="line">                  -  -  -</div>
<div class="ttc" id="anamespace_kratos_1_1_python_html_a4849e62be252722af18344658acee2ee"><div class="ttname"><a href="../../da/d07/namespace_kratos_1_1_python.html#a4849e62be252722af18344658acee2ee">Kratos::Python::items</a></div><div class="ttdeci">pybind11::list items(Parameters const &amp;self)</div><div class="ttdef"><b>Definition:</b> add_kratos_parameters_to_python.cpp:24</div></div>
<div class="ttc" id="anamespacemesh__to__mdpa__converter_html_ab9fda76a6237087d0714e405167d0868"><div class="ttname"><a href="../../d0/df1/namespacemesh__to__mdpa__converter.html#ab9fda76a6237087d0714e405167d0868">mesh_to_mdpa_converter.data</a></div><div class="ttdeci">data</div><div class="ttdef"><b>Definition:</b> mesh_to_mdpa_converter.py:59</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line">rpExpressions[1] = <a class="code" href="../../d0/df1/namespacemesh__to__mdpa__converter.html#ab9fda76a6237087d0714e405167d0868">data</a>{4, 5, 6, 7, 8, 9} with 3 <a class="code" href="../../da/d07/namespace_kratos_1_1_python.html#a4849e62be252722af18344658acee2ee">items</a>, and item shape = [2]</div>
<div class="line">                  ----  ----  ----</div>
</div><!-- fragment --><p>The resulting expression has item shape [3] with 3 items: </p><div class="fragment"><div class="line">output_data = [1, 4, 5, 2, 6, 7, 3, 8, 9]</div>
<div class="line">               -------  -------  -------</div>
</div><!-- fragment --><p>This creates a lazy expression, hence it has a constant cost complexity irrespective of the data size (The expression won't be evaluated unless <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#a18050a612bbc9adf870378bd74bccb66">Expression::Evaluate</a> is called).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rpExpressions</td><td>Expressions to comb components from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c0ca36fb7885fd377d02dd5cbe0e087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0ca36fb7885fd377d02dd5cbe0e087">&#9670;&nbsp;</a></span>Comb() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt;TContainerType&gt; Kratos::ExpressionUtils::Comb </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; typename <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt;::Pointer &gt; &amp;&#160;</td>
          <td class="paramname"><em>rpContainerExpressions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append the components of a set of container expressions' expression to the current container expression's expression components. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a635878f798e10e7cb5abd5fe93dae638" title="Append the components of a set of expressions to the current expression&#39;s components.">Comb</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the <em>rpContainerExpressions</em> is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TContainerType</td><td>Type of the data container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rpContainerExpressions</td><td>List of container expressions to comb through. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ContainerExpression&lt;TContainerType&gt; Resulting container expression. </dd></dl>

</div>
</div>
<a id="ab80b490e5967228062b8b86a70d03293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80b490e5967228062b8b86a70d03293">&#9670;&nbsp;</a></span>Comb() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> Kratos::ExpressionUtils::Comb </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>ExpressionBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>ExpressionEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append the components of a set of expressions to the current expression's components. </p>
<p>This method combines a set of expressions into the current one as explained in the following example: All provided expressions in the { <em>ExpressionBegin</em>, <em>ExpressionEnd</em> } range must have the same number of items.</p>
<p>For example, let the { <em>ExpressionBegin</em>, <em>ExpressionEnd</em> } range contain the following expressions: </p><div class="fragment"><div class="line">ExpressionBegin[0] = <a class="code" href="../../d0/df1/namespacemesh__to__mdpa__converter.html#ab9fda76a6237087d0714e405167d0868">data</a>{1, 2, 3} with 3 <a class="code" href="../../da/d07/namespace_kratos_1_1_python.html#a4849e62be252722af18344658acee2ee">items</a>, and item shape = []</div>
<div class="line">                  -  -  -</div>
</div><!-- fragment --> <div class="fragment"><div class="line">ExpressionBegin[1] = <a class="code" href="../../d0/df1/namespacemesh__to__mdpa__converter.html#ab9fda76a6237087d0714e405167d0868">data</a>{4, 5, 6, 7, 8, 9} with 3 <a class="code" href="../../da/d07/namespace_kratos_1_1_python.html#a4849e62be252722af18344658acee2ee">items</a>, and item shape = [2]</div>
<div class="line">                  ----  ----  ----</div>
</div><!-- fragment --><p>The resulting expression has item shape [3] with 3 items: </p><div class="fragment"><div class="line">output_data = [1, 4, 5, 2, 6, 7, 3, 8, 9]</div>
<div class="line">               -------  -------  -------</div>
</div><!-- fragment --><p>This creates a lazy expression, hence it has a constant cost complexity irrespective of the data size (The expression won't be evaluated unless <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#a18050a612bbc9adf870378bd74bccb66">Expression::Evaluate</a> is called).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ExpressionBegin</td><td>Iterator pointing to the first expression to comb components from. </td></tr>
    <tr><td class="paramname">ExpressionEnd</td><td>Iterator past the last expression to comb components from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11ada8a10bcc12e748a7360b55456911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ada8a10bcc12e748a7360b55456911">&#9670;&nbsp;</a></span>EntityMax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt;TContainerType&gt; Kratos::ExpressionUtils::EntityMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rContainerExpression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a container expression having EntityMax evaluated on the given <em>rContainerExpression's</em> expression. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#aedb37a909ff74c1be569ada46e467097" title="Returns an expression having max value from all the components for each entity.">EntityMax</a> . </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TContainerType</td><td>Container type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContainerExpression&lt;TContainerType&gt;</td><td>Container expression to apply EntityMax . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ContainerExpression&lt;TContainerType&gt; Resulting container expression. </dd></dl>

</div>
</div>
<a id="aedb37a909ff74c1be569ada46e467097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb37a909ff74c1be569ada46e467097">&#9670;&nbsp;</a></span>EntityMax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> Kratos::ExpressionUtils::EntityMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>rpExpression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an expression having max value from all the components for each entity. </p>
<p>If the input <em>rpExpression</em> is \(\underline{\mathbb{u}}\), where \(u_{ij}\) represents \(j^{th}\) component of the flattened (having \(N\) total components) entity data for \(i^{th}\) entity , Following illustrates the returned expression which is always a scalar expression having \(m_i\) representing the \(i^{th}\) entity data.</p>
<p class="formulaDsp">
\[ EntityMax(\underline{\mathbb{u}}) = m_{i} \]
</p>
<p>Where, </p><p class="formulaDsp">
\[ m_{i} = \max_{j\in \left[0, N\right)} u_{ij} \]
</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> Scalar expression having the maximum of all components for each entity in the input expression. </dd></dl>

</div>
</div>
<a id="a0600404feed4edf3289e35b2ace89cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0600404feed4edf3289e35b2ace89cd6">&#9670;&nbsp;</a></span>EntityMin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt;TContainerType&gt; Kratos::ExpressionUtils::EntityMin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rContainerExpression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a container expression having EntityMin evaluated on the given <em>rContainerExpression's</em> expression. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a5f5e73afde2b3dcdb47395403800be80" title="Returns an expression having min value from all the components for each entity.">EntityMin</a> . </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TContainerType</td><td>Container type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContainerExpression&lt;TContainerType&gt;</td><td>Container expression to apply EntityMin . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ContainerExpression&lt;TContainerType&gt; Resulting container expression. </dd></dl>

</div>
</div>
<a id="a5f5e73afde2b3dcdb47395403800be80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5e73afde2b3dcdb47395403800be80">&#9670;&nbsp;</a></span>EntityMin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> Kratos::ExpressionUtils::EntityMin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>rpExpression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an expression having min value from all the components for each entity. </p>
<p>If the input <em>rpExpression</em> is \(\underline{\mathbb{u}}\), where \(u_{ij}\) represents \(j^{th}\) component of the flattened (having \(N\) total components) entity data for \(i^{th}\) entity , Following illustrates the returned expression which is always a scalar expression having \(m_i\) representing the \(i^{th}\) entity data.</p>
<p class="formulaDsp">
\[ EntityMin(\underline{\mathbb{u}}) = m_{i} \]
</p>
<p>Where, </p><p class="formulaDsp">
\[ m_{i} = \min_{j\in \left[0, N\right)} u_{ij} \]
</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> Scalar expression having the minimum of all components for each entity in the input expression. </dd></dl>

</div>
</div>
<a id="ae17ecbdddf19be7be573b97377db9743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17ecbdddf19be7be573b97377db9743">&#9670;&nbsp;</a></span>EntitySum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt;TContainerType&gt; Kratos::ExpressionUtils::EntitySum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rContainerExpression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a container expression having EntitySum evaluated on the given <em>rContainerExpression's</em> expression. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#aac9689412fc997a6dcc0e58165b35349" title="Returns an expression having sum of component values for each entity.">EntitySum</a> . </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TContainerType</td><td>Container type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContainerExpression&lt;TContainerType&gt;</td><td>Container expression to apply EntitySum . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ContainerExpression&lt;TContainerType&gt; Resulting container expression. </dd></dl>

</div>
</div>
<a id="aac9689412fc997a6dcc0e58165b35349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9689412fc997a6dcc0e58165b35349">&#9670;&nbsp;</a></span>EntitySum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> Kratos::ExpressionUtils::EntitySum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>rpExpression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an expression having sum of component values for each entity. </p>
<p>If the input <em>rpExpression</em> is \(\underline{\mathbb{u}}\), where \(u_{ij}\) represents \(j^{th}\) component of the flattened (having \(N\) total components) entity data for \(i^{th}\) entity , Following illustrates the returned expression which is always a scalar expression having \(m_i\) representing the \(i^{th}\) entity data.</p>
<p class="formulaDsp">
\[ EntitySum(\underline{\mathbb{u}}) = m_{i} \]
</p>
<p>Where, </p><p class="formulaDsp">
\[ m_{i} = \sum_{j\in \left[0, N\right)} u_{ij} \]
</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> Scalar expression having the sum of all components for each entity in the input expression. </dd></dl>

</div>
</div>
<a id="a4649d8c53d62c3caa32e4b830faf1b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4649d8c53d62c3caa32e4b830faf1b17">&#9670;&nbsp;</a></span>InnerProduct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a> Kratos::ExpressionUtils::InnerProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rContainerExpression1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rContainerExpression2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes inner product between two container expressions's expressions. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a6856da86641d10957a997b6a8bc0fae5" title="Returns the inner product between two expressions.">InnerProduct</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TContainerType</td><td>Container type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rContainerExpression1</td><td>Container expression 1. </td></tr>
    <tr><td class="paramname">rContainerExpression2</td><td>Container expression 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double Inner product. </dd></dl>

</div>
</div>
<a id="a6856da86641d10957a997b6a8bc0fae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6856da86641d10957a997b6a8bc0fae5">&#9670;&nbsp;</a></span>InnerProduct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a> Kratos::ExpressionUtils::InnerProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>rpExpression1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>rpExpression2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d92/class_kratos_1_1_data_communicator.html">DataCommunicator</a> &amp;&#160;</td>
          <td class="paramname"><em>rDataCommunicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the inner product between two expressions. </p>
<p>If the input <em>rpExpression1</em> is \(\underline{\mathbb{u}}\), where \(u_{ij}\) represents \(j^{th}\) component of the flattened (having \(N\) total components) entity data for \(i^{th}\) entity (having \(M\) entities) and the input <em>rpExpression2</em> is \(\underline{\mathbb{v}}\), where \(v_{ij}\) represents \(j^{th}\) component of the flattened (having \(N\) total components) entity data for \(i^{th}\) entity (having \(M\) entities), Following illustrates the returned value where the entity data is flattened. This does not consider shapes of the expressions. They should have same size of flattened vectors.</p>
<p class="formulaDsp">
\[ InnerProduct(\underline{\mathbb{u}}, \underline{\mathbb{v}}) = \sum_{i\in \left[0, M\right)} \sum_{j\in \left[0, N\right)} u_{ij} \times v_{ij} \]
</p>
<p>This method is compatible with shared and distributed memory parallelized runs.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the flattend size mismatch. </td></tr>
    <tr><td class="paramname">If</td><td>the number of entities mismatch.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rpExpression1</td><td>Expression1. </td></tr>
    <tr><td class="paramname">rpExpression1</td><td>Expression2. </td></tr>
    <tr><td class="paramname">rDataCommunicator</td><td>Data communicator for MPI communication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double The inner product of <em>rpExpression1</em> and <em>rpExpression2</em> </dd></dl>

</div>
</div>
<a id="aecdeae3b726f57f3a03f999232264810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdeae3b726f57f3a03f999232264810">&#9670;&nbsp;</a></span>Log() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt;TContainerType&gt; Kratos::ExpressionUtils::Log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rContainerExpression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a container expression having Log evaluated on the given <em>rContainerExpression's</em> expression. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a7f4b023ae06e54ef0ed74b2543e88f73" title="Returns an expression which represents the component wise logarithmic value of the given expression.">Log</a> . </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TContainerType</td><td>Container type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContainerExpression&lt;TContainerType&gt;</td><td>Container expression to apply Log . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ContainerExpression&lt;TContainerType&gt; Resulting container expression. </dd></dl>

</div>
</div>
<a id="a7f4b023ae06e54ef0ed74b2543e88f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4b023ae06e54ef0ed74b2543e88f73">&#9670;&nbsp;</a></span>Log() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> Kratos::ExpressionUtils::Log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>rpExpression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an expression which represents the component wise logarithmic value of the given expression. </p>
<p>If the input <em>rpExpression</em> is \(\underline{\mathbb{u}}\), where \(u_{ij}\) represents \(j^{th}\) component of the flattened entity data for \(i^{th}\) entity , then the returned expression \(\left|\underline{\mathbb{u}}\right|\)</p>
<p class="formulaDsp">
\[ Log\left(\underline{\mathbb{u}}\right) = log\left(u_{ij}\right) \]
</p>
<dl class="section warning"><dt>Warning</dt><dd>Returns nan if the given $ \(u_{ij}\f &lt; 0.0$ @warning Returns inf if the given $\)@_fakenlu_{ij}\f = 0.0$</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html" title="Base class or all the expression types.">Expression</a> which computes component wise logarithmic value. </dd></dl>

</div>
</div>
<a id="a259b254d32a0edf6e5825df7d8b91776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259b254d32a0edf6e5825df7d8b91776">&#9670;&nbsp;</a></span>NormInf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a> Kratos::ExpressionUtils::NormInf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rContainerExpression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reduced value by evaluating NormInf on the given <em>rContainerExpression's</em> expression. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a3c7a12cfe75778edef162a7490676d52" title="Returns the infinity norm of the expression assuming it is a flat vector [Shape is not considered].">NormInf</a> . </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TContainerType</td><td>Container type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContainerExpression&lt;TContainerType&gt;</td><td>Container expression to apply NormInf . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double Resulting scalar value after evaluating NormInf on <em>rContainerExpression</em>. </dd></dl>

</div>
</div>
<a id="a3c7a12cfe75778edef162a7490676d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7a12cfe75778edef162a7490676d52">&#9670;&nbsp;</a></span>NormInf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a> Kratos::ExpressionUtils::NormInf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>rpExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d92/class_kratos_1_1_data_communicator.html">DataCommunicator</a> &amp;&#160;</td>
          <td class="paramname"><em>rDataCommunicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the infinity norm of the expression assuming it is a flat vector [Shape is not considered]. </p>
<p>If the input <em>rpExpression</em> is \(\underline{\mathbb{u}}\), where \(u_{ij}\) represents \(j^{th}\) component of the flattened (having \(N\) total components) entity data for \(i^{th}\) entity (having \(M\) entities) , Following illustrates the returned value where the entity data is flattened.</p>
<p class="formulaDsp">
\[ NormInf(\underline{\mathbb{u}}) = \max_{(i,j)\in \left[0, M\right)\times \left[0, N\right)} \left|u_{ij}\right| \]
</p>
<p>This method is compatible with shared and distributed memory parallelized runs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rpExpression</td><td>Expressions to be summed. </td></tr>
    <tr><td class="paramname">rDataCommunicator</td><td>Data communicator for MPI communication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double The infinity norm of all the components in all the entities. </dd></dl>

</div>
</div>
<a id="ab9b9989e4bfa413ccb890266bfc15106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b9989e4bfa413ccb890266bfc15106">&#9670;&nbsp;</a></span>NormL2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a> Kratos::ExpressionUtils::NormL2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rContainerExpression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reduced value by evaluating NormL2 on the given <em>rContainerExpression's</em> expression. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a38dcb295629d921a2174997c54a1a624" title="Returns the L2 norm of the expression assuming it is a flat vector [Shape is not considered].">NormL2</a> . </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TContainerType</td><td>Container type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContainerExpression&lt;TContainerType&gt;</td><td>Container expression to apply NormL2 . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double Resulting scalar value after evaluating NormL2 on <em>rContainerExpression</em>. </dd></dl>

</div>
</div>
<a id="a38dcb295629d921a2174997c54a1a624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38dcb295629d921a2174997c54a1a624">&#9670;&nbsp;</a></span>NormL2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a> Kratos::ExpressionUtils::NormL2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>rpExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d92/class_kratos_1_1_data_communicator.html">DataCommunicator</a> &amp;&#160;</td>
          <td class="paramname"><em>rDataCommunicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the L2 norm of the expression assuming it is a flat vector [Shape is not considered]. </p>
<p>If the input <em>rpExpression</em> is \(\underline{\mathbb{u}}\), where \(u_{ij}\) represents \(j^{th}\) component of the flattened (having \(N\) total components) entity data for \(i^{th}\) entity (having \(M\) entities) , Following illustrates the returned value where the entity data is flattened.</p>
<p class="formulaDsp">
\[ NormL2(\underline{\mathbb{u}}) = \sqrt {\sum_{i\in \left[0, M\right)} \sum_{j\in \left[0, N\right)} u_{ij}^2} \]
</p>
<p>This method is compatible with shared and distributed memory parallelized runs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rpExpression</td><td>Expressions to be summed. </td></tr>
    <tr><td class="paramname">rDataCommunicator</td><td>Data communicator for MPI communication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double The L2 norm of all the components in all the entities. </dd></dl>

</div>
</div>
<a id="a44312b8bce3251d0a4c9c5895a3b75bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44312b8bce3251d0a4c9c5895a3b75bb">&#9670;&nbsp;</a></span>NormP() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a> Kratos::ExpressionUtils::NormP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rContainerExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the P norm of the given container expression's expression. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a1ef9c55ae78c6c4726434ad824e6d6ba" title="Returns the P norm of the expression assuming it is a flat vector [Shape is not considered].">NormP</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TContainerType</td><td>Container type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rContainerExpression</td><td>Input container expression. </td></tr>
    <tr><td class="paramname">P</td><td>Norm coefficient. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double Resulting p norm. </dd></dl>

</div>
</div>
<a id="a1ef9c55ae78c6c4726434ad824e6d6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef9c55ae78c6c4726434ad824e6d6ba">&#9670;&nbsp;</a></span>NormP() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a> Kratos::ExpressionUtils::NormP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>rpExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d92/class_kratos_1_1_data_communicator.html">DataCommunicator</a> &amp;&#160;</td>
          <td class="paramname"><em>rDataCommunicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the P norm of the expression assuming it is a flat vector [Shape is not considered]. </p>
<p>If the input <em>rpExpression</em> is \(\underline{\mathbb{u}}\), where \(u_{ij}\) represents \(j^{th}\) component of the flattened (having \(N\) total components) entity data for \(i^{th}\) entity (having \(M\) entities) , Following illustrates the returned value where the entity data is flattened.</p>
<p class="formulaDsp">
\[ NormP(\underline{\mathbb{u}}, P) = \left(\sum_{i\in \left[0, M\right)} \sum_{j\in \left[0, N\right)} \left|u_{ij}\right|^P\right)^{1/P} \]
</p>
<p>This method is compatible with shared and distributed memory parallelized runs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rpExpression</td><td>Expressions to be summed. </td></tr>
    <tr><td class="paramname">rDataCommunicator</td><td>Data communicator for MPI communication. </td></tr>
    <tr><td class="paramname">P</td><td>P norm coefficent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double The P norm of all the components in all the entities. </dd></dl>

</div>
</div>
<a id="a5f7ec40be04c402341d0743e8a1e34ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7ec40be04c402341d0743e8a1e34ae">&#9670;&nbsp;</a></span>Pow() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt;TContainerType&gt; Kratos::ExpressionUtils::Pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rContainerExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a container expression by evaluating <a class="el" href="../../dd/de5/struct_kratos_1_1_pow.html">Pow</a> on the given <em>rContainerExpression's</em> expression using <em>Value</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/de5/struct_kratos_1_1_pow.html">Pow</a> . </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TContainerType</td><td>Container type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContainerExpression&lt;TContainerType&gt;</td><td>Container expression to apply <a class="el" href="../../dd/de5/struct_kratos_1_1_pow.html">Pow</a> . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ContainerExpression&lt;TContainerType&gt; Resulting container expression. </dd></dl>

</div>
</div>
<a id="acbf7237d8da0f95f82fbe8f7d9456627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf7237d8da0f95f82fbe8f7d9456627">&#9670;&nbsp;</a></span>Pow() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt;TContainerType&gt; Kratos::ExpressionUtils::Pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rContainerExpression1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rContainerExpression2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a container expression by evaluating <a class="el" href="../../dd/de5/struct_kratos_1_1_pow.html">Pow</a> on the given <em>rContainerExpression's</em> expression using <em>rContainerExpression2's</em> expression. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/de5/struct_kratos_1_1_pow.html">Pow</a> . </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TContainerType</td><td>Container type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContainerExpression&lt;TContainerType&gt;</td><td>Container expression1 to apply <a class="el" href="../../dd/de5/struct_kratos_1_1_pow.html">Pow</a> .</td></tr>
    <tr><td class="paramname">ContainerExpression&lt;TContainerType&gt;</td><td>Container expression1 to apply <a class="el" href="../../dd/de5/struct_kratos_1_1_pow.html">Pow</a> . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ContainerExpression&lt;TContainerType&gt; Resulting container expression. </dd></dl>

</div>
</div>
<a id="a8afa09e7d1254da2aed0c0f2070675e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8afa09e7d1254da2aed0c0f2070675e2">&#9670;&nbsp;</a></span>Pow() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> Kratos::ExpressionUtils::Pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>rpExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>&#160;</td>
          <td class="paramname"><em>Power</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an expression which raises each component to the given power. </p>
<p>If the input <em>rpExpression</em> is \(\underline{\mathbb{u}}\), where \(u_{ij}\) represents \(j^{th}\) component of the flattened entity data for \(i^{th}\) entity , where P is specified by <em>Power</em>.</p>
<p class="formulaDsp">
\[ Pow(\underline{\mathbb{u}}, P) = u_{ij}^P \]
</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html" title="Base class or all the expression types.">Expression</a> which raises each component to specified power. </dd></dl>

</div>
</div>
<a id="a34d800c165fead9e2f7758305d9d269f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d800c165fead9e2f7758305d9d269f">&#9670;&nbsp;</a></span>Pow() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> Kratos::ExpressionUtils::Pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>rpExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>rpPowerpExpression</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an expression which raises each component to the given power from another expression. </p>
<p>If the input <em>rpExpression</em> is \(\underline{\mathbb{u}}\), where \(u_{ij}\) represents \(j^{th}\) component of the flattened entity data for \(i^{th}\) entity and the <em>rpPowerpExpression</em> is \(\underline{\mathbb{P}}\), where \(p_{ij}\) represents \(j^{th}\) component of the flattened entity data for \(i^{th}\) entity , then the returned expression can be illustrated as below.</p>
<p class="formulaDsp">
\[ Pow(\underline{\mathbb{u}}, \underline{\mathbb{p}}) = u_{ij}^{p_{ij}} \]
</p>
<p>If the given <em>rpPowerpExpression</em> is a scalar expression then the following will be returned</p>
<p class="formulaDsp">
\[ Pow(\underline{\mathbb{u}}, \underline{\mathbb{p}}) = u_{ij}^{p_{i}} \]
</p>
 <dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the number of entities mismatch between <em>rpExpression</em> and <em>rpPowerpExpression</em> </td></tr>
    <tr><td class="paramname">If</td><td>the shape of the <em>rpExpression</em> and <em>rpPowerpExpression</em> does not match or <em>rpPowerpExpression</em> is not representing a scalar expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html" title="Base class or all the expression types.">Expression</a> which raises each component to specified power given by the <em>rpPowerpExpression</em>. </dd></dl>

</div>
</div>
<a id="a0472399899d26839e1044b7bd23eb751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0472399899d26839e1044b7bd23eb751">&#9670;&nbsp;</a></span>Reshape() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt;TContainerType&gt; Kratos::ExpressionUtils::Reshape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rContainerExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a3cf2546c42481c4106f3735e4b14b540">IndexType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rNewShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reshape the data in the given container expression's expression. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#acff1546ae9efe2a5a3f7ee9b3d4b155f" title="Construct an expression with identical data but interpreted with a new item shape.">Reshape</a>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TContainerType</td><td>Container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rContainerExpression</td><td>Container expression to be sliced. </td></tr>
    <tr><td class="paramname">rNewShape</td><td>New shape. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ContainerExpression&lt;TContainerType&gt; Resulting reshaped container expression. </dd></dl>

</div>
</div>
<a id="ab711af24f8d573f58a0b63c793801cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab711af24f8d573f58a0b63c793801cff">&#9670;&nbsp;</a></span>Reshape() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType , class TIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt;TContainerType&gt; Kratos::ExpressionUtils::Reshape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rContainerExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>NewShapeBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>NewShapeEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reshape the data in the given container expression's expression. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#acff1546ae9efe2a5a3f7ee9b3d4b155f" title="Construct an expression with identical data but interpreted with a new item shape.">Reshape</a>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TContainerType</td><td>Container type </td></tr>
    <tr><td class="paramname">TIterator</td><td>Iterator type for the shape. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rContainerExpression</td><td>Container expression to be sliced. </td></tr>
    <tr><td class="paramname">NewShapeBegin</td><td>Starting iterator for the new shape. </td></tr>
    <tr><td class="paramname">NewShapeEnd</td><td>Ending iterator for the new shape </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ContainerExpression&lt;TContainerType&gt; Resulting reshaped container expression. </dd></dl>

</div>
</div>
<a id="a0a96c3e95187e535f9566716a14c904e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a96c3e95187e535f9566716a14c904e">&#9670;&nbsp;</a></span>Reshape() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> Kratos::ExpressionUtils::Reshape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>rpExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a3cf2546c42481c4106f3735e4b14b540">IndexType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rNewShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an expression with identical data but interpreted with a new item shape. </p>
<p>Reshaping is done on each entitiy's data array, and not on the flattened expression. For example:</p>
<p>Assume an <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html">Expression</a> of shape [2, 3] and 2 entities with following data in the flattened representation: </p><div class="fragment"><div class="line"><a class="code" href="../../d0/df1/namespacemesh__to__mdpa__converter.html#ab9fda76a6237087d0714e405167d0868">data</a> = [[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]</div>
<div class="line">        &lt;-------- 1 ---------&gt;  &lt;----------- 2 -----------&gt;</div>
</div><!-- fragment --><p> The underlying data of the reshaped expression is interpreted as follows: </p><div class="fragment"><div class="line">output_data = [[[1, 2], [3, 4], [5, 6]], [[7, 8], [9, 10], [11, 12]]]</div>
<div class="line"><a class="code" href="../../dc/d97/namespacegenerate__frictional__mortar__condition.html#a19e007dd94b56aad3700765033d81ef0">output</a> container shape = [3, 2]</div>
<div class="ttc" id="anamespacegenerate__frictional__mortar__condition_html_a19e007dd94b56aad3700765033d81ef0"><div class="ttname"><a href="../../dc/d97/namespacegenerate__frictional__mortar__condition.html#a19e007dd94b56aad3700765033d81ef0">generate_frictional_mortar_condition.output</a></div><div class="ttdeci">output</div><div class="ttdef"><b>Definition:</b> generate_frictional_mortar_condition.py:444</div></div>
</div><!-- fragment --><p> This creates a lazy expression, hence it has a constant cost complexity irrespective of the data size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rpExpression</td><td><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html" title="Base class or all the expression types.">Expression</a> to reshape. </td></tr>
    <tr><td class="paramname">rNewShape</td><td>New shape to used to reshape the existing expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acff1546ae9efe2a5a3f7ee9b3d4b155f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff1546ae9efe2a5a3f7ee9b3d4b155f">&#9670;&nbsp;</a></span>Reshape() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> Kratos::ExpressionUtils::Reshape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>rpExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>NewShapeBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>NewShapeEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an expression with identical data but interpreted with a new item shape. </p>
<p>Reshaping is done on each entitiy's data array, and not on the flattened expression. For example:</p>
<p>Assume an <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html">Expression</a> of shape [2, 3] and 2 entities with following data in the flattened representation: </p><div class="fragment"><div class="line"><a class="code" href="../../d0/df1/namespacemesh__to__mdpa__converter.html#ab9fda76a6237087d0714e405167d0868">data</a> = [[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]</div>
<div class="line">        &lt;-------- 1 ---------&gt;  &lt;----------- 2 -----------&gt;</div>
</div><!-- fragment --><p> The underlying data of the reshaped expression is interpreted as follows: </p><div class="fragment"><div class="line">output_data = [[[1, 2], [3, 4], [5, 6]], [[7, 8], [9, 10], [11, 12]]]</div>
<div class="line"><a class="code" href="../../dc/d97/namespacegenerate__frictional__mortar__condition.html#a19e007dd94b56aad3700765033d81ef0">output</a> container shape = [3, 2]</div>
</div><!-- fragment --><p> This creates a lazy expression, hence it has a constant cost complexity irrespective of the data size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rpExpression</td><td><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html" title="Base class or all the expression types.">Expression</a> to reshape. </td></tr>
    <tr><td class="paramname">NewShapeBegin</td><td>Iterator pointing to the first component of the new shape. </td></tr>
    <tr><td class="paramname">NewShapeEnd</td><td>Iterator past the last component of the new shape. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa096300be9b346ce4ac4509b23aeb744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa096300be9b346ce4ac4509b23aeb744">&#9670;&nbsp;</a></span>Scale() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt;TContainerType&gt; Kratos::ExpressionUtils::Scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rContainerExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a container expression by evaluating Scale on the given <em>rContainerExpression's</em> expression using <em>Value</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#aece580e1f1c217b209dbbb776e711fb9" title="Returns an expression which scales each component to the specified value.">Scale</a> . </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TContainerType</td><td>Container type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContainerExpression&lt;TContainerType&gt;</td><td>Container expression to apply Scale . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ContainerExpression&lt;TContainerType&gt; Resulting container expression. </dd></dl>

</div>
</div>
<a id="a81d628ff22446c1027acd29b0f69726c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d628ff22446c1027acd29b0f69726c">&#9670;&nbsp;</a></span>Scale() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt;TContainerType&gt; Kratos::ExpressionUtils::Scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rContainerExpression1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rContainerExpression2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a container expression by evaluating Scale on the given <em>rContainerExpression's</em> expression using <em>rContainerExpression2's</em> expression. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#aece580e1f1c217b209dbbb776e711fb9" title="Returns an expression which scales each component to the specified value.">Scale</a> . </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TContainerType</td><td>Container type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContainerExpression&lt;TContainerType&gt;</td><td>Container expression1 to apply Scale .</td></tr>
    <tr><td class="paramname">ContainerExpression&lt;TContainerType&gt;</td><td>Container expression1 to apply Scale . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ContainerExpression&lt;TContainerType&gt; Resulting container expression. </dd></dl>

</div>
</div>
<a id="aece580e1f1c217b209dbbb776e711fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece580e1f1c217b209dbbb776e711fb9">&#9670;&nbsp;</a></span>Scale() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> Kratos::ExpressionUtils::Scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>rpExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>&#160;</td>
          <td class="paramname"><em>Scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an expression which scales each component to the specified value. </p>
<p>If the input <em>rpExpression</em> is \(\underline{\mathbb{u}}\), where \(u_{ij}\) represents \(j^{th}\) component of the flattened entity data for \(i^{th}\) entity , where Scale is specified by <em>Scale</em>.</p>
<p class="formulaDsp">
\[ Scale(\underline{\mathbb{u}}, S) = u_{ij}^S \]
</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html" title="Base class or all the expression types.">Expression</a> which scales the given expression by specified scale <em>Scale</em> </dd></dl>

</div>
</div>
<a id="acb29e543b2c1e5dc9477ddd32a694424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb29e543b2c1e5dc9477ddd32a694424">&#9670;&nbsp;</a></span>Scale() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> Kratos::ExpressionUtils::Scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>rpExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>rpScaleExpression</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an expression which scales each component by a value from another expression. </p>
<p>If the input <em>rpExpression</em> is \(\underline{\mathbb{u}}\), where \(u_{ij}\) represents \(j^{th}\) component of the flattened entity data for \(i^{th}\) entity and the <em>rpScaleExpression</em> is \(\underline{\mathbb{s}}\), where \(s_{ij}\) represents \(j^{th}\) component of the flattened entity data for \(i^{th}\) entity , then the returned expression can be illustrated as below.</p>
<p class="formulaDsp">
\[ Scale(\underline{\mathbb{u}}, \underline{\mathbb{s}}) = u_{ij}^{s_{ij}} \]
</p>
<p>If the given <em>rpScaleExpression</em> is a scalar expression then the following will be returned</p>
<p class="formulaDsp">
\[ Scale(\underline{\mathbb{u}}, \underline{\mathbb{s}}) = u_{ij}^{s_{i}} \]
</p>
 <dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the number of entities mismatch between <em>rpExpression</em> and <em>rpScaleExpression</em> </td></tr>
    <tr><td class="paramname">If</td><td>the shape of the <em>rpExpression</em> and <em>rpScaleExpression</em> does not match or <em>rpScaleExpression</em> is not representing a scalar expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html" title="Base class or all the expression types.">Expression</a> which scales each component to specified value given by the <em>rpScaleExpression</em>. </dd></dl>

</div>
</div>
<a id="a87e5d432b0b37cdd290be8a19c2646f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e5d432b0b37cdd290be8a19c2646f0">&#9670;&nbsp;</a></span>Slice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt;TContainerType&gt; Kratos::ExpressionUtils::Slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rContainerExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>Stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Slicing given container expression's expression. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#a73c5356213a929b5273f89bae07c566d" title="Construct an expression containing a subset of the components of all items.">Slice</a>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TContainerType</td><td>Container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rContainerExpression</td><td>Container expression to be sliced. </td></tr>
    <tr><td class="paramname">Offset</td><td>Index of the first component to begin slicing at. </td></tr>
    <tr><td class="paramname">Stride</td><td>Number of components from the offset in the sliced item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ContainerExpression&lt;TContainerType&gt; Resulting sliced container expression. </dd></dl>

</div>
</div>
<a id="a73c5356213a929b5273f89bae07c566d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c5356213a929b5273f89bae07c566d">&#9670;&nbsp;</a></span>Slice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> Kratos::ExpressionUtils::Slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>rpExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>Stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an expression containing a subset of the components of all items. </p>
<p>Slicing is done on each entitiy's data array, and not on the flattened expression. For example:</p>
<p>Assume an <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html">Expression</a> of shape [5] and 2 entities with the following data in the flattened representation: </p><div class="fragment"><div class="line"><a class="code" href="../../d0/df1/namespacemesh__to__mdpa__converter.html#ab9fda76a6237087d0714e405167d0868">data</a> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</div>
<div class="line">        &lt;---- 1 ----&gt; &lt;----- 2 -----&gt;</div>
</div><!-- fragment --><p> Data for entity 1 is represented with &lt;&ndash;1--&gt;.</p>
<p>Let</p><div class="fragment"><div class="line">Offset = 1 @code and @code Stride = 3 </div>
</div><!-- fragment --><p>. The resulting sliced expression then represents the following data:</p>
<p>output_data = [2, 3, 4, 7, 8, 9] output container shape = [3] = equal to Stride.</p>
<p>Slicing will always create a one dimensional array even if the input expression is multidimensional. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#acff1546ae9efe2a5a3f7ee9b3d4b155f" title="Construct an expression with identical data but interpreted with a new item shape.">Reshape</a> to reshape the one dimensional array to the desired shape if required.</dd></dl>
<p>This creates a lazy expression, hence it has a constant cost complexity irrespective of the data size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Offset</td><td>Index of the first component to begin slicing at. </td></tr>
    <tr><td class="paramname">Stride</td><td>Number of components from the offset in the sliced item. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdb8bed8e90df9ff452c74865125ffb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb8bed8e90df9ff452c74865125ffb1">&#9670;&nbsp;</a></span>Sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a> Kratos::ExpressionUtils::Sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d11/class_kratos_1_1_container_expression.html">ContainerExpression</a>&lt; TContainerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rContainerExpression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reduced value by evaluating Sum on the given <em>rContainerExpression's</em> expression. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d21/class_kratos_1_1_expression_utils.html#ac230ee14d14e633a3b4266c9923af8c7" title="Returns the sum of the expression assuming it is a flat vector [Shape is not considered].">Sum</a> . </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TContainerType</td><td>Container type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContainerExpression&lt;TContainerType&gt;</td><td>Container expression to apply Sum . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double Resulting scalar value after evaluating Sum on <em>rContainerExpression</em>. </dd></dl>

</div>
</div>
<a id="ac230ee14d14e633a3b4266c9923af8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac230ee14d14e633a3b4266c9923af8c7">&#9670;&nbsp;</a></span>Sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a> Kratos::ExpressionUtils::Sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d91/class_kratos_1_1_expression.html#ae44dd3550f3fe6eba06defd226a402db">Expression::ConstPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>rpExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d92/class_kratos_1_1_data_communicator.html">DataCommunicator</a> &amp;&#160;</td>
          <td class="paramname"><em>rDataCommunicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sum of the expression assuming it is a flat vector [Shape is not considered]. </p>
<p>If the input <em>rpExpression</em> is \(\underline{\mathbb{u}}\), where \(u_{ij}\) represents \(j^{th}\) component of the flattened (having \(N\) total components) entity data for \(i^{th}\) entity (having \(M\) entities) , Following illustrates the returned value where the entity data is flattened.</p>
<p class="formulaDsp">
\[ Sum(\underline{\mathbb{u}}) = \sum_{i\in \left[0, M\right)} \sum_{j\in \left[0, N\right)} u_{ij} \]
</p>
<p>This method is compatible with shared and distributed memory parallelized runs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rpExpression</td><td>Expressions to be summed. </td></tr>
    <tr><td class="paramname">rDataCommunicator</td><td>Data communicator for MPI communication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double The sum of all the components in all the entities. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/Documentation/Documentation/master/kratos/expression/<a class="el" href="../../d5/da4/expression__utils_8h_source.html">expression_utils.h</a></li>
<li>/home/runner/work/Documentation/Documentation/master/kratos/expression/<a class="el" href="../../da/d1f/expression__utils_8cpp.html">expression_utils.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 4 2024 03:42:52 for KratosMultiphysics by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
