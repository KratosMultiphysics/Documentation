<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KratosMultiphysics: Mapping Application</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../kratos_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">KratosMultiphysics
   </div>
   <div id="projectbrief">KRATOS Multiphysics (Kratos) is a framework for building parallel, multi-disciplinary simulation software, aiming at modularity, extensibility, and high performance. Kratos is written in C++, and counts with an extensive Python interface.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Mapping Application </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Mapping Application contains the core developments in mapping data between non matching grids. It works both in shared and distributed (<b>MPI</b>) memory environments as well as in 1D, 2D and 3D domains.</p>
<h2>Overview</h2>
<ul>
<li><a href="../../#list-of-features">List of features</a></li>
<li><a href="../../#dependencies">Dependencies</a></li>
<li><a href="../../#Mapping-in-CoSimulation">Mapping in CoSimulation</a></li>
<li><a href="../../#basic-usage">Basic Usage</a></li>
<li><a href="../../#advanced-usage">Advanced Usage</a></li>
<li><a href="../../#available-mappers">Available Mappers</a></li>
<li><a href="../../#when-to-use-which-mapper">When to use which Mapper?</a></li>
<li><a href="../../#using-the-mapper-for-modelparts-that-are-not-part-of-all-ranks">Using the Mapper for ModelParts that are not part of all ranks</a></li>
<li><a href="../../#miscellaneous-functionalities">Miscellaneous functionalities</a></li>
<li><a href="../../#faq">FAQ</a></li>
</ul>
<h2>List of features</h2>
<ul>
<li>Parallelism:<ul>
<li>Serial (no parallelism)</li>
<li>Shared memory (OpenMP)</li>
<li>Distributed memory (MPI)</li>
</ul>
</li>
<li>Domain sizes: 1D / 2D / 3D</li>
<li>Matching and non matching grids</li>
<li>Different mapping technologies (see <a href="../../#available-mappers">here</a>):<ul>
<li>Nearest Neighbor</li>
<li>Nearest Element</li>
<li>Barycentric</li>
</ul>
</li>
<li>Metamappers<ul>
<li>3D/2D metamapper (metamapper which obtains the solution for the 3D destination model part from the original 2D solution)</li>
</ul>
</li>
<li>Mapping operations (see <a href="../../#customizing-the-behavior-of-the-mapping-with-flags">here</a>)</li>
</ul>
<h2>Dependencies</h2>
<p>The serial / shared memory parallel compilation of the Mapping Application doesn't have any dependencies (except the <code>KratosCore</code>).</p>
<p>The distributed compilation of the Mapping Application depends on the <a href="https://trilinos.github.io/">Trilinos library</a>. Also most of the MPI-solvers in <a class="el" href="../../db/d66/namespace_kratos.html" title="REF: G. R. Cowper, GAUSSIAN QUADRATURE FORMULAS FOR TRIANGLES.">Kratos</a> depend on Trilinos, see the <a href="../../../TrilinosApplication">Trilinos Application</a>.</p>
<h2>Mapping in CoSimulation</h2>
<p>The Mapping Application can be used for mapping within the <a href="../../../CoSimulationApplication">CoSimulation Application</a>. This can be done by using the <a href="../../../CoSimulationApplication/python_scripts/data_transfer_operators/kratos_mapping.py">KratosMappingDataTransferOperator</a>.</p>
<h2>Basic Usage</h2>
<p>The <em>Mapper</em> maps nodal data from one <em>ModelPart</em> to another. This means that the input for the <em>Mapper</em> is two <em>ModelParts</em>, the <b>Origin</b> and the <b>Destination</b>. Furthermore settings in the form of <em><a class="el" href="../../dd/da0/class_kratos_1_1_parameters.html" title="This class provides to Kratos a data structure for I/O based on the standard of JSON.">Kratos::Parameters</a></em> are passed.</p>
<p>The <em>Mapper</em> is constructed using the <em>MapperFactory</em>. See the following basic example.</p>
<div class="fragment"><div class="line"><span class="comment"># import the Kratos Core</span></div>
<div class="line"><span class="keyword">import</span> KratosMultiphysics <span class="keyword">as</span> KM</div>
<div class="line"><span class="comment"># import the MappingApplication to load the mappers</span></div>
<div class="line"><span class="keyword">import</span> KratosMultiphysics.MappingApplication <span class="keyword">as</span> KratosMapping</div>
<div class="line"> </div>
<div class="line"><span class="comment"># create ModelParts</span></div>
<div class="line"><span class="comment"># ...</span></div>
<div class="line"> </div>
<div class="line">mapper_settings = KM.Parameters(<span class="stringliteral">&quot;&quot;&quot;{</span></div>
<div class="line"><span class="stringliteral">    &quot;mapper_type&quot;: &quot;nearest_neighbor&quot;,</span></div>
<div class="line"><span class="stringliteral">    &quot;echo_level&quot; : 0</span></div>
<div class="line"><span class="stringliteral">}&quot;&quot;&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># creating a mapper for shared memory</span></div>
<div class="line">mapper = KM.MapperFactory.CreateMapper(</div>
<div class="line">    model_part_origin,</div>
<div class="line">    model_part_destination,</div>
<div class="line">    mapper_settings</div>
<div class="line">)</div>
</div><!-- fragment --><p>For constructing an <em>MPI-Mapper</em> use the <code><a class="el" href="../../d2/dec/namespace_m_p_i_extension.html">MPIExtension</a></code> instead:</p>
<div class="fragment"><div class="line"><span class="comment"># creating a mapper for distributed memory</span></div>
<div class="line"><span class="keyword">from</span> KratosMultiphysics.MappingApplication <span class="keyword">import</span> MPIExtension <span class="keyword">as</span> MappingMPIExtension</div>
<div class="line">mpi_mapper = MappingMPIExtension.MPIMapperFactory.CreateMapper(</div>
<div class="line">    model_part_origin,</div>
<div class="line">    model_part_destination,</div>
<div class="line">    mapper_settings</div>
<div class="line">)</div>
</div><!-- fragment --><p>After constructing the <em>Mapper</em> / <em>MPI-Mapper</em> it can be used immediately to map any scalar and vector quantities, no further initialization is necessary.\ The <b>Map</b> function is used to map values from the <b>Origin</b> to the <b>Destination</b>. For this the <em>Variables</em> have to be specified. See the following example for mapping scalar quantities.</p>
<div class="fragment"><div class="line"><span class="comment"># mapping scalar quantities</span></div>
<div class="line"><span class="comment"># this maps the nodal quantities of TEMPERATURE on the origin-ModelPart</span></div>
<div class="line"><span class="comment"># to the nodal quantities of AMBIENT_TEMPERATURE on the destination-ModelPart</span></div>
<div class="line"> </div>
<div class="line">mapper.Map(KM.TEMPERATURE, KM.AMBIENT_TEMPERATURE)</div>
</div><!-- fragment --><p>The <b>Map</b> function is overloaded, this means that mapping vector quantities works in the same way as mapping scalar quantites.</p>
<div class="fragment"><div class="line"><span class="comment"># mapping vector quantities</span></div>
<div class="line"><span class="comment"># this maps the nodal quantities of VELOCITY on the origin-ModelPart</span></div>
<div class="line"><span class="comment"># to the nodal quantities of MESH_VELOCITY on the destination-ModelPart.</span></div>
<div class="line"> </div>
<div class="line">mapper.Map(KM.VELOCITY, KM.MESH_VELOCITY)</div>
</div><!-- fragment --><p>Mapping from <b>Destination</b> to <b>Origin</b> can be done using the <b>InverseMap</b> function which works in the same way as the <b>Map</b> function.</p>
<div class="fragment"><div class="line"><span class="comment"># inverse mapping scalar quantities</span></div>
<div class="line"><span class="comment"># this maps the nodal quantities of AMBIENT_TEMPERATURE on the destination-ModelPart</span></div>
<div class="line"><span class="comment"># to the nodal quantities of TEMPERATURE on the origin-ModelPart</span></div>
<div class="line"> </div>
<div class="line">mapper.InverseMap(KM.TEMPERATURE, KM.AMBIENT_TEMPERATURE)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># inverse mapping vector quantities</span></div>
<div class="line"><span class="comment"># this maps the nodal quantities of MESH_VELOCITY on the destination-ModelPart</span></div>
<div class="line"><span class="comment"># to the nodal quantities of VELOCITY on the origin-ModelPart</span></div>
<div class="line"> </div>
<div class="line">mapper.InverseMap(KM.VELOCITY, KM.MESH_VELOCITY)</div>
</div><!-- fragment --><p>For the 3D/2D metamapper the settings to consider are the following, where <code>base_mapper</code> is the backend mapper to be considered.</p>
<div class="fragment"><div class="line">mapper_params = KM.Parameters(&quot;&quot;&quot;{</div>
<div class="line">    &quot;mapper_type&quot;     : &quot;projection_3D_2D&quot;,</div>
<div class="line">    &quot;base_mapper&quot;     : &quot;nearest_neighbor&quot;,</div>
<div class="line">    &quot;search_settings&quot; : {},</div>
<div class="line">    &quot;echo_level&quot;      : 0</div>
<div class="line">}&quot;&quot;&quot;)</div>
</div><!-- fragment --><h2>Advanced Usage</h2>
<p>The previous section introduced the basics of using the <em><a class="el" href="../../d0/df1/namespace_mapping_application.html">MappingApplication</a></em>. The more advanced usage is explained in this section.</p>
<h3>Customizing the behavior of the mapping with Flags</h3>
<p>By default the mapping functions <b>Map</b> and <b>InverseMap</b> will overwrite the values where they map to. In order to add instead of overwrite the values the behavior can be customized by using <em><a class="el" href="../../d9/d4f/class_kratos_1_1_flags.html" title="Forward declaration.">Kratos::Flags</a></em>. Consider in the following example that several forces are acting on a surface. Overwritting the values would cancel the previously applied forces.</p>
<div class="fragment"><div class="line"><span class="comment"># Instead of overwriting, this will add the values to the existing ones</span></div>
<div class="line"> </div>
<div class="line">mapper.Map(KM.REACTION, KM.FORCE, KM.Mapper.ADD_VALUES)</div>
</div><!-- fragment --><p>Sometimes it can be necessary to swap the signs of quantites that are to be mapped. This can be done with the following:</p>
<div class="fragment"><div class="line"><span class="comment"># Swapping the sign, i.e. multiplying the values with (-1)</span></div>
<div class="line"> </div>
<div class="line">mapper.Map(KM.DISPLACEMENT, KM.MESH_DISPLACEMENT, KM.Mapper.SWAP_SIGN)</div>
</div><!-- fragment --><p>The flags can also be combined:</p>
<div class="fragment"><div class="line">mapper.Map(KM.REACTION, KM.FORCE, KM.Mapper.ADD_VALUES | KM.Mapper.SWAP_SIGN)</div>
</div><!-- fragment --><p>Historical nodal values are used by default. Mapping to an from nonhistorical nodal values is also supported, the following examples show the usage:</p>
<p>This maps the values from the origin (<code>REACTION</code>) as historical values to the destination (<code>FORCE</code>) as nonhistorical values:</p>
<div class="fragment"><div class="line">mapper.Map(KM.REACTION, KM.FORCE, KM.Mapper.TO_NON_HISTORICAL)</div>
</div><!-- fragment --><p>This maps the values from the origin (<code>REACTION</code>) as nonhistorical values to the destination (<code>FORCE</code>) as historical values:</p>
<div class="fragment"><div class="line">mapper.Map(KM.REACTION, KM.FORCE, KM.Mapper.FROM_NON_HISTORICAL)</div>
</div><!-- fragment --><p>This maps the values from the destination (<code>FORCE</code>) as historical values to the origin (<code>REACTION</code>) as nonhistorical values:</p>
<div class="fragment"><div class="line">mapper.InverseMap(KM.REACTION, KM.FORCE, KM.Mapper.TO_NON_HISTORICAL)</div>
</div><!-- fragment --><p>This maps the values from the destination (<code>FORCE</code>) as nonhistorical values to the origin (<code>REACTION</code>) as historical values:</p>
<div class="fragment"><div class="line">mapper.InverseMap(KM.REACTION, KM.FORCE, KM.Mapper.FROM_NON_HISTORICAL)</div>
</div><!-- fragment --><p>Of course it is possible to use both origin and destination nonhistorical. This maps the values from the origin (<code>REACTION</code>) as nonhistorical values to the destination (<code>FORCE</code>) as nonhistorical values:</p>
<div class="fragment"><div class="line">mapper.Map(KM.REACTION, KM.FORCE, KM.Mapper.FROM_NON_HISTORICAL | KM.Mapper.TO_NON_HISTORICAL)</div>
</div><!-- fragment --><p>Many <em>Mappers</em> internally construct a mapping matrix. It is possible to use the transpose of this matrix for mapping with <code>USE_TRANSPOSE</code>. This is often used for conservative mapping of forces in FSI, when the virtual work on both interfaces should be preserved.</p>
<div class="fragment"><div class="line">mapper.Map(KM.REACTION, KM.FORCE, KM.Mapper.USE_TRANSPOSE)</div>
</div><!-- fragment --><h3>Updating the Interface</h3>
<p>In case of moving interfaces (e.g. in a problem involving Contact between bodies) it can become necessary to update the <em>Mapper</em> to take the new geometrical positions of the interfaces into account.\ One way of doing this would be to construct a new <em>Mapper</em>, but this is not efficient and sometimes not even possible.</p>
<p>Hence the <em>Mapper</em> provides the <b>UpdateInterface</b> function for updating itseld with respect to the new geometrical positions of the interfaces.\ Note that this is potentially an expensive operation due to searching the new geometrical neighbors on the interface.</p>
<div class="fragment"><div class="line">mapper.UpdateInterface()</div>
</div><!-- fragment --><h3>Checking which mappers are available</h3>
<p>The following can be used to see which <em>Mappers</em> are available:</p>
<div class="fragment"><div class="line"><span class="comment"># available mappers for shared memory</span></div>
<div class="line">KM.MapperFactory.GetRegisteredMapperNames()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># available mappers for distributed memory</span></div>
<div class="line">MappingMPIExtension.MPIMapperFactory.GetRegisteredMapperNames()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># check if mapper for shared memory exists</span></div>
<div class="line">KM.MapperFactory.HasMapper(<span class="stringliteral">&quot;mapper_name&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># check if mapper for distributed memory exists</span></div>
<div class="line">MappingMPIExtension.MPIMapperFactory.HasMapper(<span class="stringliteral">&quot;mapper_name&quot;</span>)</div>
</div><!-- fragment --><h3>Search settings</h3>
<p>The search of neighbors / partners on the other side of the interface is a crucial task when creating the mapper. Especially in distributed computations (MPI) this can be very expensive and time consuming. Hence the search of the mapper is very optimized to provide robust and fast results. For this the search works in several iterations where the search radius is increased in each iteration. The default settings of the search are working fine in most cases, but in some special cases it might still be necessary to tweak and optimize the settings. The following settings are available (as sub-parameter <code>search_settings</code> of the settings that are given to the mapper):</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">type   </th><th class="markdownTableHeadNone">default   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>search_radius</code>   </td><td class="markdownTableBodyNone"><code>double</code>   </td><td class="markdownTableBodyNone">computed   </td><td class="markdownTableBodyNone">The search radius to start with in the first iteration. In each next iteration it will be increased by multiplying with <code>search_radius_increase_factor</code> (<code>search_radius *= search_radius_increase_factor</code>)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>max_search_radius</code>   </td><td class="markdownTableBodyNone"><code>double</code>   </td><td class="markdownTableBodyNone">computed   </td><td class="markdownTableBodyNone">The max search radius to use.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>search_radius_increase_factor</code>   </td><td class="markdownTableBodyNone"><code>double</code>   </td><td class="markdownTableBodyNone"><code>2.0</code>   </td><td class="markdownTableBodyNone">factor by which the search radius is increasing in each search iteration (see above). <b>Tuning this parameter is usually the best way to achieve a faster search</b>. In many cases decreasing it will speed up the search, especially for volumetric mapping, but it is case dependent.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>max_num_search_iterations</code>   </td><td class="markdownTableBodyNone"><code>int</code>   </td><td class="markdownTableBodyNone">computed (min 3)   </td><td class="markdownTableBodyNone">max number of search iterations that is conducted. If the search is successful before then it will terminate earlier. The more heterogeneous the mesh the larger this will be.   </td></tr>
</table>
<p>It is recommended to set the <code>echo_level</code> to 2 or higher for getting useful information from the search. This will help to debug the search in case of problems.</p>
<h2>Available Mappers</h2>
<p>This section explains the theory behind the mappers.</p>
<h3>Nearest Neighbor</h3>
<p>The <em>NearestNeighborMapper</em> is a very simple/basic <em>Mapper</em>. Searches its closest neighbor (node) on the other interface. During mapping it gets/sets its value to the value of its closest neighbor.</p>
<p>This mapper is best suited for problems where both interfaces have a similar discretization. Furthermore it is very robust and can be used for setting up problems when one does not (yet) want to deal with mapping.</p>
<p>Internally it constructs the mapping matrix, hence it offers the usage of the transposed mapping matrix. When using this, for very inhomogenous interface discretizations it can come to oscillations in the mapped quantities.</p>
<p><b>Supported mesh topologies</b>: This mapper only works with nodes and hence supports any mesh topology</p>
<h3>Nearest Element</h3>
<p>The <em>NearestElementMapper</em> projects nodes to the elements( or conditions) on other side of the inteface. Mapping is then done by interpolating the values of the nodes of the elements by using the shape functions at the projected position.</p>
<p>This mapper is best suited for problems where the <em>NearestNeighborMapper</em> cannot be used, i.e. for cases where the discretization on the interfaces is different. Note that it is less robust than the <em>NearestNeighborMapper</em> due to the projections it performs. In case a projection fails, it uses an approximation that is similar to the approach of the <em>NearestNeighborMapper</em>. This can be disabled by setting <code>use_approximation</code> to <code>false</code> in the mapper-settings.</p>
<p>Internally it constructs the mapping matrix, hence it offers the usage of the transposed mapping matrix. When using this, for very inhomogenous interface discretizations it can come to oscillations in the mapped quantities.</p>
<p><b>Supported mesh topologies</b>: Any mesh topology available in <a class="el" href="../../db/d66/namespace_kratos.html" title="REF: G. R. Cowper, GAUSSIAN QUADRATURE FORMULAS FOR TRIANGLES.">Kratos</a>, which includes the most common linear and quadratic geometries, see <a href="../../../../kratos/geometries">here</a>.</p>
<h3>Barycentric</h3>
<p>The <em>BarycentricMapper</em> uses the closest nodes to reconstructs a geometry. This geometry is used in the same way as the <em>NearestElementMapper</em> for interpolating the values of the nodes using the shape functions.</p>
<p>This mapper can be used when no geometries are available and interpolative properties of the mapper are required. E.g. for particle methods when only nodes or point-based entities are available. Overall it can be seen as combining the advantages of the <em>NearestNeighborMapper</em> (which only requires points as input) with the advantages of the <em>NearestElementMapper</em> (which has interpolative properties). The disadvantage is that the reconstruction of the geometry can cause problems in complex situations, hence it should only be used if the <em>NearestElementMapper</em> cannot be used.</p>
<p>Furthermore, the geometry type for the reconstruction/interpolation has to be chosen with the <code>interpolation_type</code> setting. The following types are available: <code>line</code>, <code>triangle</code> and <code>tetrahedra</code></p>
<p>Internally it constructs the mapping matrix, hence it offers the usage of the transposed mapping matrix. When using this, for very inhomogenous interface discretizations it can come to oscillations in the mapped quantities.</p>
<p><b>Supported mesh topologies</b>: This mapper only works with nodes and hence supports any mesh topology</p>
<h2>When to use which Mapper?</h2>
<ul>
<li><b>Matching Interface</b>\ For a matching interface the <em>NearestNeighborMapper</em> is the best / fastes choice. Note that the ordering / numbering of the nodes doesn't matter.</li>
<li><b>Interfaces with almost matching discretizations</b>\ In this case both the <em>NearestNeighborMapper</em> and the <em>NearestElementMapper</em> can yield good results.</li>
<li><b>Interfaces with non matching discretizations</b>\ The <em>NearestElementMapper</em> is recommended because it results in smoother mapping results due to the interpolation using the shape functions.</li>
<li><b>Interfaces with non matching discretizations when no geometries are available for interpolation</b>\ The <em>NearestElementMapper</em> cannot be used as it requires geometries for the ionterpolation. Here the <em>BarycentricMapper</em> is recommended because it reconstructs geometries from the surrounding nodes and then uses it to interpolate.</li>
</ul>
<h2>Using the Mapper for ModelParts that are not part of all ranks</h2>
<p>In MPI parallel simulations usually all <code>ModelParts</code> are distributed across all ranks. However in some cases this does not hold, for example in FSI when the fluid runs on all ranks but the structure runs serial on one rank. In this case it is necessary to do the following:</p>
<ul>
<li>Create a dummy-<code>ModelPart</code> on the ranks that do not have the original ModelPart.</li>
<li><b>IMPORTANT</b>: This <code>ModelPart</code> must have a <code>DataCommunicator</code> that is not defined on the ranks that are not part of the original <code>ModelPart</code>.</li>
<li>Create and MPI-mapper as explained <a href="../../#basic-usage">above</a>, using the original and the dummy <code>ModelPart</code>s on the respective ranks.</li>
</ul>
<p>Check <a href="https://github.com/KratosMultiphysics/Kratos/blob/master/applications/MappingApplication/tests/blade_mapping_test.py">this test</a> for more details and usage example.</p>
<p>For an example the following assumptions are made:</p>
<ul>
<li>Overall 4 MPI processes are used</li>
<li><code>model_part_fluid</code> is distributed across all 4 ranks</li>
<li><code>model_part_structure</code> is not distributed and exists only on rank 0</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">import</span> KratosMultiphysics <span class="keyword">as</span> KM</div>
<div class="line"><span class="keyword">import</span> <a class="code" href="../../d8/d5e/namespace_kratos_multiphysics_1_1mpi.html">KratosMultiphysics.mpi</a> <span class="keyword">as</span> KratosMPI</div>
<div class="line"> </div>
<div class="line"><span class="comment"># &quot;model_part_fluid&quot; was already read and exists on all ranks</span></div>
<div class="line"><span class="comment"># &quot;model_part_structure&quot; was already read and exists only on rank 0</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># getting the DataCommunicator that wraps `MPI_COMM_WORLD` i.e. contains all ranks</span></div>
<div class="line">world_data_comm = KM.ParallelEnvironment.GetDataCommunicator(<span class="stringliteral">&quot;World)</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral"></span><span class="comment"># define the ranks on which the structure ModelPart exists</span></div>
<div class="line"><span class="comment"># structure can also be distributed across several (but not all) ranks</span></div>
<div class="line">structure_ranks = [0]</div>
<div class="line"> </div>
<div class="line"><span class="comment"># create a DataCommunicator containing only the structure ranks</span></div>
<div class="line">structure_ranks_data_comm_name = <span class="stringliteral">&quot;structure_ranks&quot;</span></div>
<div class="line">data_comm_all_structure_ranks = KratosMPI.DataCommunicatorFactory.CreateFromRanksAndRegister(</div>
<div class="line">    world_data_comm,</div>
<div class="line">    structure_ranks,</div>
<div class="line">    structure_ranks_data_comm_name)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># create a dummy ModelPart on the ranks where the original ModelPart does not exist</span></div>
<div class="line"><span class="keywordflow">if</span> world_data_comm.Rank() <span class="keywordflow">not</span> <span class="keywordflow">in</span> structure_ranks:</div>
<div class="line">    dummy_model = KM.Model()</div>
<div class="line">    model_part_structure = dummy_model.CreateModelPart(<span class="stringliteral">&quot;structure_dummy&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Important: set the DataCommunicator so that the Mapper knows on which ranks the ModelPart is only a dummy</span></div>
<div class="line">    KratosMPI.ModelPartCommunicatorUtilities.SetMPICommunicator(model_part_structure, data_comm_all_structure_ranks)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># now the Mapper can be created with the original and the dummy ModelParts</span></div>
<div class="line">mpi_mapper = MappingMPIExtension.MPIMapperFactory.CreateMapper(</div>
<div class="line">    model_part_fluid,</div>
<div class="line">    model_part_structure,</div>
<div class="line">    mapper_settings</div>
<div class="line">)</div>
<div class="ttc" id="anamespace_kratos_multiphysics_1_1mpi_html"><div class="ttname"><a href="../../d8/d5e/namespace_kratos_multiphysics_1_1mpi.html">mpi</a></div></div>
</div><!-- fragment --><h2>Miscellaneous functionalities</h2>
<ul>
<li><p class="startli"><a href="https://github.com/KratosMultiphysics/Kratos/blob/master/applications/MappingApplication/python_scripts/serial_output_process.py">serial_output_process</a>: This process can be used to map results to one rank and then do postprocessing on this rank. This has two advantages:</p><ul>
<li>Some output formats write one file per rank in distributed simulations, which leads to many files when running with many cores. This process collects the results on one rank and can hence reduce the number of files significantly</li>
<li>Different meshes can be used to do the postprocessing. This is in particular useful when the computational mesh is very fine, but a coarser mesh would be sufficient for postprocessing.</li>
</ul>
<p class="startli"><ins>The following input parameters are used:</ins></p><ul>
<li><code>model_part_name_origin</code>: name of the origin ModelPart where the data comes from (is being mapped from)</li>
<li><code>model_part_name_destination</code>: name of destination ModelPart where the data is mapped to. This ModelPart is being read.</li>
<li><code>mdpa_file_name_destination</code>: name of the mdpa file containing the mesh that is used for the destination</li>
<li><code>historical_variables_destination</code> list of historical variables that are allocated on the destination ModelPart</li>
<li><code>destination_rank</code> rank on which the processing of the destination happens (i.e. the rank on which the destination ModelPart is read). Note that this increases the memory usage significantly, especially for large destination meshes. The default is rank 0, which in most distributed simulations acts as the master rank with already increased computational effort. Hence it can make sense to use another rank, preferably on another compute node, to optimize the memory and computational load balance</li>
<li><code>mapper_settings</code>: setting that are passed to the mapper, as explained above</li>
<li><code>mapping_settings</code>: list of mapping steps to be executed before the postprocessing is done. <code>variable_origin</code> and <code>variable_destination</code> must be specified, while <code>mapping_options</code> is optional and can contain the flags as explained above.</li>
<li><code>output_process_settings</code>: The settings for the output process (which will be only executed on the destination rank). <b>Important</b>: For mapping onto a serial ModelPart, the DataCommunicator is set as explained <a href="../../#using-the-mapper-for-modelparts-that-are-not-part-of-all-ranks">here</a>. This means that the destination ModelPart is not valid on other ranks and can hence not be used in the regular postprocessing (which happens also on the ranks where it is not valid and hence some MPI-functionalities would fail) Example input: <div class="fragment"><div class="line">&quot;python_module&quot; : &quot;serial_output_process&quot;,</div>
<div class="line">&quot;kratos_module&quot; : &quot;KratosMultiphysics.MappingApplication&quot;,</div>
<div class="line">&quot;Parameters&quot;    : {</div>
<div class="line">    &quot;model_part_name_origin&quot;      : &quot;FluidModelPart&quot;,</div>
<div class="line">    &quot;model_part_name_destination&quot; : &quot;PostProcessing&quot;,</div>
<div class="line">    &quot;mdpa_file_name_destination&quot;  : &quot;coarse_mesh&quot;,</div>
<div class="line">    &quot;historical_variables_destination&quot; : [&quot;REACTION&quot;, &quot;DISPLACEMENT&quot;],</div>
<div class="line">    &quot;mapper_settings&quot; :  {&quot;mapper_type&quot; : &quot;nearest_neighbor&quot;},</div>
<div class="line">    &quot;mapping_settings&quot; : [{</div>
<div class="line">        &quot;variable_origin&quot; : &quot;REACTION&quot;,</div>
<div class="line">        &quot;variable_destination&quot; : &quot;REACTION&quot;</div>
<div class="line">    },{</div>
<div class="line">        &quot;variable_origin&quot; : &quot;REACTION&quot;,</div>
<div class="line">        &quot;variable_destination&quot; : &quot;REACTION&quot;,</div>
<div class="line">        &quot;mapping_options&quot; : [&quot;add_values&quot;]</div>
<div class="line">    },{</div>
<div class="line">        &quot;variable_origin&quot; : &quot;MESH_DISPLACEMENT&quot;,</div>
<div class="line">        &quot;variable_destination&quot; : &quot;DISPLACEMENT&quot;</div>
<div class="line">    }],</div>
<div class="line">    &quot;output_process_settings&quot; : {</div>
<div class="line">        &quot;python_module&quot; : &quot;vtk_output_process&quot;,</div>
<div class="line">        &quot;kratos_module&quot; : &quot;KratosMultiphysics&quot;,</div>
<div class="line">        &quot;Parameters&quot;    : {</div>
<div class="line">            // ...</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ul>
</li>
</ul>
<h2>FAQ</h2>
<ul>
<li><b>Is mapping of elemental / conditional data or gauss-point values possible?</b>\ The mapper only supports mapping of nodal data. In order to map other quantities, those have to first be inter- / extrapolated to the nodes.</li>
<li><b>Something is not working with the mapping. What should I do?</b>\ Problems with mapping can have many sources. The first thing in debugging what is happening is to increase the <code>echo_level</code> of the <em>Mapper</em>. Then in many times warnings are shown in case of some problems.</li>
<li><b>I get oscillatory solutions when mapping with <code>USE_TRANSPOSE</code></b>\ Research has shown that "simple" mappers like <em>NearestNeighbor</em> and <em>NearestElement</em> can have problems with mapping with the transpose (i.e. when using <code>USE_TRANSPOSE</code>) if the meshes are very different. Using the <em>MortarMapper</em> technology can improve this situation. This <em>Mapper</em> is currently under development.</li>
<li><b>Projections find the wrong result</b>\ For complex geometries the projections can fail to find the correct result if many lines or surfaces are close. In those situations it helps to partition the mapping interface and construct multiple mappers with the smaller interfaces.</li>
<li><b>Creation of the mapper takes very long</b>\ Often this is because of of unfit search settings. If the settings are not suitable for the problem then the mapper creation time can increase several magnitudes! Check <a href="../../#search-settings">here</a> for an explanation of how to set the search settings in case the defaults are not working well. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 19 2024 03:34:01 for KratosMultiphysics by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
