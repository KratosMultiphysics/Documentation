<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KratosMultiphysics: Kratos::NormalCalculationUtils Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../kratos_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">KratosMultiphysics
   </div>
   <div id="projectbrief">KRATOS Multiphysics (Kratos) is a framework for building parallel, multi-disciplinary simulation software, aiming at modularity, extensibility, and high performance. Kratos is written in C++, and counts with an extensive Python interface.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../db/d66/namespace_kratos.html">Kratos</a></li><li class="navelem"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html">NormalCalculationUtils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../d8/d63/class_kratos_1_1_normal_calculation_utils-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Kratos::NormalCalculationUtils Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="../../d9/db3/normal__calculation__utils_8h_source.html">normal_calculation_utils.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Kratos::NormalCalculationUtils:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../d5/dbe/class_kratos_1_1_normal_calculation_utils__coll__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Type Definitions</div></td></tr>
<tr class="memitem:a98323bfeb21b297511225f9f905d5658"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a98323bfeb21b297511225f9f905d5658">IndexType</a></td></tr>
<tr class="memdesc:a98323bfeb21b297511225f9f905d5658"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index type definition.  <a href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a98323bfeb21b297511225f9f905d5658">More...</a><br /></td></tr>
<tr class="separator:a98323bfeb21b297511225f9f905d5658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623474556fb413412358b56bae0bfbb4"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a623474556fb413412358b56bae0bfbb4">SizeType</a></td></tr>
<tr class="memdesc:a623474556fb413412358b56bae0bfbb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size type definition.  <a href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a623474556fb413412358b56bae0bfbb4">More...</a><br /></td></tr>
<tr class="separator:a623474556fb413412358b56bae0bfbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db05e6d9e0ba056f89977fa663eaac3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="../../d5/ddd/class_kratos_1_1_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a8db05e6d9e0ba056f89977fa663eaac3">NodeType</a></td></tr>
<tr class="separator:a8db05e6d9e0ba056f89977fa663eaac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bc6154d698d68aa12d6e7278ba1f4a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="../../dc/dea/class_kratos_1_1_geometry.html">Geometry</a>&lt; <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a8db05e6d9e0ba056f89977fa663eaac3">NodeType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a03bc6154d698d68aa12d6e7278ba1f4a">GeometryType</a></td></tr>
<tr class="memdesc:a03bc6154d698d68aa12d6e7278ba1f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of geometries.  <a href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a03bc6154d698d68aa12d6e7278ba1f4a">More...</a><br /></td></tr>
<tr class="separator:a03bc6154d698d68aa12d6e7278ba1f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3d728d95778d9e22fd9ba3934796be"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html#af948f3ac7e1d253d0d5cbbd990e236b4">ModelPart::ConditionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a0d3d728d95778d9e22fd9ba3934796be">ConditionType</a></td></tr>
<tr class="memdesc:a0d3d728d95778d9e22fd9ba3934796be"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d1/d6e/class_kratos_1_1_condition.html" title="Base class for all Conditions.">Condition</a> type definition.  <a href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a0d3d728d95778d9e22fd9ba3934796be">More...</a><br /></td></tr>
<tr class="separator:a0d3d728d95778d9e22fd9ba3934796be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b1e5a039a6c4b7166095447d59820f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html#a0960956dac2688d5d72cdb874c450e1d">ModelPart::ConditionsContainerType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad9b1e5a039a6c4b7166095447d59820f">ConditionsArrayType</a></td></tr>
<tr class="memdesc:ad9b1e5a039a6c4b7166095447d59820f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditions array definition.  <a href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad9b1e5a039a6c4b7166095447d59820f">More...</a><br /></td></tr>
<tr class="separator:ad9b1e5a039a6c4b7166095447d59820f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93ded15c1489962eb06714fba53d286"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> = <a class="el" href="../../d1/d66/class_kratos_1_1_variable.html">Variable</a>&lt; <a class="el" href="../../d4/ddc/class_kratos_1_1array__1d.html">array_1d</a>&lt; <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>, 3 &gt; &gt;</td></tr>
<tr class="memdesc:ad93ded15c1489962eb06714fba53d286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal variable definition.  <a href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">More...</a><br /></td></tr>
<tr class="separator:ad93ded15c1489962eb06714fba53d286"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af48b3fbb88ad01ae515e202a774bf306"><td class="memTemplParams" colspan="2">template&lt;class TContainerType &gt; </td></tr>
<tr class="memitem:af48b3fbb88ad01ae515e202a774bf306"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#af48b3fbb88ad01ae515e202a774bf306">CalculateNormalsInContainer</a> (<a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;rModelPart, const <a class="el" href="../../d1/d66/class_kratos_1_1_variable.html">Variable</a>&lt; <a class="el" href="../../d4/ddc/class_kratos_1_1array__1d.html">array_1d</a>&lt; <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>, 3 &gt;&gt; &amp;rNormalVariable)</td></tr>
<tr class="separator:af48b3fbb88ad01ae515e202a774bf306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1931a0ba9fddac9fd18656fb77902c6c"><td class="memTemplParams" colspan="2">template&lt;class TContainerType , bool TIsHistorical&gt; </td></tr>
<tr class="memitem:a1931a0ba9fddac9fd18656fb77902c6c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a1931a0ba9fddac9fd18656fb77902c6c">InitializeNormals</a> (<a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;rModelPart, const <a class="el" href="../../d1/d66/class_kratos_1_1_variable.html">Variable</a>&lt; <a class="el" href="../../d4/ddc/class_kratos_1_1array__1d.html">array_1d</a>&lt; <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>, 3 &gt;&gt; &amp;rNormalVariable)</td></tr>
<tr class="separator:a1931a0ba9fddac9fd18656fb77902c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787053390bea7cf1b3ec21704a9b447c"><td class="memTemplParams" colspan="2">template&lt;class TContainerType , bool TIsHistorical&gt; </td></tr>
<tr class="memitem:a787053390bea7cf1b3ec21704a9b447c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a787053390bea7cf1b3ec21704a9b447c">CalculateUnitNormals</a> (<a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;rModelPart, const <a class="el" href="../../db/d66/namespace_kratos.html#a14b9d687ed53c882489400b57cdf34cd">bool</a> EnforceGenericGeometryAlgorithm, const <a class="el" href="../../d1/d66/class_kratos_1_1_variable.html">Variable</a>&lt; <a class="el" href="../../d4/ddc/class_kratos_1_1array__1d.html">array_1d</a>&lt; <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>, 3 &gt;&gt; &amp;rNormalVariable)</td></tr>
<tr class="separator:a787053390bea7cf1b3ec21704a9b447c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e799fc98cf944bb975411889a42d920"><td class="memTemplParams" colspan="2">template&lt;class TContainerType , bool TIsHistorical&gt; </td></tr>
<tr class="memitem:a3e799fc98cf944bb975411889a42d920"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a3e799fc98cf944bb975411889a42d920">ComputeUnitNormalsFromAreaNormals</a> (<a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;rModelPart, const <a class="el" href="../../d1/d66/class_kratos_1_1_variable.html">Variable</a>&lt; <a class="el" href="../../d4/ddc/class_kratos_1_1array__1d.html">array_1d</a>&lt; <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>, 3 &gt;&gt; &amp;rNormalVariable)</td></tr>
<tr class="separator:a3e799fc98cf944bb975411889a42d920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cdc5d1203e442121089169ed724b63"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa5cdc5d1203e442121089169ed724b63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html#a0960956dac2688d5d72cdb874c450e1d">ModelPart::ConditionsContainerType</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#aa5cdc5d1203e442121089169ed724b63">GetContainer</a> (<a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;rModelPart)</td></tr>
<tr class="separator:aa5cdc5d1203e442121089169ed724b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operations</div></td></tr>
<tr class="memitem:aca249c7f60384bed1e864c22229968dd"><td class="memTemplParams" colspan="2">template&lt;class TContainerType &gt; </td></tr>
<tr class="memitem:aca249c7f60384bed1e864c22229968dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#aca249c7f60384bed1e864c22229968dd">CalculateNormalsInContainer</a> (<a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;rModelPart, const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;rNormalVariable=NORMAL)</td></tr>
<tr class="memdesc:aca249c7f60384bed1e864c22229968dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">It computes the normal in the conditions.  <a href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#aca249c7f60384bed1e864c22229968dd">More...</a><br /></td></tr>
<tr class="separator:aca249c7f60384bed1e864c22229968dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b1876206fef09319364ec0eb0d59e5"><td class="memTemplParams" colspan="2">template&lt;class TContainerType , bool TIsHistorical = true&gt; </td></tr>
<tr class="memitem:a03b1876206fef09319364ec0eb0d59e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a03b1876206fef09319364ec0eb0d59e5">CalculateNormals</a> (<a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;rModelPart, const <a class="el" href="../../db/d66/namespace_kratos.html#a14b9d687ed53c882489400b57cdf34cd">bool</a> EnforceGenericGeometryAlgorithm=false, const <a class="el" href="../../db/d66/namespace_kratos.html#a14b9d687ed53c882489400b57cdf34cd">bool</a> ConsiderUnitNormal=false, const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;rNormalVariable=NORMAL)</td></tr>
<tr class="memdesc:a03b1876206fef09319364ec0eb0d59e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">It computes the mean of the normal in the entities and in all the nodes.  <a href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a03b1876206fef09319364ec0eb0d59e5">More...</a><br /></td></tr>
<tr class="separator:a03b1876206fef09319364ec0eb0d59e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667d6aa925478e50927e964ac6d035ca"><td class="memTemplParams" colspan="2">template&lt;class TContainerType , bool TIsHistorical = true&gt; </td></tr>
<tr class="memitem:a667d6aa925478e50927e964ac6d035ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a667d6aa925478e50927e964ac6d035ca">CalculateUnitNormals</a> (<a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;rModelPart, const <a class="el" href="../../db/d66/namespace_kratos.html#a14b9d687ed53c882489400b57cdf34cd">bool</a> EnforceGenericGeometryAlgorithm=false, const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;rNormalVariable=NORMAL)</td></tr>
<tr class="memdesc:a667d6aa925478e50927e964ac6d035ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">It computes the mean of the normal in the entities and in all the nodes (unit normal version)  <a href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a667d6aa925478e50927e964ac6d035ca">More...</a><br /></td></tr>
<tr class="separator:a667d6aa925478e50927e964ac6d035ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e07c770ecbdf64b5e64b81cc7ba090"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad3e07c770ecbdf64b5e64b81cc7ba090">CalculateOnSimplex</a> (<a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad9b1e5a039a6c4b7166095447d59820f">ConditionsArrayType</a> &amp;rConditions, const std::size_t Dimension, const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;rNormalVariable=NORMAL)</td></tr>
<tr class="memdesc:ad3e07c770ecbdf64b5e64b81cc7ba090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the "area normal" (vector oriented as the normal with a dimension proportional to the area).  <a href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad3e07c770ecbdf64b5e64b81cc7ba090">More...</a><br /></td></tr>
<tr class="separator:ad3e07c770ecbdf64b5e64b81cc7ba090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f50daec0dab23c132d7e6fcb544f42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#af2f50daec0dab23c132d7e6fcb544f42">CalculateOnSimplexNonHistorical</a> (<a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad9b1e5a039a6c4b7166095447d59820f">ConditionsArrayType</a> &amp;rConditions, const std::size_t Dimension, const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;rNormalVariable=NORMAL)</td></tr>
<tr class="memdesc:af2f50daec0dab23c132d7e6fcb544f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the "area normal" in the non-historical database (vector oriented as the normal with a dimension proportional to the area).  <a href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#af2f50daec0dab23c132d7e6fcb544f42">More...</a><br /></td></tr>
<tr class="separator:af2f50daec0dab23c132d7e6fcb544f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bcc1f86edc16fd865af8c24c65831f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#af5bcc1f86edc16fd865af8c24c65831f">CalculateNormalShapeDerivativesOnSimplex</a> (<a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad9b1e5a039a6c4b7166095447d59820f">ConditionsArrayType</a> &amp;rConditions, const std::size_t Dimension)</td></tr>
<tr class="memdesc:af5bcc1f86edc16fd865af8c24c65831f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates nodal area normal shape sensitivities w.r.t. nodal coordinates of the condition.  <a href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#af5bcc1f86edc16fd865af8c24c65831f">More...</a><br /></td></tr>
<tr class="separator:af5bcc1f86edc16fd865af8c24c65831f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10ac277a49e8a59b52e1b471592ab24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#af10ac277a49e8a59b52e1b471592ab24">CalculateOnSimplex</a> (<a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;rModelPart, const std::size_t Dimension, const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;rNormalVariable=NORMAL)</td></tr>
<tr class="memdesc:af10ac277a49e8a59b52e1b471592ab24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the area normal (vector oriented as the normal with a dimension proportional to the area).  <a href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#af10ac277a49e8a59b52e1b471592ab24">More...</a><br /></td></tr>
<tr class="separator:af10ac277a49e8a59b52e1b471592ab24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0943ec6c3f39f787fa4ac72486dcb5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad0943ec6c3f39f787fa4ac72486dcb5b">CalculateOnSimplexNonHistorical</a> (<a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;rModelPart, const std::size_t Dimension, const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;rNormalVariable=NORMAL)</td></tr>
<tr class="memdesc:ad0943ec6c3f39f787fa4ac72486dcb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the area normal in the non-historical database (vector oriented as the normal with a dimension proportional to the area).  <a href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad0943ec6c3f39f787fa4ac72486dcb5b">More...</a><br /></td></tr>
<tr class="separator:ad0943ec6c3f39f787fa4ac72486dcb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f6610904b1fb92c0cbd068cb6fb580"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a16f6610904b1fb92c0cbd068cb6fb580">CalculateOnSimplex</a> (<a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;rModelPart, const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;rNormalVariable=NORMAL)</td></tr>
<tr class="memdesc:a16f6610904b1fb92c0cbd068cb6fb580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the area normal (vector oriented as the normal with a dimension proportional to the area).  <a href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a16f6610904b1fb92c0cbd068cb6fb580">More...</a><br /></td></tr>
<tr class="separator:a16f6610904b1fb92c0cbd068cb6fb580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6dd4a2cbaca7012707a420e35ae4b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a8c6dd4a2cbaca7012707a420e35ae4b1">CalculateOnSimplexNonHistorical</a> (<a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;rModelPart, const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;rNormalVariable=NORMAL)</td></tr>
<tr class="memdesc:a8c6dd4a2cbaca7012707a420e35ae4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the area normal in the non-historical database (vector oriented as the normal with a dimension proportional to the area).  <a href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a8c6dd4a2cbaca7012707a420e35ae4b1">More...</a><br /></td></tr>
<tr class="separator:a8c6dd4a2cbaca7012707a420e35ae4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cbab837a6b001fec85b87a1ecfe9cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ae0cbab837a6b001fec85b87a1ecfe9cb">SwapNormals</a> (<a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;rModelPart)</td></tr>
<tr class="memdesc:ae0cbab837a6b001fec85b87a1ecfe9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function swaps the normal of all of the conditions in a model part.  <a href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ae0cbab837a6b001fec85b87a1ecfe9cb">More...</a><br /></td></tr>
<tr class="separator:ae0cbab837a6b001fec85b87a1ecfe9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad422edbbdc921855cef6b5bcd5877ec5"><td class="memTemplParams" colspan="2">template&lt;class TValueType &gt; </td></tr>
<tr class="memitem:ad422edbbdc921855cef6b5bcd5877ec5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad422edbbdc921855cef6b5bcd5877ec5">CalculateOnSimplex</a> (<a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;rModelPart, const std::size_t Dimension, const <a class="el" href="../../d1/d66/class_kratos_1_1_variable.html">Variable</a>&lt; TValueType &gt; &amp;rVariable, const TValueType Zero, const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;rNormalVariable=NORMAL)</td></tr>
<tr class="memdesc:ad422edbbdc921855cef6b5bcd5877ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the area normal (vector oriented as the normal with a dimension proportional to the area) using only nodes marked with a flag variable.  <a href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad422edbbdc921855cef6b5bcd5877ec5">More...</a><br /></td></tr>
<tr class="separator:ad422edbbdc921855cef6b5bcd5877ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcabe41925051cef90e662f2c97bcad7"><td class="memTemplParams" colspan="2">template&lt;class TValueType &gt; </td></tr>
<tr class="memitem:adcabe41925051cef90e662f2c97bcad7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#adcabe41925051cef90e662f2c97bcad7">CalculateOnSimplex</a> (<a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;rModelPart, const std::size_t Dimension, const <a class="el" href="../../d1/d66/class_kratos_1_1_variable.html">Variable</a>&lt; TValueType &gt; &amp;rVariable)</td></tr>
<tr class="memdesc:adcabe41925051cef90e662f2c97bcad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the area normal (vector oriented as the normal with a dimension proportional to the area) using only nodes marked with a flag variable.  <a href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#adcabe41925051cef90e662f2c97bcad7">More...</a><br /></td></tr>
<tr class="separator:adcabe41925051cef90e662f2c97bcad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4276de6dcdd814eb90e434303c56fda"><td class="memTemplParams" colspan="2">template&lt;class TValueType &gt; </td></tr>
<tr class="memitem:ac4276de6dcdd814eb90e434303c56fda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ac4276de6dcdd814eb90e434303c56fda">CalculateOnSimplex</a> (<a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;rModelPart, const std::size_t Dimension, const <a class="el" href="../../d1/d66/class_kratos_1_1_variable.html">Variable</a>&lt; TValueType &gt; &amp;rVariable, const TValueType Zero, const <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a> rAlpha, const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;rNormalVariable=NORMAL)</td></tr>
<tr class="memdesc:ac4276de6dcdd814eb90e434303c56fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the area normal (vector oriented as the normal with a dimension proportional to the area) using only nodes marked with a flag variable and detecting corners. Corners are defined as nodes that recieves more than 2 normals from their neighbor conditions with a difference in angle greater than Alpha .  <a href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ac4276de6dcdd814eb90e434303c56fda">More...</a><br /></td></tr>
<tr class="separator:ac4276de6dcdd814eb90e434303c56fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303dc49b81bde1c3b8d2ee7a315f0e50"><td class="memTemplParams" colspan="2">template&lt;class TValueType &gt; </td></tr>
<tr class="memitem:a303dc49b81bde1c3b8d2ee7a315f0e50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a303dc49b81bde1c3b8d2ee7a315f0e50">CalculateOnSimplexLowMemory</a> (<a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;rModelPart, <a class="el" href="../../db/d66/namespace_kratos.html#ac398e9982e45de7167981e05b7f5ff57">int</a> Dimension, const <a class="el" href="../../d1/d66/class_kratos_1_1_variable.html">Variable</a>&lt; TValueType &gt; &amp;rVariable, const TValueType Zero, const <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a> rAlpha, const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;rNormalVariable=NORMAL)</td></tr>
<tr class="memdesc:a303dc49b81bde1c3b8d2ee7a315f0e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the area normal (vector oriented as the normal with a dimension proportional to the area) using only nodes marked with a flag variable and detecting corners. Corners are defined as nodes that recieves more than 2 normals from their neighbor conditions with a difference in angle greater than Alpha . (Low memory version)  <a href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a303dc49b81bde1c3b8d2ee7a315f0e50">More...</a><br /></td></tr>
<tr class="separator:a303dc49b81bde1c3b8d2ee7a315f0e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad9b1e5a039a6c4b7166095447d59820f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b1e5a039a6c4b7166095447d59820f">&#9670;&nbsp;</a></span>ConditionsArrayType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html#a0960956dac2688d5d72cdb874c450e1d">ModelPart::ConditionsContainerType</a> <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad9b1e5a039a6c4b7166095447d59820f">Kratos::NormalCalculationUtils::ConditionsArrayType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conditions array definition. </p>

</div>
</div>
<a id="a0d3d728d95778d9e22fd9ba3934796be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3d728d95778d9e22fd9ba3934796be">&#9670;&nbsp;</a></span>ConditionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html#af948f3ac7e1d253d0d5cbbd990e236b4">ModelPart::ConditionType</a> <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a0d3d728d95778d9e22fd9ba3934796be">Kratos::NormalCalculationUtils::ConditionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="../../d1/d6e/class_kratos_1_1_condition.html" title="Base class for all Conditions.">Condition</a> type definition. </p>

</div>
</div>
<a id="a03bc6154d698d68aa12d6e7278ba1f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03bc6154d698d68aa12d6e7278ba1f4a">&#9670;&nbsp;</a></span>GeometryType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../dc/dea/class_kratos_1_1_geometry.html">Geometry</a>&lt;<a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a8db05e6d9e0ba056f89977fa663eaac3">NodeType</a>&gt; <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a03bc6154d698d68aa12d6e7278ba1f4a">Kratos::NormalCalculationUtils::GeometryType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of geometries. </p>

</div>
</div>
<a id="a98323bfeb21b297511225f9f905d5658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98323bfeb21b297511225f9f905d5658">&#9670;&nbsp;</a></span>IndexType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a98323bfeb21b297511225f9f905d5658">Kratos::NormalCalculationUtils::IndexType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The index type definition. </p>

</div>
</div>
<a id="a8db05e6d9e0ba056f89977fa663eaac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db05e6d9e0ba056f89977fa663eaac3">&#9670;&nbsp;</a></span>NodeType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d5/ddd/class_kratos_1_1_node.html">Node</a> <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a8db05e6d9e0ba056f89977fa663eaac3">Kratos::NormalCalculationUtils::NodeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad93ded15c1489962eb06714fba53d286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93ded15c1489962eb06714fba53d286">&#9670;&nbsp;</a></span>NormalVariableType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">Kratos::NormalCalculationUtils::NormalVariableType</a> =  <a class="el" href="../../d1/d66/class_kratos_1_1_variable.html">Variable</a>&lt;<a class="el" href="../../d4/ddc/class_kratos_1_1array__1d.html">array_1d</a>&lt;<a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>,3&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normal variable definition. </p>

</div>
</div>
<a id="a623474556fb413412358b56bae0bfbb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623474556fb413412358b56bae0bfbb4">&#9670;&nbsp;</a></span>SizeType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#a623474556fb413412358b56bae0bfbb4">Kratos::NormalCalculationUtils::SizeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size type definition. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a03b1876206fef09319364ec0eb0d59e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b1876206fef09319364ec0eb0d59e5">&#9670;&nbsp;</a></span>CalculateNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType , bool TIsHistorical = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Kratos::NormalCalculationUtils::CalculateNormals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;&#160;</td>
          <td class="paramname"><em>rModelPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d66/namespace_kratos.html#a14b9d687ed53c882489400b57cdf34cd">bool</a>&#160;</td>
          <td class="paramname"><em>EnforceGenericGeometryAlgorithm</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d66/namespace_kratos.html#a14b9d687ed53c882489400b57cdf34cd">bool</a>&#160;</td>
          <td class="paramname"><em>ConsiderUnitNormal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;&#160;</td>
          <td class="paramname"><em>rNormalVariable</em> = <code>NORMAL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It computes the mean of the normal in the entities and in all the nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rModelPart</td><td>The model part to compute </td></tr>
    <tr><td class="paramname">EnforceGenericGeometryAlgorithm</td><td>If enforce the generic algorithm for any kind of geometry </td></tr>
    <tr><td class="paramname">ConsiderUnitNormal</td><td>In order to consider directly the unit normal instead of the area normal multiplied with a coefficient </td></tr>
    <tr><td class="paramname">rNormalVariable</td><td>Component variable storing the normal value </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEntity</td><td>The entity type considered </td></tr>
    <tr><td class="paramname">TIsHistorical</td><td>Specifies if the historical or non-historical nodal database is used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5bcc1f86edc16fd865af8c24c65831f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5bcc1f86edc16fd865af8c24c65831f">&#9670;&nbsp;</a></span>CalculateNormalShapeDerivativesOnSimplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Kratos::NormalCalculationUtils::CalculateNormalShapeDerivativesOnSimplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad9b1e5a039a6c4b7166095447d59820f">ConditionsArrayType</a> &amp;&#160;</td>
          <td class="paramname"><em>rConditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>Dimension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates nodal area normal shape sensitivities w.r.t. nodal coordinates of the condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rConditions</td><td>List of conditions where shape sensitivities need to be calculated. </td></tr>
    <tr><td class="paramname">Dimension</td><td>Dimensionality of the conditions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca249c7f60384bed1e864c22229968dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca249c7f60384bed1e864c22229968dd">&#9670;&nbsp;</a></span>CalculateNormalsInContainer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Kratos::NormalCalculationUtils::CalculateNormalsInContainer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;&#160;</td>
          <td class="paramname"><em>rModelPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;&#160;</td>
          <td class="paramname"><em>rNormalVariable</em> = <code>NORMAL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It computes the normal in the conditions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rModelPart</td><td>The model part to compute </td></tr>
    <tr><td class="paramname">rNormalVariable</td><td>Component variable storing the normal value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af48b3fbb88ad01ae515e202a774bf306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af48b3fbb88ad01ae515e202a774bf306">&#9670;&nbsp;</a></span>CalculateNormalsInContainer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Kratos::NormalCalculationUtils::CalculateNormalsInContainer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;&#160;</td>
          <td class="paramname"><em>rModelPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d66/class_kratos_1_1_variable.html">Variable</a>&lt; <a class="el" href="../../d4/ddc/class_kratos_1_1array__1d.html">array_1d</a>&lt; <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>, 3 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rNormalVariable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3e07c770ecbdf64b5e64b81cc7ba090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e07c770ecbdf64b5e64b81cc7ba090">&#9670;&nbsp;</a></span>CalculateOnSimplex() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Kratos::NormalCalculationUtils::CalculateOnSimplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad9b1e5a039a6c4b7166095447d59820f">ConditionsArrayType</a> &amp;&#160;</td>
          <td class="paramname"><em>rConditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>Dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;&#160;</td>
          <td class="paramname"><em>rNormalVariable</em> = <code>NORMAL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the "area normal" (vector oriented as the normal with a dimension proportional to the area). </p>
<p>This is done on the base of the Conditions provided which should be understood as the surface elements of the area of interest. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rConditions</td><td>A set of conditions defining the "skin" of a model </td></tr>
    <tr><td class="paramname">Dimension</td><td>Spatial dimension (2 or 3) </td></tr>
    <tr><td class="paramname">rNormalVariable</td><td>Component variable storing the normal value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is not recommended for distributed (MPI) runs, as the user has to ensure that the calculated normals are assembled between processes. The overload of this function that takes a <a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html" title="This class aims to manage meshes for multi-physics simulations.">ModelPart</a> is preferable in ths case, as it performs the required communication. </dd></dl>

</div>
</div>
<a id="a16f6610904b1fb92c0cbd068cb6fb580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f6610904b1fb92c0cbd068cb6fb580">&#9670;&nbsp;</a></span>CalculateOnSimplex() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Kratos::NormalCalculationUtils::CalculateOnSimplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;&#160;</td>
          <td class="paramname"><em>rModelPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;&#160;</td>
          <td class="paramname"><em>rNormalVariable</em> = <code>NORMAL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the area normal (vector oriented as the normal with a dimension proportional to the area). </p>
<p>This is done on the base of the Conditions provided which should be understood as the surface elements of the area of interest. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rModelPart</td><td><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html" title="This class aims to manage meshes for multi-physics simulations.">ModelPart</a> of the problem. Must have a set of conditions defining the "skin" of the domain </td></tr>
    <tr><td class="paramname">rNormalVariable</td><td>Component variable storing the normal value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Use this fuction instead of its overload taking a Conditions array for MPI applications, as it will take care of communication between partitions. </dd></dl>

</div>
</div>
<a id="af10ac277a49e8a59b52e1b471592ab24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10ac277a49e8a59b52e1b471592ab24">&#9670;&nbsp;</a></span>CalculateOnSimplex() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Kratos::NormalCalculationUtils::CalculateOnSimplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;&#160;</td>
          <td class="paramname"><em>rModelPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>Dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;&#160;</td>
          <td class="paramname"><em>rNormalVariable</em> = <code>NORMAL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the area normal (vector oriented as the normal with a dimension proportional to the area). </p>
<p>This is done on the base of the Conditions provided which should be understood as the surface elements of the area of interest. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rModelPart</td><td><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html" title="This class aims to manage meshes for multi-physics simulations.">ModelPart</a> of the problem. Must have a set of conditions defining the "skin" of the domain </td></tr>
    <tr><td class="paramname">Dimension</td><td>Spatial dimension (2 or 3) </td></tr>
    <tr><td class="paramname">rNormalVariable</td><td>Component variable storing the normal value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Use this fuction instead of its overload taking a Conditions array for MPI applications, as it will take care of communication between partitions. </dd></dl>

</div>
</div>
<a id="adcabe41925051cef90e662f2c97bcad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcabe41925051cef90e662f2c97bcad7">&#9670;&nbsp;</a></span>CalculateOnSimplex() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Kratos::NormalCalculationUtils::CalculateOnSimplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;&#160;</td>
          <td class="paramname"><em>rModelPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>Dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d66/class_kratos_1_1_variable.html">Variable</a>&lt; TValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rVariable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the area normal (vector oriented as the normal with a dimension proportional to the area) using only nodes marked with a flag variable. </p>
<p>This function is equivalent to other implementations of CalculateOnSimplex, but instead of using all conditions in the array, it only uses those that contain a value of rVariable != Zero. This is useful in problems where a part of the boundary is a slip condition, as it provides more reasonable values for the normals on the border between this area and other parts of the boundary. This function is safe to use in MPI. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rModelPart</td><td><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html" title="This class aims to manage meshes for multi-physics simulations.">ModelPart</a> of the problem. Must have a set of conditions defining the "skin" of the domain. </td></tr>
    <tr><td class="paramname">Dimension</td><td>Spatial dimension (2 or 3). </td></tr>
    <tr><td class="paramname">rVariable</td><td>The <a class="el" href="../../d1/d66/class_kratos_1_1_variable.html" title="Variable class contains all information needed to store and retrive data from a data container.">Kratos::Variable</a> used to indicate which parts of the boundary will be used to calculate the normals. Conditions where rVariable == Zero will be skipped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4276de6dcdd814eb90e434303c56fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4276de6dcdd814eb90e434303c56fda">&#9670;&nbsp;</a></span>CalculateOnSimplex() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Kratos::NormalCalculationUtils::CalculateOnSimplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;&#160;</td>
          <td class="paramname"><em>rModelPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>Dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d66/class_kratos_1_1_variable.html">Variable</a>&lt; TValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rVariable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TValueType&#160;</td>
          <td class="paramname"><em>Zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>&#160;</td>
          <td class="paramname"><em>rAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;&#160;</td>
          <td class="paramname"><em>rNormalVariable</em> = <code>NORMAL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the area normal (vector oriented as the normal with a dimension proportional to the area) using only nodes marked with a flag variable and detecting corners. Corners are defined as nodes that recieves more than 2 normals from their neighbor conditions with a difference in angle greater than Alpha . </p>
<p>This function is equivalent to other implementations of CalculateOnSimplex, but instead of using all conditions in the array, it only uses those that contain a value of rVariable != Zero. This is useful in problems where a part of the boundary is a slip condition, as it provides more reasonable values for the normals on the border between this area and other parts of the boundary. This function is safe to use in MPI. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rModelPart</td><td><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html" title="This class aims to manage meshes for multi-physics simulations.">ModelPart</a> of the problem. Must have a set of conditions defining the "skin" of the domain. </td></tr>
    <tr><td class="paramname">Dimension</td><td>Spatial dimension (2 or 3). </td></tr>
    <tr><td class="paramname">rVariable</td><td>The <a class="el" href="../../d1/d66/class_kratos_1_1_variable.html" title="Variable class contains all information needed to store and retrive data from a data container.">Kratos::Variable</a> used to indicate which parts of the boundary will be used to calculate the normals. Conditions where rVariable == Zero will be skipped. </td></tr>
    <tr><td class="paramname">rAlpha</td><td>the maximum angle to distinguish normals. </td></tr>
    <tr><td class="paramname">rNormalVariable</td><td>Component variable storing the normal value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad422edbbdc921855cef6b5bcd5877ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad422edbbdc921855cef6b5bcd5877ec5">&#9670;&nbsp;</a></span>CalculateOnSimplex() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Kratos::NormalCalculationUtils::CalculateOnSimplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;&#160;</td>
          <td class="paramname"><em>rModelPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>Dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d66/class_kratos_1_1_variable.html">Variable</a>&lt; TValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rVariable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TValueType&#160;</td>
          <td class="paramname"><em>Zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;&#160;</td>
          <td class="paramname"><em>rNormalVariable</em> = <code>NORMAL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the area normal (vector oriented as the normal with a dimension proportional to the area) using only nodes marked with a flag variable. </p>
<p>This function is equivalent to other implementations of CalculateOnSimplex, but instead of using all conditions in the array, it only uses those that contain a value of rVariable != Zero. This is useful in problems where a part of the boundary is a slip condition, as it provides more reasonable values for the normals on the border between this area and other parts of the boundary. This function is safe to use in MPI. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rModelPart</td><td><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html" title="This class aims to manage meshes for multi-physics simulations.">ModelPart</a> of the problem. Must have a set of conditions defining the "skin" of the domain. </td></tr>
    <tr><td class="paramname">Dimension</td><td>Spatial dimension (2 or 3). </td></tr>
    <tr><td class="paramname">rVariable</td><td>The <a class="el" href="../../d1/d66/class_kratos_1_1_variable.html" title="Variable class contains all information needed to store and retrive data from a data container.">Kratos::Variable</a> used to indicate which parts of the boundary will be used to calculate the normals. </td></tr>
    <tr><td class="paramname">Zero</td><td>The 'off' value for the flag. Conditions where rVariable == Zero will be skipped for normal calculation. </td></tr>
    <tr><td class="paramname">rNormalVariable</td><td>Component variable storing the normal value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a303dc49b81bde1c3b8d2ee7a315f0e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303dc49b81bde1c3b8d2ee7a315f0e50">&#9670;&nbsp;</a></span>CalculateOnSimplexLowMemory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Kratos::NormalCalculationUtils::CalculateOnSimplexLowMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;&#160;</td>
          <td class="paramname"><em>rModelPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d66/namespace_kratos.html#ac398e9982e45de7167981e05b7f5ff57">int</a>&#160;</td>
          <td class="paramname"><em>Dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d66/class_kratos_1_1_variable.html">Variable</a>&lt; TValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rVariable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TValueType&#160;</td>
          <td class="paramname"><em>Zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>&#160;</td>
          <td class="paramname"><em>rAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;&#160;</td>
          <td class="paramname"><em>rNormalVariable</em> = <code>NORMAL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the area normal (vector oriented as the normal with a dimension proportional to the area) using only nodes marked with a flag variable and detecting corners. Corners are defined as nodes that recieves more than 2 normals from their neighbor conditions with a difference in angle greater than Alpha . (Low memory version) </p>
<p>This function is equivalent to other implementations of CalculateOnSimplex, but instead of using all conditions in the array, it only uses those that contain a value of rVariable != Zero. This is useful in problems where a part of the boundary is a slip condition, as it provides more reasonable values for the normals on the border between this area and other parts of the boundary. This function is safe to use in MPI. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rModelPart</td><td><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html" title="This class aims to manage meshes for multi-physics simulations.">ModelPart</a> of the problem. Must have a set of conditions defining the "skin" of the domain. </td></tr>
    <tr><td class="paramname">Dimension</td><td>Spatial dimension (2 or 3). </td></tr>
    <tr><td class="paramname">rVariable</td><td>The <a class="el" href="../../d1/d66/class_kratos_1_1_variable.html" title="Variable class contains all information needed to store and retrive data from a data container.">Kratos::Variable</a> used to indicate which parts of the boundary will be used to calculate the normals. Conditions where rVariable == Zero will be skipped. </td></tr>
    <tr><td class="paramname">rAlpha</td><td>the maximum angle to distinguish normals. </td></tr>
    <tr><td class="paramname">rNormalVariable</td><td>Component variable storing the normal value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2f50daec0dab23c132d7e6fcb544f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f50daec0dab23c132d7e6fcb544f42">&#9670;&nbsp;</a></span>CalculateOnSimplexNonHistorical() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Kratos::NormalCalculationUtils::CalculateOnSimplexNonHistorical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad9b1e5a039a6c4b7166095447d59820f">ConditionsArrayType</a> &amp;&#160;</td>
          <td class="paramname"><em>rConditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>Dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;&#160;</td>
          <td class="paramname"><em>rNormalVariable</em> = <code>NORMAL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the "area normal" in the non-historical database (vector oriented as the normal with a dimension proportional to the area). </p>
<p>This is done on the base of the Conditions provided which should be understood as the surface elements of the area of interest. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rConditions</td><td>A set of conditions defining the "skin" of a model </td></tr>
    <tr><td class="paramname">Dimension</td><td>Spatial dimension (2 or 3) </td></tr>
    <tr><td class="paramname">rNormalVariable</td><td>Component variable storing the normal value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is not recommended for distributed (MPI) runs, as the user has to ensure that the calculated normals are assembled between processes. The overload of this function that takes a <a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html" title="This class aims to manage meshes for multi-physics simulations.">ModelPart</a> is preferable in ths case, as it performs the required communication. </dd></dl>

</div>
</div>
<a id="a8c6dd4a2cbaca7012707a420e35ae4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6dd4a2cbaca7012707a420e35ae4b1">&#9670;&nbsp;</a></span>CalculateOnSimplexNonHistorical() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Kratos::NormalCalculationUtils::CalculateOnSimplexNonHistorical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;&#160;</td>
          <td class="paramname"><em>rModelPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;&#160;</td>
          <td class="paramname"><em>rNormalVariable</em> = <code>NORMAL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the area normal in the non-historical database (vector oriented as the normal with a dimension proportional to the area). </p>
<p>This is done on the base of the Conditions provided which should be understood as the surface elements of the area of interest. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rModelPart</td><td><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html" title="This class aims to manage meshes for multi-physics simulations.">ModelPart</a> of the problem. Must have a set of conditions defining the "skin" of the domain </td></tr>
    <tr><td class="paramname">rNormalVariable</td><td>Component variable storing the normal value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Use this fuction instead of its overload taking a Conditions array for MPI applications, as it will take care of communication between partitions. </dd></dl>

</div>
</div>
<a id="ad0943ec6c3f39f787fa4ac72486dcb5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0943ec6c3f39f787fa4ac72486dcb5b">&#9670;&nbsp;</a></span>CalculateOnSimplexNonHistorical() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Kratos::NormalCalculationUtils::CalculateOnSimplexNonHistorical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;&#160;</td>
          <td class="paramname"><em>rModelPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>Dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;&#160;</td>
          <td class="paramname"><em>rNormalVariable</em> = <code>NORMAL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the area normal in the non-historical database (vector oriented as the normal with a dimension proportional to the area). </p>
<p>This is done on the base of the Conditions provided which should be understood as the surface elements of the area of interest. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rModelPart</td><td><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html" title="This class aims to manage meshes for multi-physics simulations.">ModelPart</a> of the problem. Must have a set of conditions defining the "skin" of the domain </td></tr>
    <tr><td class="paramname">Dimension</td><td>Spatial dimension (2 or 3) </td></tr>
    <tr><td class="paramname">rNormalVariable</td><td>Component variable storing the normal value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Use this fuction instead of its overload taking a Conditions array for MPI applications, as it will take care of communication between partitions. </dd></dl>

</div>
</div>
<a id="a787053390bea7cf1b3ec21704a9b447c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787053390bea7cf1b3ec21704a9b447c">&#9670;&nbsp;</a></span>CalculateUnitNormals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType , bool TIsHistorical&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Kratos::NormalCalculationUtils::CalculateUnitNormals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;&#160;</td>
          <td class="paramname"><em>rModelPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d66/namespace_kratos.html#a14b9d687ed53c882489400b57cdf34cd">bool</a>&#160;</td>
          <td class="paramname"><em>EnforceGenericGeometryAlgorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d66/class_kratos_1_1_variable.html">Variable</a>&lt; <a class="el" href="../../d4/ddc/class_kratos_1_1array__1d.html">array_1d</a>&lt; <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>, 3 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rNormalVariable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a667d6aa925478e50927e964ac6d035ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667d6aa925478e50927e964ac6d035ca">&#9670;&nbsp;</a></span>CalculateUnitNormals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType , bool TIsHistorical = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Kratos::NormalCalculationUtils::CalculateUnitNormals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;&#160;</td>
          <td class="paramname"><em>rModelPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d66/namespace_kratos.html#a14b9d687ed53c882489400b57cdf34cd">bool</a>&#160;</td>
          <td class="paramname"><em>EnforceGenericGeometryAlgorithm</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddc/class_kratos_1_1_normal_calculation_utils.html#ad93ded15c1489962eb06714fba53d286">NormalVariableType</a> &amp;&#160;</td>
          <td class="paramname"><em>rNormalVariable</em> = <code>NORMAL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It computes the mean of the normal in the entities and in all the nodes (unit normal version) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rModelPart</td><td>The model part to compute </td></tr>
    <tr><td class="paramname">EnforceGenericGeometryAlgorithm</td><td>If enforce the generic algorithm for any kind of geometry </td></tr>
    <tr><td class="paramname">rNormalVariable</td><td>Component variable storing the normal value </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEntity</td><td>The entity type considered </td></tr>
    <tr><td class="paramname">TIsHistorical</td><td>Specifies if the historical or non-historical nodal database is used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e799fc98cf944bb975411889a42d920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e799fc98cf944bb975411889a42d920">&#9670;&nbsp;</a></span>ComputeUnitNormalsFromAreaNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType , bool TIsHistorical&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Kratos::NormalCalculationUtils::ComputeUnitNormalsFromAreaNormals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;&#160;</td>
          <td class="paramname"><em>rModelPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d66/class_kratos_1_1_variable.html">Variable</a>&lt; <a class="el" href="../../d4/ddc/class_kratos_1_1array__1d.html">array_1d</a>&lt; <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>, 3 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rNormalVariable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5cdc5d1203e442121089169ed724b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5cdc5d1203e442121089169ed724b63">&#9670;&nbsp;</a></span>GetContainer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html#a38ea8c8a7a801055130282bb5697a014">ModelPart::ElementsContainerType</a> &amp; Kratos::NormalCalculationUtils::GetContainer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;&#160;</td>
          <td class="paramname"><em>rModelPart</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1931a0ba9fddac9fd18656fb77902c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1931a0ba9fddac9fd18656fb77902c6c">&#9670;&nbsp;</a></span>InitializeNormals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TContainerType , bool TIsHistorical&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Kratos::NormalCalculationUtils::InitializeNormals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;&#160;</td>
          <td class="paramname"><em>rModelPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d66/class_kratos_1_1_variable.html">Variable</a>&lt; <a class="el" href="../../d4/ddc/class_kratos_1_1array__1d.html">array_1d</a>&lt; <a class="el" href="../../db/d66/namespace_kratos.html#ac77084a57869cbecf89d3ee2c819c5d3">double</a>, 3 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rNormalVariable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0cbab837a6b001fec85b87a1ecfe9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cbab837a6b001fec85b87a1ecfe9cb">&#9670;&nbsp;</a></span>SwapNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Kratos::NormalCalculationUtils::SwapNormals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html">ModelPart</a> &amp;&#160;</td>
          <td class="paramname"><em>rModelPart</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function swaps the normal of all of the conditions in a model part. </p>
<p>This is done by swapping the two first nodes in the geometry and is thus appropriate for simplicial elements </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rModelPart</td><td><a class="el" href="../../d1/d79/class_kratos_1_1_model_part.html" title="This class aims to manage meshes for multi-physics simulations.">ModelPart</a> of the problem. Must have a set of conditions defining the "skin" of the domain </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/Documentation/Documentation/master/kratos/utilities/<a class="el" href="../../d9/db3/normal__calculation__utils_8h_source.html">normal_calculation_utils.h</a></li>
<li>/home/runner/work/Documentation/Documentation/master/kratos/utilities/<a class="el" href="../../dc/d7f/normal__calculation__utils_8cpp.html">normal_calculation_utils.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 25 2024 03:23:26 for KratosMultiphysics by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
